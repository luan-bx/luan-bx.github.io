<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>实习面经</title>
      <link href="/2023/03/16/secret/meeting/"/>
      <url>/2023/03/16/secret/meeting/</url>
      
        <content type="html"><![CDATA[<h1 id="x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-美团-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D"><a href="#x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-美团-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 美团 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;"></a>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 美团 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</h1><h2 id="3-11-笔试"><a href="#3-11-笔试" class="headerlink" title="3.11 笔试"></a>3.11 笔试</h2><p>五道算法题，写出来 1 + 0.5 + 0.5</p><h2 id="3-16-一面"><a href="#3-16-一面" class="headerlink" title="3.16 一面"></a>3.16 一面</h2><blockquote><p>全程40分钟，聊了20min项目，10min算法题，10项目</p><ol><li>每个项目都问了一遍，主要是业务逻辑，夹带基础知识和解决方案</li><li>思考五分钟，讲了一下思路，考官说可以的，写代码的时候没写出来</li><li>还有哪块你做的比较好的我没问到的？讲了一下视频处理的部分（rtsp转rtmp、视频快&gt; 照、接入算法、存h264、识别结果base64编码成图片）</li></ol></blockquote><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ol><li>jvm   </li><li>垃圾处理怎么机制  </li><li>对象是什么时候被销毁</li></ol><h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><ol><li>数据上报</li></ol><blockquote><p>一秒达到多少数据量传输</p></blockquote><h3 id="PMS"><a href="#PMS" class="headerlink" title="PMS"></a>PMS</h3><ol><li>登陆状态</li></ol><p>cookie</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口继承</title>
      <link href="/2022/08/14/javacodeimplements/"/>
      <url>/2022/08/14/javacodeimplements/</url>
      
        <content type="html"><![CDATA[<h1 id="ApplicationRunner"><a href="#ApplicationRunner" class="headerlink" title="ApplicationRunner"></a>ApplicationRunner</h1><p>springBoot项目启动时，代码自启动</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Order</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HJ212Server</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationRunner</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span>ApplicationArguments args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">runEPServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 启动服务     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">runEPServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//相关操作，需要系统启动时自行运行的代码</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>若有多个代码段需要执行，可用@Order注解设置执行的顺序。<br><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/a1125527550c9c651a07d1711570328.png"></p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>方式一：继承Thread类</p><ol><li><p>定义子类继承Thread类。</p></li><li><p>子类中重写Thread类中的run方法。</p></li><li><p>创建Thread子类对象，即创建了线程对象。</p></li><li><p>调用线程对象start方法：启动线程，调用run方法。</p></li></ol><p>注意点：</p><ol><li><p>如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式。</p></li><li><p>run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统CPU调度决定。</p></li><li><p>想要启动多线程，必须调用start方法。</p></li><li><p>一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以上的异常 “IllegalThreadStateException”。</p></li></ol><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/47e4d123b9ee6068ddc5492f7443cb9b.png"></p><p>方式二：实现Runnable接口</p><ol><li><p>定义子类，实现Runnable接口。</p></li><li><p>子类中重写Runnable接口中的run方法。</p></li><li><p>通过Thread类含参构造器创建线程对象。</p></li><li><p>将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。</p></li><li><p>调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。</p></li></ol><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/ed21a78a26850abcd5709d4ec0131953.png"></p>]]></content>
      
      
      <categories>
          
          <category> 接口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
            <tag> Java </tag>
            
            <tag> 接口 </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件相关操作</title>
      <link href="/2022/07/10/javacodefile/"/>
      <url>/2022/07/10/javacodefile/</url>
      
        <content type="html"><![CDATA[<h1 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h1><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** 下载文件*/</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">downloadFile</span><span class="token punctuation">(</span>String proname<span class="token punctuation">,</span> String fileName<span class="token punctuation">,</span> HttpServletResponse resp<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        ProjectEntity projectEntity <span class="token operator">=</span> projectMapping<span class="token punctuation">.</span><span class="token function">getProjectByName</span><span class="token punctuation">(</span>proname<span class="token punctuation">)</span><span class="token punctuation">;</span>        ProductEntity productEntity <span class="token operator">=</span> productMapping<span class="token punctuation">.</span><span class="token function">getProductByProductId</span><span class="token punctuation">(</span>projectEntity<span class="token punctuation">.</span><span class="token function">getProProductId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ProductOutsourceEntity productOutsourceEntity <span class="token operator">=</span> productOutsourceMapping<span class="token punctuation">.</span><span class="token function">getProductOutsourceByOutId</span><span class="token punctuation">(</span>productEntity<span class="token punctuation">.</span><span class="token function">getOutId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取文件名</span>        String strUrl <span class="token operator">=</span> productOutsourceEntity<span class="token punctuation">.</span><span class="token function">getFileUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String filename <span class="token operator">=</span> strUrl<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>strUrl<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        filename <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>filename<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"iso8859-1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String path <span class="token operator">=</span> strUrl<span class="token punctuation">;</span>        File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果文件不存在</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>file<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"下载文件不存在"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//解决下载文件时文件名乱码问题</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fileNameBytes <span class="token operator">=</span> filename<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>StandardCharsets<span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">;</span>        filename <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>fileNameBytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> fileNameBytes<span class="token punctuation">.</span>length<span class="token punctuation">,</span> StandardCharsets<span class="token punctuation">.</span>ISO_8859_1<span class="token punctuation">)</span><span class="token punctuation">;</span>        resp<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        resp<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"application/octet-stream"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        resp<span class="token punctuation">.</span><span class="token function">setCharacterEncoding</span><span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        resp<span class="token punctuation">.</span><span class="token function">setContentLength</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> file<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置响应头，控制浏览器下载该文件</span>        resp<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"content-disposition"</span><span class="token punctuation">,</span> <span class="token string">"attachment;filename="</span> <span class="token operator">+</span> filename<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//读取要下载的文件，保存到文件输入流</span>        BufferedInputStream bis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建输出流</span>        OutputStream os  <span class="token operator">=</span> resp<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//缓存区</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//循环将输入流中的内容读取到缓冲区中</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">=</span> bis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        os<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buff<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                        os<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//关闭</span>        bis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        os<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"下载失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"下载成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO 自动生成的 catch 块</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="文件夹下载"><a href="#文件夹下载" class="headerlink" title="文件夹下载"></a>文件夹下载</h1><p> 与文件下载不一样，需要先压缩再下载。本例子的服务器中文件URL已知，所以未用mapping层查询数据库，可根据需要加上。</p><h2 id="Service"><a href="#Service" class="headerlink" title="Service:"></a>Service:</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*    * 下载文件夹    */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">downloadFile</span><span class="token punctuation">(</span>String proname<span class="token punctuation">,</span> String fileName<span class="token punctuation">,</span> HttpServletResponse resp<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//下载后的文件</span>        String name<span class="token operator">=</span>Constants<span class="token punctuation">.</span>FILEPATH <span class="token operator">+</span> Constants<span class="token punctuation">.</span>PROJECT <span class="token operator">+</span> proname <span class="token operator">+</span> <span class="token string">"/product/outsource"</span><span class="token operator">+</span><span class="token string">".zip"</span><span class="token punctuation">;</span>        zipUtil zc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">zipUtil</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> list<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//服务器存储的URL</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Constants<span class="token punctuation">.</span>FILEPATH <span class="token operator">+</span> Constants<span class="token punctuation">.</span>PROJECT <span class="token operator">+</span> proname <span class="token operator">+</span> <span class="token string">"/product/outsource"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//可继续添加要一起压缩的文件夹或文件</span>        <span class="token comment" spellcheck="true">//list.add("");</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> strings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>strings<span class="token punctuation">)</span><span class="token punctuation">;</span>        File file<span class="token operator">=</span>null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            zc<span class="token punctuation">.</span><span class="token function">compress</span><span class="token punctuation">(</span>strings<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//压缩</span>            file<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            downLoad<span class="token punctuation">.</span><span class="token function">downloadZip</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span>resp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//下载</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>file<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                file<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//把生成的压缩文件删除</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO 自动生成的 catch 块</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="Utile"><a href="#Utile" class="headerlink" title="Utile:"></a>Utile:</h2><p>建立两个工具包</p><p>（1）压缩文件夹</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ZipCompressorUtil</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> BUFFER <span class="token operator">=</span> <span class="token number">8192</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/**        * 压缩的文件夹        */</span>    <span class="token keyword">private</span> File zipFile1111<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">ZipCompressorUtil</span><span class="token punctuation">(</span>String pathName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        zipFile1111 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>pathName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**        * 遍历需要压缩文件集合        * @param pathName        * @throws IOException        */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">compress</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> pathName<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        ZipOutputStream out <span class="token operator">=</span>null<span class="token punctuation">;</span>        FileOutputStream fileOutputStream<span class="token operator">=</span>null<span class="token punctuation">;</span>        CheckedOutputStream cos<span class="token operator">=</span>null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            fileOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>zipFile1111<span class="token punctuation">)</span><span class="token punctuation">;</span>            cos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CheckedOutputStream</span><span class="token punctuation">(</span>fileOutputStream<span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">CRC32</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZipOutputStream</span><span class="token punctuation">(</span>cos<span class="token punctuation">)</span><span class="token punctuation">;</span>            String basedir <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>pathName<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">compress</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>pathName<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> out<span class="token punctuation">,</span> basedir<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>out<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>fileOutputStream<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                fileOutputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cos<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                cos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**        * 压缩        * @param file        * @param out        * @param basedir        */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">compress</span><span class="token punctuation">(</span>File file<span class="token punctuation">,</span> ZipOutputStream out<span class="token punctuation">,</span> String basedir<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 判断是目录还是文件</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">isDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compressDirectory</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> out<span class="token punctuation">,</span> basedir<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compressFile</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> out<span class="token punctuation">,</span> basedir<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**        * 压缩一个目录        * */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">compressDirectory</span><span class="token punctuation">(</span>File dir<span class="token punctuation">,</span> ZipOutputStream out<span class="token punctuation">,</span> String basedir<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dir<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        File<span class="token punctuation">[</span><span class="token punctuation">]</span> files <span class="token operator">=</span> dir<span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> files<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 递归</span>            <span class="token function">compress</span><span class="token punctuation">(</span>files<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> out<span class="token punctuation">,</span> basedir <span class="token operator">+</span> dir<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**        * 压缩一个文件        *        * */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">compressFile</span><span class="token punctuation">(</span>File file<span class="token punctuation">,</span> ZipOutputStream out<span class="token punctuation">,</span> String basedir<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>file<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        BufferedInputStream bis <span class="token operator">=</span>null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            bis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ZipEntry entry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZipEntry</span><span class="token punctuation">(</span>basedir <span class="token operator">+</span> file<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            out<span class="token punctuation">.</span><span class="token function">putNextEntry</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> count<span class="token punctuation">;</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>BUFFER<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>count <span class="token operator">=</span> bis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> BUFFER<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>bis<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                bis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>       <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>（2）下载文件夹</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DownLoadUtil</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 下载压缩包     * @param file     * @param response     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> HttpServletResponse <span class="token function">downloadZip</span><span class="token punctuation">(</span>File file<span class="token punctuation">,</span>HttpServletResponse response<span class="token punctuation">)</span> <span class="token punctuation">{</span>        InputStream fis <span class="token operator">=</span> null<span class="token punctuation">;</span>        OutputStream toClient <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 以流的形式下载文件。</span>             fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>fis<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 清空response</span>            response<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             toClient <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedOutputStream</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"application/octet-stream"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//如果输出的是中文名的文件，在此处就要用URLEncoder.encode方法进行处理</span>            response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"Content-Disposition"</span><span class="token punctuation">,</span> <span class="token string">"attachment;filename="</span> <span class="token operator">+</span> URLEncoder<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            toClient<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>            toClient<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ex<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                File f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                f<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token keyword">if</span><span class="token punctuation">(</span>fis<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                   fis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>               <span class="token keyword">if</span><span class="token punctuation">(</span>toClient<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                   toClient<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> response<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h1><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** 删除文件* @param fileName* @return*/</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">deleteFile</span><span class="token punctuation">(</span>String fileName<span class="token punctuation">)</span> <span class="token punctuation">{</span>    File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 如果文件路径只有单个文件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> file<span class="token punctuation">.</span><span class="token function">isFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"删除文件"</span> <span class="token operator">+</span> fileName <span class="token operator">+</span> <span class="token string">"成功！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"删除文件"</span> <span class="token operator">+</span> fileName <span class="token operator">+</span> <span class="token string">"失败！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>fileName <span class="token operator">+</span> <span class="token string">"不存在！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="文件夹删除"><a href="#文件夹删除" class="headerlink" title="文件夹删除"></a>文件夹删除</h1><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** 删除文件夹,里面用到了删除文件的函数，把上面文件删除的函数也引进来*/</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">deleteAllFile</span><span class="token punctuation">(</span>String dir<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果dir不以文件分隔符结尾，自动添加文件分隔符</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dir<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span>File<span class="token punctuation">.</span>separator<span class="token punctuation">)</span><span class="token punctuation">)</span>        dir <span class="token operator">=</span> dir <span class="token operator">+</span> File<span class="token punctuation">.</span>separator<span class="token punctuation">;</span>    File dirFile <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果dir对应的文件不存在，或者不是一个目录，则退出</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>dirFile<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token operator">!</span>dirFile<span class="token punctuation">.</span><span class="token function">isDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"删除文件夹失败："</span> <span class="token operator">+</span> dir <span class="token operator">+</span> <span class="token string">"不存在！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 删除文件夹中的所有文件包括子文件夹</span>    File<span class="token punctuation">[</span><span class="token punctuation">]</span> files <span class="token operator">=</span> dirFile<span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> files<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 删除子文件</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>files<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">isFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            flag <span class="token operator">=</span> <span class="token function">deleteFile</span><span class="token punctuation">(</span>files<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getAbsolutePath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 删除子文件夹</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>files<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">isDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            flag <span class="token operator">=</span> <span class="token function">deleteAllFile</span><span class="token punctuation">(</span>files<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getAbsolutePath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"删除文件夹失败！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 删除当前文件夹</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dirFile<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"删除文件夹"</span> <span class="token operator">+</span> dir <span class="token operator">+</span> <span class="token string">"成功！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="文件上传（文件夹需自行压缩）"><a href="#文件上传（文件夹需自行压缩）" class="headerlink" title="文件上传（文件夹需自行压缩）"></a>文件上传（文件夹需自行压缩）</h1><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">insertProductOutsource</span><span class="token punctuation">(</span>ProductOutsourceEntity productOutsourceEntity<span class="token punctuation">,</span>String proname<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>MultipartFile<span class="token operator">></span> file<span class="token punctuation">,</span>HttpServletRequest req<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 判断参数有没有效</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>productOutsourceEntity <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Constants<span class="token punctuation">.</span>FAILCODE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//获取当前时间</span>        Calendar calendar <span class="token operator">=</span> Calendar<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String nowTime <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd_HH-mm-ss"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>calendar<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建文件夹,文件名称与提交时间关联</span>        ProjectEntity projectEntity <span class="token operator">=</span> projectMapping<span class="token punctuation">.</span><span class="token function">getProjectByName</span><span class="token punctuation">(</span>proname<span class="token punctuation">)</span><span class="token punctuation">;</span>        String poId <span class="token operator">=</span> signMapping<span class="token punctuation">.</span><span class="token function">getSignById</span><span class="token punctuation">(</span>projectEntity<span class="token punctuation">.</span><span class="token function">getProSignId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPoId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String docPath <span class="token operator">=</span> Constants<span class="token punctuation">.</span>FILEPATH <span class="token operator">+</span> Constants<span class="token punctuation">.</span>PROJECT <span class="token operator">+</span> proname <span class="token operator">+</span> <span class="token string">"/product/"</span> <span class="token operator">+</span> poId <span class="token operator">+</span> <span class="token string">"-outsource/"</span><span class="token operator">+</span>nowTime<span class="token operator">+</span><span class="token string">"/"</span><span class="token punctuation">;</span>        File localPath <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>docPath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>localPath<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 获得文件目录，判断目录是否存在，不存在就新建一个</span>            localPath<span class="token punctuation">.</span><span class="token function">mkdirs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//存文件</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>MultipartFile f <span class="token operator">:</span> file<span class="token punctuation">)</span> <span class="token punctuation">{</span>            String filename <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">getOriginalFilename</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String path <span class="token operator">=</span> docPath <span class="token operator">+</span>filename<span class="token punctuation">;</span>            File filePath <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>             BufferedOutputStream out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 保存文件到目录下</span>            out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//在创建好的文件中写入f.getBytes()</span>            out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            productOutsourceEntity<span class="token punctuation">.</span><span class="token function">setFileUrl</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"数据库中FileUrl储存"</span><span class="token operator">+</span>productOutsourceEntity<span class="token punctuation">.</span><span class="token function">getFileUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        productOutsourceMapping<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>productOutsourceEntity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> Constants<span class="token punctuation">.</span>SUCCESSCODE<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO: handle exception</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        req<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">,</span> <span class="token string">"添加文件失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> Constants<span class="token punctuation">.</span>FAILCODE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> </code></pre>]]></content>
      
      
      <categories>
          
          <category> 文件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java（十一）IO流</title>
      <link href="/2022/06/30/javanotes/java11/"/>
      <url>/2022/06/30/javanotes/java11/</url>
      
        <content type="html"><![CDATA[<h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ol><li><p>java.io.File类：文件和文件目录路径的抽象表示形式，与平台无关</p></li><li><p>File 能新建、删除、重命名文件和目录，但 File 不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入&#x2F;输出流。</p></li><li><p>想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录。</p></li><li><p>File对象可以作为参数传递给流的构造器</p></li></ol><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>public File(String pathname)</p><p>以pathname为路径创建File对象，可以是绝对路径或者相对路径，相对路径的当前路径在系统属性user.dir中存储。</p><p>public File(String parent,String child)</p><p>以parent为父路径，child为子路径创建File对象。</p><p>public File(File parent,String child)</p><p>根据一个父File对象和子文件路径创建File对象</p><h2 id="路径分隔符"><a href="#路径分隔符" class="headerlink" title="路径分隔符"></a>路径分隔符</h2><p>路径分隔符和系统有关：</p><p>windows和DOS系统默认使用“\”来表示</p><p>UNIX和URL使用“&#x2F;”来表示</p><p>File类提供了一个常量解决分隔符统一：</p><p>public static final String separator。根据操作系统，动态的提供分隔符</p><p>File file2 &#x3D; new File(“d:” + File.separator + “atguigu” + File.separator + “info.txt”);</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>File类的获取功能</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">getAbsolutePath</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：获取绝对路径<span class="token keyword">public</span> String <span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span> ：获取路径<span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> ：获取名称<span class="token keyword">public</span> String <span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：获取上层文件目录路径。若无，返回null<span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> ：获取文件长度（即：字节数）。不能获取目录的长度。<span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">lastModified</span><span class="token punctuation">(</span><span class="token punctuation">)</span> ：获取最后一次的修改时间，毫秒值<span class="token keyword">public</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span> ：获取指定目录下的所有文件或者文件目录的名称数组<span class="token keyword">public</span> File<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span> ：获取指定目录下的所有文件或者文件目录的File数组</code></pre><p>File类的重命名功能</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">renameTo</span><span class="token punctuation">(</span>File dest<span class="token punctuation">)</span><span class="token operator">:</span>把文件重命名为指定的文件路径</code></pre><p>File类的判断功能</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：判断是否是文件目录<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> ：判断是否是文件<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span> ：判断是否存在<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">canRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> ：判断是否可读<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">canWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span> ：判断是否可写<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isHidden</span><span class="token punctuation">(</span><span class="token punctuation">)</span> ：判断是否隐藏</code></pre><p>File类的创建功能</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">createNewFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> ：创建文件。若文件存在，则不创建，返回<span class="token boolean">false</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">mkdir</span><span class="token punctuation">(</span><span class="token punctuation">)</span> ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">mkdirs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> ：创建文件目录。如果上层文件目录不存在，一并创建注意事项：如果你创建文件或者文件目录没有写盘符路径，那么，默认在项目路径下。</code></pre><p>File类的删除功能</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：删除文件或者文件夹删除注意事项：Java中的删除不走回收站。要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录</code></pre><h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><p>Google I&#x2F;O 寓为“开放中创新” (Innovation in the Open)</p><p>Input&#x2F;Output</p><p>二进制1,0</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>按操作数据单位不同分为：字节流(8 bit)，字符流(16 bit)</p><p>按数据流的流向不同分为：输入流，输出流</p><p>按流的角色的不同分为：节点流，处理流</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/316100407aa8385a026a4f59d91df93e.png"></p><ol><li><p>Java的IO流共涉及40多个类，实际上非常规则，都是从如下4个抽象基类派生的。</p></li><li><p>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀</p></li></ol><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/61e415145864302949ba6ce4794ec4ea.png"></p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/2f5264b726a10e6fbc077407b94c86c0.png"></p><h2 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h2><p>节点流：直接从数据源或目的地读写数据</p><p>处理流：不直接连接到数据源或目的地，而是“连接”在已存在的流（节点流或处理流）之上，通过对数据的处理为程序提供更为强大的读写功能。</p><h2 id="InputStream-amp-Reader"><a href="#InputStream-amp-Reader" class="headerlink" title="InputStream &amp; Reader"></a>InputStream &amp; Reader</h2><pre class=" language-java"><code class="language-java">InputStream 和Reader 是所有输入流的基类。InputStream（典型实现：FileInputStream）<span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">)</span><span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> off<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span>Reader（典型实现：FileReader）<span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> c<span class="token punctuation">)</span><span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> off<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span></code></pre><p>程序中打开的文件IO 资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该显式关闭文件IO 资源。</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/719a8f161c1c2b4bcd8133b69a5e7796.png"></p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/8e4d1e66ddbf877ab0b458375da79cb3.png"></p><h2 id="OutputStream-amp-Writer"><a href="#OutputStream-amp-Writer" class="headerlink" title="OutputStream &amp; Writer"></a>OutputStream &amp; Writer</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">int</span> b<span class="token operator">/</span><span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token operator">/</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cbuf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token operator">/</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buff<span class="token punctuation">,</span> <span class="token keyword">int</span> off<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 需要先刷新，再关闭此流</code></pre><p>因为字符流以字符作为操作单位，所以Writer可以用字符串来替换字符数组</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span>String str<span class="token punctuation">,</span> <span class="token keyword">int</span> off<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/03fc7bb05747235d79921841bbe2128f.png"></p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/0531f464a3899191306c4ab57f81878e.png"></p><h2 id="read的理解"><a href="#read的理解" class="headerlink" title="read的理解"></a>read的理解</h2><p>Java 下 IO 中 FileReader 和 FileInputStream 分别是以字符和字节的形式来完成数据的读取的，然而返回值确是 int 类型的数据，这样做的核心目的只是要取到到一个 int 类型下的 -1 来表示数据流的末尾。为什么要这样做？又是怎么实现的呢？</p><p>首先看FileReader ：</p><pre class=" language-java"><code class="language-java">FileReader fr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"src.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> ch <span class="token operator">=</span> fr<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如上面的代码，FileReader 的 read 方法返回值是一个 int 类型的变量来接收的，然而 read 方法在实际中却是以字符形式来进行数据的读取的。通过上面的基本数据类型的取值范围我们能发现 char 类型数据的取值范围为 0 ~ 65535 ，也就是说 char 类型数据是取不到负值的；int 类型数据的取值范围为 -2147483648 ~ 2147483647 ，可以取到负值；同时 int 的取值范围又包含 char 的取值范围，这就为使用 int 作为返回值类型提供了可能，因为流需要一个特殊的值来表示流末尾，这个值不应该在 char 的取值范围内，如果使用 char 取值范围内的值作为流末尾标志，那么这个值同样有可能出现在数据流中间作为数据来传输，流在读到这个值的时候会认为已经到达流末尾，后面未读取的数据将被截断。所以 Java 中选择了使用 -1 来作为流末尾，这个值不在 char 的取值范围内，所以不存在数据截断，然而 -1 又在 int 的取值范围内，同时 int 的取值范围包含 char 的取值范围，所以 FileReader 下 read 方法返回的 char 类型数据直接转为了 int 类型。</p><p>再看FileInputStream ：</p><pre class=" language-java"><code class="language-java">FileInputStream fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"src.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>同理FileInputStream 也需要一个自己取不到的值来作为流末尾的标志，Java 同样使用 -1 来作为字节流的流末尾，从上面基本数据类型的取值范围我们可以看到 byte 的取值范围为 -128 ~ 127 ，这就意味走着 byte 可以取到 -1 ，如果把 -1 直接当作 int 作为流末尾，那么就无法区分这个读到的结果是流末尾还是流中的数据了，那么 Java 是如何实现取值 -1 的呢？在 Java 内部，Java 通过高位补 0 来实现数据从 byte 到 int 的转换，举个例子：</p><p>-1 在 byte 类型和 int 类型中都可以取到，-1 在 byte 类型下的二进制存储形式为 11111111 ，然而使用 read 方法的时候，Java 内部将 byte 的高位补 0 将 byte 转为 int 类型，所以 byte 类型的 -1 在 int 类型下的二进制存储形式为 00000000 00000000 00000000 11111111，对应的 int 值为 255，通过高位补 0 ，所有 byte 类型的负数都转为了正数。然而在使用这些读到的 byte 数据时，只要将这些数据从 int 强转回 byte 即可得到原有的数据。所以就可以使用 -1 来作为流末尾的标志，因为 Java 内部将 byte 的负数通过高位补 0 将其转换为了正数。</p><h1 id="节点流（或文件流）"><a href="#节点流（或文件流）" class="headerlink" title="节点流（或文件流）"></a>节点流（或文件流）</h1><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/f9a4ba3ee91cb2833b7879f6526015d3.png"></p><ol><li><p>可以省略new File，因为FileReader会自动封装</p></li><li><p>1024是因为通常设置10位二进制</p></li></ol><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/84b733d03c03021483b8c035c0d6cc38.png"></p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/e6472489740e0c25ad77871a705a8225.png"></p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/cbbf74cb9f48eb905c713f613535fd2d.png"></p><ol><li><p>定义文件路径时，注意：可以用“&#x2F;”或者“\”。</p></li><li><p>写入一个文件时，如果使用构造器FileOutputStream(file)，则目录下有同名文件将被覆盖。</p></li><li><p>如果使用FileOutputStream(file,true)，则同名文件不会被覆盖，在文件内容末尾追加内容。</p></li><li><p>在读取文件时，必须保证该文件已存在，否则报异常。</p></li><li><p>字节流操作字节，比如：.mp3，.avi，.rmvb，mp4，.jpg，.doc，.ppt</p></li></ol><p>字符流操作字符，只能操作普通文本文件。最常见的文本文件：.txt，.java，.c，.cpp 等语言的源代码。尤其注意.doc,excel,ppt这些不是文本文件。</p><ol start="6"><li>可以用stream复制文本，但是不能中途查看会乱码,其他操作不可以.</li></ol><h1 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h1><ol><li><p>为了提高数据读写的速度，Java API提供了带缓冲功能的流类，在使用这些流类时，会创建一个内部缓冲区数组，缺省使用8192个字节(8Kb)的缓冲区。</p></li><li><p>缓冲流要“套接”在相应的节点流之上，根据数据操作单位可以把缓冲流分为：</p></li></ol><p>BufferedInputStream 和 BufferedOutputStream</p><p>BufferedReader 和 BufferedWriter</p><ol start="3"><li><p>当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区</p></li><li><p>当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从文件中读取8192个(8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中读取下一个8192个字节数组。</p></li><li><p>向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满， BufferedOutputStream才会把缓冲区中的数据一次性写到文件里。使用方法flush()可以强制将缓冲区的内容全部写入输出流</p></li><li><p>关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外层流也会相应关闭内层节点流</p></li><li><p>flush()方法的使用：手动将buffer中内容写入文件</p></li><li><p>如果是带缓冲区的流对象的close()方法，不但会关闭流，还会在关闭流之前刷新缓冲区，关闭后不能再写出</p></li></ol><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/4238ec72917d56c104c74a202b5f22b1.png"></p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/042e7caf26a4fb6a0eccc7ac39c75844.png"></p><h1 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h1><p>转换流提供了在字节流和字符流之间的转换</p><p>Java API提供了两个转换流：</p><pre class=" language-java"><code class="language-java">InputStreamReader：将InputStream转换为ReaderOutputStreamWriter：将Writer转换为OutputStream</code></pre><p>字节流中的数据都是字符时，转成字符流操作更高效。</p><p>很多时候我们使用转换流来处理文件乱码问题。实现编码和解码的功能</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/94c8156627bb3b71fec2f0b700e7e832.png"></p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/0494f669553662b317169df54756eaa0.png"></p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/e469d12671ba6f45a197d85636a2c482.png"></p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/195e459d424acc2c261069572a787369.png"></p><p>6.输入、输出流<br>System.in和System.out分别代表了系统标准的输入和输出设备</p><p>默认输入设备是：键盘，输出设备是：显示器</p><p>System.in的类型是InputStream</p><p>System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream 的子类</p><p>重定向：通过System类的setIn，setOut方法对默认设备进行改变。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setIn</span><span class="token punctuation">(</span>InputStream in<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setOut</span><span class="token punctuation">(</span>PrintStream out<span class="token punctuation">)</span></code></pre><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/8a394b669d5c46abbaefa40fb01d4c8c.png"></p><h1 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h1><p>实现将基本数据类型的数据格式转化为字符串输出</p><p>打印流：PrintStream和PrintWriter</p><p>提供了一系列重载的print()和println()方法，用于多种数据类型的输出</p><p>PrintStream和PrintWriter的输出不会抛出IOException异常</p><p>PrintStream和PrintWriter有自动flush功能</p><p>PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。</p><p>在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。</p><p>System.out返回的是PrintStream的实例</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/2133f12b40c1760a71cb8bae2a51367e.png"></p><h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/8dab044182d962f8079902ec1d024760.png"></p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/ba7fdba0e392a2acebe04f7b67d5866e.png"></p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/7968fa2c8beb42b69da60f5874b28cd9.png"></p><h1 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h1><p>ObjectInputStream和OjbectOutputSteam</p><p>用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</p><p>序列化：用ObjectOutputStream类保存基本类型数据或对象的机制</p><p>反序列化：用ObjectInputStream类读取基本类型数据或对象的机制</p><p>ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量</p><p>对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。&#x2F;&#x2F;当其它程序获取了这种二进制流，就可以恢复成原来的Java对象</p><p>序列化的好处在于可将任何实现了Serializable接口的对象转化为字节数据，使其在保存和传输时可被还原</p><p>序列化是RMI（Remote Method Invoke – 远程方法调用）过程的参数和返回值都必须实现的机制，而RMI 是JavaEE 的基础。因此序列化机制是JavaEE 平台的基础</p><p>如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。</p><p>否则，会抛出NotSerializableException异常</p><p>Serializable</p><p>Externalizable</p><p>凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量：</p><p>private static final long serialVersionUID;</p><p>serialVersionUID用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象</p><p>进行版本控制，有关各版本反序列化时是否兼容。</p><p>如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自</p><p>动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。故建议，</p><p>显式声明。</p><p>简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常(InvalidCastException)。防止序列化后，该类被修改了，反序列找不到类了。</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/0413e4f64caa48fcec1eef20dc4eee91.png"></p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/d4ab1948fadb22fa06e86b1ece16a7e7.png"></p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/e0724a866a037cdadc3fc756e79ad904.png"></p><h1 id="path"><a href="#path" class="headerlink" title="path"></a>path</h1><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/266fc5a7fce86ec387842c66c93b56d2.png"></p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/8b289e3029e4514abd9f1ecf5806d5fc.png"></p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/7dae905e2edb94c7192a68ff9c8b3f4d.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP收发测试</title>
      <link href="/2022/06/20/javacodetcp/"/>
      <url>/2022/06/20/javacodetcp/</url>
      
        <content type="html"><![CDATA[<h1 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h1><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>OutputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>InetSocketAddress<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>ServerSocket<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>Socket<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Tcp</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*  * TCP接收  */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"12345678"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> port <span class="token operator">=</span> <span class="token number">8081</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//创建服务器端的Socket对象(ServerSocket)</span>            ServerSocket serverSocket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//serverSocket.bind(new InetSocketAddress(port));</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//监听客户端连接，返回一个Socket对象</span>            Socket socket <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//设置阻塞的超时时间</span>            <span class="token comment" spellcheck="true">//socket.setSoTimeout(5000);</span>            <span class="token comment" spellcheck="true">//输出流</span>            OutputStream output <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//获取输入流，读数据，并把数据显示在控制台</span>            InputStream input <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//打印连接IP</span>            String IP <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span><span class="token function">getInetAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getHostAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>IP <span class="token operator">+</span> <span class="token string">"......connected"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>socket<span class="token punctuation">.</span><span class="token function">isConnected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> len <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                                <span class="token comment" spellcheck="true">// 把一个字节数组str从0取到len，取出来之后转换成String类型</span>                String str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"数据为"</span> <span class="token operator">+</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>                output<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//output.write("okok".getBytes());//可删</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>            socket<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//serverSocket.close();</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h1><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>BufferedReader<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InputStreamReader<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>OutputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>InetAddress<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>Socket<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>UnknownHostException<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* * 客户端向服务器发送数据 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TcpSend</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//接受控制台数据的输入流</span>        BufferedReader buff<span class="token operator">=</span>null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//定义保存服务器地址的对象【String】</span>        InetAddress serverip<span class="token operator">=</span>null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//定义连接服务器的端口号</span>        <span class="token keyword">int</span> serverport<span class="token operator">=</span><span class="token number">38700</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//定义创建客户端对象的Socket</span>        Socket client<span class="token operator">=</span>null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//定义发送信息的输出流对象</span>        OutputStream out<span class="token operator">=</span>null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//定义保存被发送的数据</span>        String info<span class="token operator">=</span>null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//返回包含有本机IP地址的InetAddress对象,花生壳透传公网IP</span>        serverip<span class="token operator">=</span>InetAddress<span class="token punctuation">.</span><span class="token function">getByName</span><span class="token punctuation">(</span><span class="token string">"454585x8l0.qicp.vip"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接收方： "</span> <span class="token operator">+</span> serverip<span class="token punctuation">.</span><span class="token function">getHostName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接收IP： "</span> <span class="token operator">+</span> serverip<span class="token punctuation">.</span><span class="token function">getHostAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//Socket(InetAddress address,int prot)---创建流套接字并将其连接到指定IP地址的指定端口号</span>        client<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span>serverip<span class="token punctuation">,</span>serverport<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// getOutputStream()---返回客户端的输出流。【与服务器的输入流连接】</span>        out<span class="token operator">=</span>client<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请输入发送的数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                buff<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            info<span class="token operator">=</span>buff<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>info<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        buff<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        client<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
            <tag> Java </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java（十）集合</title>
      <link href="/2022/06/17/javanotes/java10/"/>
      <url>/2022/06/17/javanotes/java10/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="对比数组"><a href="#对比数组" class="headerlink" title="对比数组"></a>对比数组</h2><p>数组在内存存储方面的特点：（所以安全）</p><p>数组初始化以后，长度就确定了。</p><p>数组声明的类型，就决定了进行元素初始化时的类型</p><p>数组在存储数据方面的弊端：</p><p>数组初始化以后，长度就不可变了，不便于扩展</p><p>数组中提供的属性和方法少，不便于进行添加、删除、插入等操作，且效率不高。</p><p>同时无法直接获取存储元素的个数</p><p>数组存储的数据是有序的、可以重复的。—-&gt;存储数据的特点单一</p><p>Java 集合类可以用于存储数量不等的多个对象，还可用于保存具有映射关系的关联数组。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Java 集合可分为Collection 和Map 两种体系</p><p>Collection接口：单列数据，定义了存取一组对象的方法的集合</p><p>List：元素有序、可重复的集合</p><p>Set：元素无序、不可重复的集合</p><p>Map接口：双列数据，保存具有映射关系“key-value对”的集合</p><h2 id="接口树"><a href="#接口树" class="headerlink" title="接口树"></a>接口树</h2><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/2e713678f49c8a71e600f077479a89a8.png"></p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/4712c3de22afc152fc7e8c2e9a561d72.png"></p><h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><ol><li><p>Collection 接口是List、Set 和Queue 接口的父接口</p></li><li><p>JDK不提供此接口的任何直接实现，而是提供更具体的子接口(如：Set和List) 实现。</p></li><li><p>在Java5 之前，Java 集合会丢失容器中所有对象的数据类型，把所有对象都当成Object 类型处理；</p></li><li><p>从JDK 5.0 增加了泛型以后，Java 集合可以记住容</p></li></ol><p>器中对象的数据类型。</p><p>方法：</p><ol><li>添加</li></ol><pre class=" language-java"><code class="language-java"><span class="token function">add</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span><span class="token function">addAll</span><span class="token punctuation">(</span>Collection coll<span class="token punctuation">)</span></code></pre><ol start="2"><li>获取有效元素的个数</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ol start="3"><li>清空集合</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ol start="4"><li>是否是空集合</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ol start="5"><li>是否包含某个元素</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span>：是通过元素的equals方法来判断是否是同一个对象<span class="token keyword">boolean</span> <span class="token function">containsAll</span><span class="token punctuation">(</span>Collection c<span class="token punctuation">)</span>：调用元素的equals方法来。拿两个集合的元素挨个比较。</code></pre><ol start="6"><li>删除</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> ：通过元素的equals方法判断是否是要删除的那个元素。```只会删除找到的第一个元素```java<span class="token keyword">boolean</span> <span class="token function">removeAll</span><span class="token punctuation">(</span>Collection coll<span class="token punctuation">)</span>：取当前集合的差集</code></pre><ol start="7"><li>取两个集合的交集</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">boolean</span> <span class="token function">retainAll</span><span class="token punctuation">(</span>Collection c<span class="token punctuation">)</span>：把交集的结果存在当前集合中，不影响c</code></pre><ol start="8"><li>集合是否相等</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span></code></pre><ol start="9"><li>转成对象数组</li></ol><pre class=" language-java"><code class="language-java">Object<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ol start="10"><li>获取集合对象的哈希值</li></ol><pre class=" language-java"><code class="language-java"><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ol start="11"><li>遍历</li></ol><pre class=" language-java"><code class="language-java"><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：返回迭代器对象，用于集合遍历</code></pre><h1 id="Iterator迭代器接口"><a href="#Iterator迭代器接口" class="headerlink" title="Iterator迭代器接口"></a>Iterator迭代器接口</h1><h2 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h2><ol><li><p>Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。</p></li><li><p>Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。</p></li><li><p>Iterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建Iterator 对象，则必须有一个被迭代的集合。</p></li><li><p>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</p></li></ol><h2 id="遍历集合元素"><a href="#遍历集合元素" class="headerlink" title="遍历集合元素"></a>遍历集合元素</h2><p>在调用xxxxx.next()方法之前必须要调用xxxxx.hasNext()进行检测。若不调用，且下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常。</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/4554275f0be41b0450e8443bf4d38e06.png"></p><h2 id="remove（）方法"><a href="#remove（）方法" class="headerlink" title="remove（）方法"></a>remove（）方法</h2><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/5e741203516eddf39fec15aa463fd782.png"></p><p>注意：</p><p>Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法。</p><p>如果还未调用next()或在上一次调用next 方法之后已经调用了remove 方法，再调用remove都会报IllegalStateException。</p><h2 id="foreach-循环遍历集合元素"><a href="#foreach-循环遍历集合元素" class="headerlink" title="foreach 循环遍历集合元素"></a>foreach 循环遍历集合元素</h2><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/f9fc8dc15e764095faa80f506535e376.png"></p><h1 id="Collection-——-List"><a href="#Collection-——-List" class="headerlink" title="Collection —— List"></a>Collection —— List</h1><p>鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组</p><p>List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。</p><p>List容器中的元素可以根据序号存取容器中的元素。</p><p>JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。</p><h2 id="List接口方法"><a href="#List接口方法" class="headerlink" title="List接口方法"></a>List接口方法</h2><p>除了从Collection集合继承的方法外，List 集合里添加了根据索引来操作集合元素的方法。</p><ol><li><p>void add(int index, Object ele):在index位置插入ele元素</p></li><li><p>boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</p></li><li><p>Object get(int index):获取指定index位置的元素</p></li><li><p>int indexOf(Object obj):返回obj在集合中首次出现的位置</p></li><li><p>int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置</p></li><li><p>Object remove(int index):移除指定index位置的元素，并返回此元素</p></li><li><p>Object set(int index, Object ele):设置指定index位置的元素为ele</p></li><li><p>List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</p></li></ol><h2 id="实现类1：ArrayList"><a href="#实现类1：ArrayList" class="headerlink" title="实现类1：ArrayList"></a>实现类1：ArrayList</h2><p>ArrayList 是 List 接口的典型实现类、主要实现类</p><p>本质上，ArrayList是对象引用的一个”变长”数组</p><p>ArrayList的JDK1.8之前与之后的实现区别？</p><pre><code>JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组JDK1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元素时 再创建一个始容量为10的数组</code></pre><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/7762116f85ef7ce648979ee372fa0f13.png"></p><p>删除的是对应的下角标</p><p>改为：list.remove(new Integer(2)) 装箱删除的是对象</p><p>Java List 的 remove 方法有两个重载，一个接收 int 型参数（通过下标删除），一个接收 Object 型参数（通过元素删除）。对于List<Integer>,如果传入一个整型字面值，会删除对应下标处的元素</p><h2 id="实现类2：LinkedList"><a href="#实现类2：LinkedList" class="headerlink" title="实现类2：LinkedList"></a>实现类2：LinkedList</h2><p>对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高</p><p>新增方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">addFirst</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">addLast</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span>Object <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span>Object <span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span>Object <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span>Object <span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span>LinkedList：双向链表，内部没有声明数组，而是定义了Node类型的first和last，用于记录首末元素。同时，定义内部类Node，作为LinkedList中保存数据的基本结构。Node除了保存数据，还定义了两个变量：prev变量记录前一个元素的位置next变量记录下一个元素的位置</code></pre><h2 id="实现类3：Vector"><a href="#实现类3：Vector" class="headerlink" title="实现类3：Vector"></a>实现类3：Vector</h2><p>Vector 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的。</p><p>在各种list中，最好把ArrayList作为缺省选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用。</p><h2 id="list总结"><a href="#list总结" class="headerlink" title="list总结"></a>list总结</h2><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/a42b07bc8ee2bbb50c7dd6a35eceb0ec.png"></p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/a8dde2f5127aaca2b22845ecb80e99c7.png"></p><h1 id="Collection-——-Set"><a href="#Collection-——-Set" class="headerlink" title="Collection —— Set"></a>Collection —— Set</h1><p>Set接口是Collection的子接口，set接口没有提供额外的方法</p><p>Set 集合不允许包含相同的元素，如果两个相同的元素加入同个Set 集合，则添加操作失败</p><p>Set 判断两个对象是否相同不是使用&#x3D;&#x3D; 运算符，而是根据equals() 方法</p><h2 id="实现类1-HashSet"><a href="#实现类1-HashSet" class="headerlink" title="实现类1:HashSet"></a>实现类1:HashSet</h2><p>HashSet 是Set 接口的典型实现，大多数时候使用Set 集合时都使用这个实现类。</p><p>HashSet 按Hash 算法来存储集合中的元素，因此具有很好的存取、查找、删除性能。</p><p>HashSet 具有以下特点：</p><pre><code>不能保证元素的排列顺序HashSet 不是线程安全的集合元素可以是null</code></pre><p>HashSet 集合判断两个元素相等的标准：两个对象通过hashCode() 方法比较相等，并且两个对象的equals() 方法返回值也相等。</p><p>对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object obj)方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”。</p><p>向HashSet中添加元素的过程：</p><p>当向HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来得到该对象的 hashCode 值，然后根据 hashCode 值，通过某种散列函数决定该对象在 HashSet 底层数组中的存储位置。（这个散列函数会与底层数组的长度相计算得到在数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布，该散列函数设计的越好）<br>如果两个元素的hashCode()值相等，会再继续调用equals方法，如果equals方法结果为true，添加失败；如果为false，那么会保存该元素，但是该数组的位置已经有元素了，那么会通过链表的方式继续链接。如果两个元素的equals() 方法返回true，但它们的hashCode() 返回值不相等，hashSet 将会把它们存储在不同的位置，但依然可以添加成功。</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/3d19f627840a91ac908676673fb90db2.png"></p><p>重写hashCode() 方法的基本原则</p><ol><li><p>在程序运行时，同一个对象多次调用hashCode() 方法应该返回相同的值。</p></li><li><p>当两个对象的equals() 方法比较返回true 时，这两个对象的hashCode()方法的返回值也应相等。</p></li><li><p>对象中用作equals() 方法比较的Field，都应该用来计算hashCode 值。</p></li></ol><p>重写equals() 方法的基本原则</p><p>以自定义的Customer类为例，何时需要重写equals()？</p><ol><li><p>当一个类有自己特有的“逻辑相等”概念,当改写equals()的时候，总是要改写hashCode()，根据一个类的equals方法（改写后），两个截然不同的实例有可能在逻辑上是相等的，但是，根据Object.hashCode()方法，它们仅仅是两个对象。</p></li><li><p>因此，违反了“相等的对象必须具有相等的散列码”。</p></li><li><p>结论：复写equals方法的时候一般都需要同时复写hashCode方法。通常参与计算hashCode的对象的属性也应该参与到equals()中进行计算。</p></li></ol><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/bd75ff2ea5fcc2a43141ed29951dfeca.png"></p><h2 id="实现类2：LinkedHashSet"><a href="#实现类2：LinkedHashSet" class="headerlink" title="实现类2：LinkedHashSet"></a>实现类2：LinkedHashSet</h2><p>LinkedHashSet 是HashSet 的子类</p><p>LinkedHashSet 根据元素的hashCode 值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的。</p><p>LinkedHashSet插入性能略低于HashSet，但在迭代访问Set 里的全部元素时有很好的性能。</p><p>LinkedHashSet 不允许集合元素重复。</p><h2 id="实现类3：TreeSet"><a href="#实现类3：TreeSet" class="headerlink" title="实现类3：TreeSet"></a>实现类3：TreeSet</h2><p>TreeSet 是SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态。</p><p>TreeSet底层使用红黑树结构存储数据</p><p>新增的方法如下：(了解)</p><pre class=" language-java"><code class="language-java">Comparator <span class="token function">comparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>Object <span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span>Object <span class="token function">last</span><span class="token punctuation">(</span><span class="token punctuation">)</span>Object <span class="token function">lower</span><span class="token punctuation">(</span>Object e<span class="token punctuation">)</span>Object <span class="token function">higher</span><span class="token punctuation">(</span>Object e<span class="token punctuation">)</span>SortedSet <span class="token function">subSet</span><span class="token punctuation">(</span>fromElement<span class="token punctuation">,</span> toElement<span class="token punctuation">)</span>SortedSet <span class="token function">headSet</span><span class="token punctuation">(</span>toElement<span class="token punctuation">)</span>SortedSet <span class="token function">tailSet</span><span class="token punctuation">(</span>fromElement<span class="token punctuation">)</span>TreeSet 两种排序方法：自然排序和定制排序。默认情况下，TreeSet 采用自然排序。TreeSet和后面要讲的TreeMap采用红黑树的存储结构特点：有序，查询速度比List快</code></pre><p>hashmap</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/e84c17b59d3705b829141ad52ae0bef0.png"></p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/c9236a8abc95c14dfb77244995403df9.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java（九）枚举类 | 注解</title>
      <link href="/2022/06/09/javanotes/java9/"/>
      <url>/2022/06/09/javanotes/java9/</url>
      
        <content type="html"><![CDATA[<h1 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/34059251250e2378bb5ab19c7d2de263.png"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>枚举类的实现</p><p>JDK1.5之前需要自定义枚举类</p><p>JDK 1.5 新增的enum 关键字用于定义枚举类</p><p>若枚举只有一个对象, 则可以作为一种单例模式的实现方式。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>枚举类对象的属性不应允许被改动, 所以应该使用private final 修饰</p><p>枚举类的使用private final 修饰的属性应该在构造器中为其赋值</p><p>若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数</p><h2 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h2><ol><li><p>私有化类的构造器，保证不能在类的外部创建其对象</p></li><li><p>在类的内部创建枚举类的实例。声明为：public static final</p></li><li><p>对象如果有实例变量，应该声明为private final，并在构造器中初始化</p></li></ol><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/3ccf7553934222fa3346383952fad029.png"></p><h2 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h2><p>使用enum 定义的枚举类默认继承了java.lang.Enum类，因此不能再继承其他类</p><p>枚举类的构造器只能使用private 权限修饰符</p><p>枚举类的所有实例必须在枚举类中显式列出(, 分隔; 结尾)。列出的实例系统会自动添加public static final 修饰</p><p>必须在枚举类的第一行声明枚举类对象</p><p>JDK 1.5 中可以在switch 表达式中使用Enum定义的枚举类的对象作为表达式, case 子句可以直接使用枚举值的名字, 无需添加枚举类作为限定。</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/2de2ddaf456e7f43f8a21073b3f9a065.png"></p><h2 id="Enum类的主要方法"><a href="#Enum类的主要方法" class="headerlink" title="Enum类的主要方法"></a>Enum类的主要方法</h2><p>values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</p><p>valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。</p><p>toString()：返回当前枚举类对象常量的名称</p><h1 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解(Annotation)"></a>注解(Annotation)</h1><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>框架&#x3D; 注解+ 反射+ 设计模式。</p><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>使用Annotation 时要在其前面增加@ 符号, 并把该Annotation 当成一个修饰符使用。用于修饰它支持的程序元素</p><p>示例一：生成文档相关的注解</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@author</span> 标明开发该类模块的作者，多个作者之间使用<span class="token punctuation">,</span>分割<span class="token annotation punctuation">@version</span> 标明该类模块的版本<span class="token annotation punctuation">@see</span> 参考转向，也就是相关主题<span class="token annotation punctuation">@since</span> 从哪个版本开始增加的<span class="token annotation punctuation">@param</span> 对方法中某参数的说明，如果没有参数就不能写@<span class="token keyword">return</span> 对方法返回值的说明，如果方法的返回值类型是<span class="token keyword">void</span>就不能写<span class="token annotation punctuation">@exception</span> 对方法可能抛出的异常进行说明，如果没有用<span class="token keyword">throws</span>显式抛出的异常就不能写其中<span class="token annotation punctuation">@param</span> @<span class="token keyword">return</span> 和<span class="token annotation punctuation">@exception</span> 这三个标记都是只用于方法的。<span class="token annotation punctuation">@param</span>的格式要求：<span class="token annotation punctuation">@param</span> 形参名形参类型形参说明@<span class="token keyword">return</span> 的格式要求：@<span class="token keyword">return</span> 返回值类型返回值说明<span class="token annotation punctuation">@exception</span>的格式要求：<span class="token annotation punctuation">@exception</span> 异常类型异常说明<span class="token annotation punctuation">@param</span>和<span class="token annotation punctuation">@exception</span>可以并列多个</code></pre><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/df0df4eaa159df410ae8f7a738e5d945.png"></p><p>示例二：在编译时进行格式检查(JDK内置的三个基本注解)</p><pre class=" language-jaca"><code class="language-jaca">@Override: 限定重写父类方法, 该注解只能用于方法@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择@SuppressWarnings: 抑制编译器警告</code></pre><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/ec2780a0a554659af1142a760506674d.png"></p><p>示例三：跟踪代码依赖性，实现替代配置文件功能</p><p>Servlet3.0提供了注解,使得不再需要在web.xml文件中进行Servlet的部署。</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/e50a36402caf94bb90b82d16505f157c.png"></p><p>spring框架中关于“事务”的管理</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/d78c3c5ae03ac27f3f36169232949396.png"></p><h2 id="自定义-1"><a href="#自定义-1" class="headerlink" title="自定义"></a>自定义</h2><p>A.定义新的Annotation 类型使用@interface 关键字</p><p>B.自定义注解自动继承了java.lang.annotation.Annotation接口</p><p>C.Annotation 的成员变量在Annotation 定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型。我们称为配置参数。类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组。</p><p>D.可以在定义Annotation 的成员变量时为其指定初始值, 指定成员变量的初始值可使用default 关键字</p><p>E.如果只有一个参数成员，建议使用参数名为value</p><p>F.如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认值。格式是“参数名 &#x3D; 参数值”，如果只有一个参数成员，且名称为value，可以省略“value&#x3D;”</p><p>G.没有成员定义的Annotation 称为标记; 包含成员变量的Annotation 称为元数据Annotation</p><p>注意：自定义注解必须配上注解的信息处理流程才有意义。</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/fd74a963746898e2fc85bd86573cd7ef.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库相关操作</title>
      <link href="/2022/06/03/javacodemysql/"/>
      <url>/2022/06/03/javacodemysql/</url>
      
        <content type="html"><![CDATA[<h1 id="删除一条记录（此记录与其他表关联）"><a href="#删除一条记录（此记录与其他表关联）" class="headerlink" title="删除一条记录（此记录与其他表关联）"></a>删除一条记录（此记录与其他表关联）</h1><p>表A其中一个字段为表B的某个字段，当表B的该条记录删除时，应当提前在表B设置一条初始记录，当某条记录删除，应将初始记录的对应字段set到表A对应字段，防止表B删除后，表A查不到信息。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** 删除岗位，设置的初始记录为postId = 16，postName = “待管理员审核身份”*/</span><span class="token keyword">public</span> String <span class="token function">delatePost</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Constants<span class="token punctuation">.</span>FAILCODE<span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>UserEntity<span class="token operator">></span> allUser <span class="token operator">=</span> backSysMapping<span class="token punctuation">.</span><span class="token function">getAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>UserEntity userEntity <span class="token operator">:</span> allUser<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>userEntity<span class="token punctuation">.</span><span class="token function">getPostName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>                userEntity<span class="token punctuation">.</span><span class="token function">setPostId</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                userEntity<span class="token punctuation">.</span><span class="token function">setPostName</span><span class="token punctuation">(</span>postMapping<span class="token punctuation">.</span><span class="token function">getNameById</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        postMapping<span class="token punctuation">.</span><span class="token function">deletePostByName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> Constants<span class="token punctuation">.</span>SUCCESSCODE<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"BackSysService/delatePost, 删除岗位失败, "</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> Constants<span class="token punctuation">.</span>FAILCODE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
            <tag> Java </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java（八）多线程</title>
      <link href="/2022/05/28/javanotes/java8/"/>
      <url>/2022/05/28/javanotes/java8/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="程序-program"><a href="#程序-program" class="headerlink" title="程序(program)"></a>程序(program)</h2><p>是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。</p><h2 id="进程-process"><a href="#进程-process" class="headerlink" title="进程(process)"></a>进程(process)</h2><p>是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期</p><ol><li><p>如：运行中的QQ，运行中的MP3播放器</p></li><li><p>程序是静态的，进程是动态的</p></li><li><p>进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域</p></li></ol><h2 id="线程-thread"><a href="#线程-thread" class="headerlink" title="线程(thread)"></a>线程(thread)</h2><p>进程可进一步细化为线程，是一个程序内部的一条执行路径。</p><ol><li><p>若一个进程同一时间并行执行多个线程，就是支持多线程的</p></li><li><p>线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小。</p></li><li><p>一个进程中的多个线程共享相同的内存单元&#x2F;内存地址空间——它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。</p></li></ol><h2 id="单核CPU和多核CPU"><a href="#单核CPU和多核CPU" class="headerlink" title="单核CPU和多核CPU"></a>单核CPU和多核CPU</h2><ol><li><p>单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果有某个人不想交钱，那么收费人员可以把他“挂起”（晾着他，等他想通了，准备好了钱，再去收费）。但是因为CPU时间单元特别短，因此感觉不出来。</p></li><li><p>如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的）</p></li><li><p>一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。</p></li></ol><h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><p>并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。</p><p>并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。</p><h2 id="使用多线程的优点"><a href="#使用多线程的优点" class="headerlink" title="使用多线程的优点"></a>使用多线程的优点</h2><p>背景：以单核CPU为例，只使用单个线程先后完成多个任务（调用多个方法），肯定比用多个线程来完成用的时间更短，为何仍需多线程呢？</p><p>多线程程序的优点：</p><ol><li><p>提高应用程序的响应。对图形化界面更有意义，可增强用户体验。</p></li><li><p>提高计算机系统CPU的利用率</p></li><li><p>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改</p></li></ol><h2 id="何时需要多线程"><a href="#何时需要多线程" class="headerlink" title="何时需要多线程"></a>何时需要多线程</h2><ol><li><p>程序需要同时执行两个或多个任务。</p></li><li><p>程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。</p></li><li><p>需要一些后台运行的程序时。</p></li></ol><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>Java语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来体现。</p><h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><p>特性：</p><ol><li><p>每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体</p></li><li><p>通过该Thread对象的start()方法来启动这个线程，而非直接调用run()</p></li></ol><pre class=" language-java"><code class="language-java">构造器：<span class="token function">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：创建新的Thread对象<span class="token function">Thread</span><span class="token punctuation">(</span>String threadname<span class="token punctuation">)</span>：创建线程并指定线程实例名<span class="token function">Thread</span><span class="token punctuation">(</span>Runnable target<span class="token punctuation">)</span>：指定创建线程的目标对象，它实现了Runnable接口中的run方法<span class="token function">Thread</span><span class="token punctuation">(</span>Runnable target<span class="token punctuation">,</span> String name<span class="token punctuation">)</span>：创建新的Thread对象</code></pre><h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><p>JDK1.5之前创建新执行线程有两种方法：</p><p>继承Thread类的方式</p><p>实现Runnable接口的方式</p><p>方式一：继承Thread类</p><ol><li><p>定义子类继承Thread类。</p></li><li><p>子类中重写Thread类中的run方法。</p></li><li><p>创建Thread子类对象，即创建了线程对象。</p></li><li><p>调用线程对象start方法：启动线程，调用run方法。</p></li></ol><p>注意点：</p><ol><li><p>如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式。</p></li><li><p>run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统CPU调度决定。</p></li><li><p>想要启动多线程，必须调用start方法。</p></li><li><p>一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以上的异常 “IllegalThreadStateException”。</p></li></ol><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/47e4d123b9ee6068ddc5492f7443cb9b.png"></p><p>方式二：实现Runnable接口</p><ol><li><p>定义子类，实现Runnable接口。</p></li><li><p>子类中重写Runnable接口中的run方法。</p></li><li><p>通过Thread类含参构造器创建线程对象。</p></li><li><p>将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。</p></li><li><p>调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。</p></li></ol><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/ed21a78a26850abcd5709d4ec0131953.png"></p><p>区别：</p><p>继承Thread：线程代码存放Thread子类run方法中。</p><p>实现Runnable：线程代码存在接口的子类的run方法。</p><p>实现方式的好处：</p><ol><li><p>避免了单继承的局限性</p></li><li><p>多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源。</p></li></ol><h2 id="Thread类的有关方法"><a href="#Thread类的有关方法" class="headerlink" title="Thread类的有关方法"></a>Thread类的有关方法</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> 启动线程，并执行对象的<span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法<span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> 线程在被调度时执行的操作String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> 返回线程的名称<span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token operator">:</span>设置该线程名称<span class="token keyword">static</span> Thread <span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> 返回当前线程。在Thread子类中就是<span class="token keyword">this</span>，通常用于主线程和 Runnable实现类<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：线程让步暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程若队列中没有同优先级的线程，忽略此方法<span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> ：当某个程序执行流中调用其他线程的<span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 方法时，调用线程将被阻塞，直到<span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 方法加入的join 线程执行完为止低优先级的线程也可以获得执行<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">long</span> millis<span class="token punctuation">)</span>：<span class="token punctuation">(</span>指定时间<span class="token operator">:</span>毫秒<span class="token punctuation">)</span>令当前线程在指定时间段放弃对CPU控制<span class="token punctuation">,</span>使其他线程有机会被执行<span class="token punctuation">,</span>时间到后重排队。抛出InterruptedException异常<span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> 强制线程生命期结束，不推荐使用<span class="token keyword">boolean</span> <span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：返回<span class="token keyword">boolean</span>，判断线程是否还活着</code></pre><p>（5）线程的调度<br>调度策略：</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/2ab141e9e55cf4e9a58c0f8658994186.png"></p><p>Java的调度方法：</p><p>同优先级线程组成先进先出队列（先到先服务），使用时间片策略</p><p>对高优先级，使用优先调度的抢占式策略</p><h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>线程的优先级等级</p><p>MAX_PRIORITY：10</p><p>MIN _PRIORITY：1</p><p>NORM_PRIORITY：5</p><p>涉及的方法</p><p>getPriority() ：返回线程优先值</p><p>setPriority(int newPriority) ：改变线程的优先级</p><p>说明</p><p>线程创建时继承父线程的优先级</p><p>低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用</p><h2 id="补充：线程的分类"><a href="#补充：线程的分类" class="headerlink" title="补充：线程的分类"></a>补充：线程的分类</h2><p>Java中的线程分为两类：一种是守护线程，一种是用户线程。</p><ol><li><p>它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开。</p></li><li><p>守护线程是用来服务用户线程的，通过在start()方法前调用thread.setDaemon(true)可以把一个用户线程变成一个守护线程。</p></li><li><p>Java垃圾回收就是一个典型的守护线程。</p></li><li><p>若JVM中都是守护线程，当前JVM将退出。</p></li><li><p>形象理解：兔死狗烹，鸟尽弓藏</p></li></ol><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>五个状态</p><p>A.新建：</p><p>当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态</p><p>B.就绪：</p><p>处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了 运行的条件，只是没分配到CPU资源</p><p>C.运行：</p><p>当就绪的线程被调度并获得CPU资源时,便进入运行状态，run()方法定义了线程的操 作和功能</p><p>D.阻塞：</p><p>在某种特殊情况下，被人为挂起或执行输入输出操作时，让出CPU 并临时中止自己的 执行，进入阻塞状态</p><p>E.死亡：</p><p>线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/5eccdb02a448b7b568a383da378c6566.png"></p><h1 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h1><h2 id="Synchronized同步代码块"><a href="#Synchronized同步代码块" class="headerlink" title="Synchronized同步代码块"></a>Synchronized同步代码块</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>同步监视器<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 需要被同步的代码；</span><span class="token punctuation">}</span></code></pre><p>同步监视器可自定义，但需要保证每个线程调用时，该对象是同一个。</p><p>A.使用实现Runnable接口的方法：</p><p>只会创建一个对象，所以监视器可以用this，即刚创建的该类的对象。</p><p>B.使用继承Thread类的方法：</p><p>由于创建多线程会创建出多个对象，就拥有了多个监视器，所以此时用把监视器设置为：该类.calss，因为一个类只有一个，且类也是对象。</p><h2 id="Synchronized同步方法"><a href="#Synchronized同步方法" class="headerlink" title="Synchronized同步方法"></a>Synchronized同步方法</h2><p>如果整个方法均需要同步，synchronized还可以放在方法声明中，表示整个方法为同步方法。</p><pre class=" language-java"><code class="language-java">例如：<span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">show</span> <span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>…<span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>A.使用实现Runnable接口的方法：</p><p>只会创建一个对象，所以可以直接用上面的形势，此时也是有监视器的，是this，即刚创建的该类的对象。</p><p>B.使用继承Thread类的方法：</p><p>由于创建多线程会创建出多个对象，就拥有了多个监视器，所以此时用把该方法设置为static，此时的监视器为：该类.calss，因为一个类只有一个</p><p>synchronized的锁是什么？</p><ol><li><p>任意对象都可以作为同步锁。所有对象都自动含有单一的锁（监视器）。</p></li><li><p>同步方法的锁：静态方法（类名.class）、非静态方法（this）</p></li><li><p>同步代码块：自己指定，很多时候也是指定为this或类名.class</p></li></ol><p>注意：</p><ol><li><p>必须确保使用同一个资源的多个线程共用一把锁，这个非常重要，否则就无法保证共享资源的安全</p></li><li><p>一个线程类中的所有静态方法共用同一把锁（类名.class），所有非静态方法共用同一把锁（this），同步代码块（指定需谨慎）</p></li></ol><h2 id="同步的范围"><a href="#同步的范围" class="headerlink" title="同步的范围"></a>同步的范围</h2><ol><li>如何找问题，即代码是否存在线程安全？（非常重要）</li></ol><p>明确哪些代码是多线程运行的代码</p><p>明确多个线程是否有共享数据</p><p>明确多线程运行代码中是否有多条语句操作共享数据</p><ol start="2"><li>如何解决呢？（非常重要）</li></ol><p>对多条操作共享数据的语句，一个线程执行过程中，其他线程不可以参与执行。</p><p>即所有操作共享数据的这些语句都要放在同步范围中</p><ol start="3"><li>切记：</li></ol><p>范围太小：没锁住所有有安全问题的代码</p><p>范围太大：没发挥多线程的功能。</p><h2 id="释放锁的操作"><a href="#释放锁的操作" class="headerlink" title="释放锁的操作"></a>释放锁的操作</h2><p>A.当前线程的同步方法、同步代码块执行结束。</p><p>B.当前线程在同步代码块、同步方法中遇到break、return终止该代码块、该方法的继续执行。</p><p>C.当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。</p><p>D.当前线程在同步代码块、同步方法中执行线程对象的wait()方法，当前线程暂停并释放锁。</p><h2 id="不会释放锁的操作"><a href="#不会释放锁的操作" class="headerlink" title="不会释放锁的操作"></a>不会释放锁的操作</h2><p>A.线程执行同步代码块或同步方法时，程序调用Thread.sleep()、</p><p>Thread.yield()方法暂停当前线程的执行</p><p>B.线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）。</p><p>应尽量避免使用suspend()和resume()来控制线程</p><h2 id="线程的死锁问题"><a href="#线程的死锁问题" class="headerlink" title="线程的死锁问题"></a>线程的死锁问题</h2><p>死锁：</p><p>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源</p><p>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续</p><p>解决方法：</p><p>专门的算法、原则</p><p>尽量减少同步资源的定义</p><p>尽量避免嵌套同步</p><h2 id="Lock-锁"><a href="#Lock-锁" class="headerlink" title="Lock(锁)"></a>Lock(锁)</h2><p>从JDK 5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。</p><p>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</p><p>ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReenTrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span><span class="token punctuation">{</span>证线程安全的代码<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">finally</span><span class="token punctuation">{</span>lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>注意：如果同步代码有异常，要将unlock()写入finally语句块</p><h2 id="synchronized-与-Lock-的对比"><a href="#synchronized-与-Lock-的对比" class="headerlink" title="synchronized 与 Lock 的对比"></a>synchronized 与 Lock 的对比</h2><ol><li><p>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁，出了作用域自动释放</p></li><li><p>Lock只有代码块锁，synchronized有代码块锁和方法锁</p></li><li><p>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）</p></li></ol><p>优先使用顺序：</p><p>Lock —— 同步代码块（已经进入了方法体，分配了相应资源）—— 同步方法</p><p>（在方法体之外）</p><h1 id="线性的通信"><a href="#线性的通信" class="headerlink" title="线性的通信"></a>线性的通信</h1><h2 id="wait-与notify-和notifyAll"><a href="#wait-与notify-和notifyAll" class="headerlink" title="wait() 与notify() 和notifyAll()"></a>wait() 与notify() 和notifyAll()</h2><p>wait()：令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用notify()或notifyAll()方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行。</p><p>notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待</p><p>notifyAll ()：唤醒正在排队等待资源的所有线程结束等待.</p><p>这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报</p><p>java.lang.IllegalMonitorStateException异常。</p><p>因为这三个方法必须有锁对象调用，而任意对象都可以作为synchronized的同步锁，因此这三个方法只能在Object类中声明。</p><h2 id="wait-方法"><a href="#wait-方法" class="headerlink" title="wait() 方法"></a>wait() 方法</h2><p>在当前线程中调用方法：对象名.wait()</p><p>使当前线程进入等待（某对象）状态，直到另一线程对该对象发出notify(notifyAll) 为止。</p><p>调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）</p><p>调用此方法后，当前线程将释放对象监控权，然后进入等待</p><p>在当前线程被notify后，要重新获得监控权，然后从断点处继续代码的执行。</p><h2 id="notify-x2F-notifyAll"><a href="#notify-x2F-notifyAll" class="headerlink" title="notify()&#x2F;notifyAll()"></a>notify()&#x2F;notifyAll()</h2><p>当前线程调用方法：对象名.notify()，对象名一般设置为同步代码块（方法）的同步监控器</p><p>功能：唤醒等待该对象监控权的一个&#x2F;所有线程。</p><p>调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）</p><p>面试题: sleep() 和wait()的异同?</p><p>A. 相同点:一旦执行方法， 都可以使得当前的线程进入阻塞状态。</p><p>B. 不同点: </p><ol><li><p>两个方法声明的位置不同: Thread类 中声明sleep()，object类中声明wait()</p></li><li><p>调用的要求不同: sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代</p></li><li><p>关于是否释放同步监视器:|如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会。</p></li></ol><h1 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>JDK5.0 新增线程创建方式</p><p>与使用Runnable相比， Callable功能更强大些</p><ol><li><p>相比run()方法，可以有返回值</p></li><li><p>方法可以抛出异常</p></li><li><p>支持泛型的返回值</p></li><li><p>需要借助FutureTask类，比如获取返回结果</p></li></ol><p>Future接口</p><p>可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。</p><p>FutrueTask是Futrue接口的唯一的实现类</p><p>FutureTask 同时实现了Runnable, Future接口。它既可以作为</p><p>Runnable被线程执行，又可以作为Future得到Callable的返回值</p><h2 id="创建流程"><a href="#创建流程" class="headerlink" title="创建流程"></a>创建流程</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//1.创建一个实现Callable的实现类</span><span class="token keyword">class</span> <span class="token class-name">NumThread</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//2.实现call方法，将此线程需要执行的操作声明在call（）中</span><span class="token annotation punctuation">@Override</span>Public Object call（）<span class="token keyword">throws</span> Exception<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span>在调用类中：<span class="token comment" spellcheck="true">//3.创建Callable接口实现类的对象</span>NumThread numThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NumThread</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//4.将Callable接口实现类的对象作为参数传到FutureTask构造器，创建FutureTask的对象</span>FutureTask futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token punctuation">(</span> numThread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//5.将FutureTask的对象作为参数侍送到Thread美的构造器中创建Thread.象， 并调用start(）</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span> <span class="token punctuation">.</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Try<span class="token punctuation">{</span><span class="token comment" spellcheck="true">//6.获取Callable中dplL方法的返回值</span><span class="token comment" spellcheck="true">//get()返回值即为Future Task构造器参数Callable实现类重写的call()的返回値。</span>object sum <span class="token operator">=</span> futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span> out <span class="token punctuation">.</span> <span class="token function">println</span><span class="token punctuation">(</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>e<span class="token punctuation">.</span> <span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>e<span class="token punctuation">.</span> <span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。</p><p>思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</p><p>好处：</p><p>A.提高响应速度（减少了创建新线程的时间）</p><p>B.降低资源消耗（重复利用线程池中线程，不需要每次都创建）</p><p>C.便于线程管理</p><p>corePoolSize：核心池的大小</p><p>maximumPoolSize：最大线程数</p><p>keepAliveTime：线程没有任务时最多保持多长时间后会终止</p><p>…</p><h2 id="线程池相关API"><a href="#线程池相关API" class="headerlink" title="线程池相关API"></a>线程池相关API</h2><p>JDK 5.0起提供了线程池相关API：ExecutorService 和 Executors</p><p>ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor</p><p>void execute(Runnable command) ：执行任务&#x2F;命令，没有返回值，一般用来执行Runnable</p><p><T> Future<T> submit(Callable<T> task)：执行任务，有返回值，一般又来执行Callable</p><p>void shutdown() ：关闭连接池</p><p>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池</p><p>Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池</p><p>Executors.newFixedThreadPool(n); 创建一个可重用固定线程数的线程池</p><p>Executors.newSingleThreadExecutor() ：创建一个只有一个线程的线程池</p><p>Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/8b98e5e44e4309a1d487db7683a0f4d7.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java（七）异常处理</title>
      <link href="/2022/05/22/javanotes/java7/"/>
      <url>/2022/05/22/javanotes/java7/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>因为很多问题不是靠代码能够避免的，(开发过程中的语法错误和逻辑错误不是异常) ，比如：</p><ol><li><p>客户输入数据的格式</p></li><li><p>读取文件是否存在</p></li><li><p>网络是否始终保持通畅等等</p></li></ol><h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><p>Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError和OOM。一般不编写针对性的代码进行处理。</p><p>Exception: 其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如：</p><ol><li><p>空指针访问</p></li><li><p>试图读取不存在的文件</p></li><li><p>网络连接中断</p></li><li><p>数组角标越界</p></li></ol><p>捕获错误最理想的是在编译期间，但有的错误只有在运行时才会发生。比如：除数为0，数组下标越界等</p><p>分类：编译时异常和运行时异常</p><h2 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h2><pre class=" language-java"><code class="language-java">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span><span class="token function">RuntimeException</span> <span class="token punctuation">(</span>运行异常<span class="token punctuation">)</span>ClassCastExceptionArrayIndexOutOfBoundsExceptionNullPointerExceptionArithmeticExceptionNumberFormatExceptionInputMismatchException<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOExeptionFileNotFoundExceptionEOFExceptionjava<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ClassNotFoundExceptionjava<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>InterruptedExceptionjava<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileNotFoundExceptionjava<span class="token punctuation">.</span>sql<span class="token punctuation">.</span>SQLException</code></pre><h2 id="Java异常处理的方式"><a href="#Java异常处理的方式" class="headerlink" title="Java异常处理的方式"></a>Java异常处理的方式</h2><p>方式一：try-catch-finally</p><p>方式二：throws + 异常类型</p><ol><li><p>Java提供的是异常处理的抓抛模型。</p></li><li><p>Java程序的执行过程中如出现异常，会生成一个异常类对象，该异常对象将被提交给Java运行时系统，这个过程称为抛出(throw)异常。</p></li><li><p>异常对象的生成</p></li></ol><p>A.由虚拟机自动生成：程序运行过程中，虚拟机检测到程序发生了问题，如果在当前代码中没有找到相应的处理程序，就会在后台自动创建一个对应异常类的实例对象并抛出——自动抛出</p><p>B.由开发人员手动创建：Exception exception &#x3D; new ClassCastException();——创建好的异常对象不抛出对程序没有任何影响，和创建一个普通对象一样</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/4dcda331c21388c8c8ec4c23abbeaa4d.png"></p><ol><li><p>如果一个方法内抛出异常，该异常对象会被抛给调用者方法中处理。如果异常没有在调用者方法中处理，它继续被抛给这个调用方法的上层方法。这个过程将一直继续下去，直到异常被处理。这一过程称为捕获(catch)异常。</p></li><li><p>如果一个异常回到main()方法，并且main()也不处理，则程序运行终止。</p></li><li><p>程序员通常只能处理Exception，而对Error无能为力。</p></li></ol><h1 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h1><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/f5c7e8bd544afb7d29aed2a4cbb5932d.png"></p><p>捕获异常的有关信息：</p><p>与其它对象一样，可以访问一个异常对象的成员变量或调用它的方法。</p><p>getMessage() 获取异常信息，返回字符串</p><p>printStackTrace() 获取异常类名和信息，以及异常出现在程序中的位置。返回值void。</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/c0e86e67aafe0fbd71a403bc64677034.png"></p><p>finally:捕获异常的最后一步是通过finally语句为异常处理提供一个统一的出口，使得在控制流转到程序的其它部分以前，能够对程序的状态作统一的管理。</p><h1 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h1><p>声明抛出异常是Java中处理异常的第二种方式</p><p>如果一个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。</p><p>在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/3c47db2f7e0a5a593a2cd98a4c309682.png"></p><p>重写方法不能抛出比被重写方法范围更大的异常类型。</p><p>在多态的情况下，对methodA()方法的调用-异常的捕获按父类声明的异常处理。</p><h1 id="手动抛出异常"><a href="#手动抛出异常" class="headerlink" title="手动抛出异常"></a>手动抛出异常</h1><p>首先要生成异常类对象，然后通过throw语句实现抛出操作(提交给Java运行环境)。</p><p>IOException e &#x3D; new IOException();</p><p>throw e;</p><p>可以抛出的异常必须是Throwable或其子类的实例。下面语句在编译时将会产生语法错误：</p><p>throw new String(“want to throw”);</p><h1 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h1><ol><li><p>一般地，用户自定义异常类都是RuntimeException的子类。</p></li><li><p>通常需要编写几个重载的构造器。</p></li><li><p>需要提供serialVersionUID</p></li><li><p>通过throw抛出。</p></li><li><p>最重要的是异常类的名字，当异常出现时，可以根据名字判断异常类型。</p></li><li><p>用户自己的异常类必须继承现有的异常类。</p></li></ol><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/e65c851dbbef2850c3047383a8e4554c.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java（六）面向对象（下）</title>
      <link href="/2022/05/15/javanotes/java6/"/>
      <url>/2022/05/15/javanotes/java6/</url>
      
        <content type="html"><![CDATA[<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="类属性、类方法"><a href="#类属性、类方法" class="headerlink" title="类属性、类方法"></a>类属性、类方法</h2><p>类属性作为该类各个对象之间共享的变量。在设计类时,分析哪些属性不因对象的不同而改变，将这些属性设置为类属性。相应的方法设置为类方法。<br>类变量（类属性）由该类的所有实例共享.<br>如果方法与调用者无关，则这样的方法通常被声明为类方法，由于不需要创建对象就可以调用类方法，从而简化了方法的调用。</p><h2 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h2><p>在Java类中，可用static修饰：属性、方法、代码块、内部类 </p><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><p>A.随着类的加载而加载 </p><p>B.优先于对象存在 </p><p>C.修饰的成员，被所有对象所共享 </p><p>D.访问权限允许时，可不创建对象，直接被类调用(如Person.id、Person.add(int num) )</p><p>E.调用时，在一处修改了static的变量或方法，所有调用该static的均同步变化。</p><p>F.在static方法内部只能访问类的static修饰的属性或方法，不能访问类的非static结构。</p><p>G.因为不需要实例就可访问static方法，因此static方法内部不能有this,也不能有super 。</p><p>H.static修饰的方法不能被重写。</p><h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。“套路” </p><h2 id="单例设计模式-1"><a href="#单例设计模式-1" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的构造器的访问权限设置为private，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的。</p><h2 id="单例-饿汉式"><a href="#单例-饿汉式" class="headerlink" title="单例-饿汉式"></a>单例-饿汉式</h2><p>一加载类就new好了，等待调用。</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/000000000000.png"></p><h2 id="单例-懒汉式"><a href="#单例-懒汉式" class="headerlink" title="单例-懒汉式"></a>单例-懒汉式</h2><p>用的时候再new</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/111.png"></p><h2 id="单例模式的优点"><a href="#单例模式的优点" class="headerlink" title="单例模式的优点"></a>单例模式的优点</h2><p>由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。</p><h2 id="单例设计模式应用"><a href="#单例设计模式应用" class="headerlink" title="单例设计模式应用"></a>单例设计模式应用</h2><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/131.png"></p><h1 id="main"><a href="#main" class="headerlink" title="main"></a>main</h1><p>因为main() 方法是静态的，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员。</p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>对Java类或对象进行初始化</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>一个类中代码块若有修饰符，则只能被static修饰，称为静态代码块(static block)，没有使用static修饰的，为非静态代码块。</p><p>static代码块通常用于初始化static的属性</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>A.静态代码块：用static 修饰的代码块</p><ol><li><p>可以有输出语句。</p></li><li><p>可以对类的属性、类的声明进行初始化操作。</p></li><li><p>不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。</p></li><li><p>若有多个静态的代码块，那么按照从上到下的顺序依次执行。</p></li><li><p>静态代码块的执行要先于非静态代码块。</p></li><li><p>静态代码块随着类的加载而加载，且只执行一次。</p></li></ol><p>B.非静态代码块：没有static修饰的代码块</p><ol><li><p>可以有输出语句。</p></li><li><p>可以对类的属性、类的声明进行初始化操作。</p></li><li><p>除了调用非静态的结构外，还可以调用静态的变量或方法。</p></li><li><p>若有多个非静态的代码块，那么按照从上到下的顺序依次执行。</p></li><li><p>每次创建对象的时候，都会执行一次。且先于构造器执行。</p></li></ol><h2 id="分析运行顺序"><a href="#分析运行顺序" class="headerlink" title="分析运行顺序"></a>分析运行顺序</h2><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/sssss.png"></p><p>先执行的是father的static代码块，然后son的static代码块，才是打印“777777777”，因为main方法的运行，需要son类的加载，又继承了father，所以从father开始打印。</p><h2 id="属性赋值的位置"><a href="#属性赋值的位置" class="headerlink" title="属性赋值的位置"></a>属性赋值的位置</h2><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/sdafafafa.png"></p><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>声明类、变量和方法时，可使用关键字final来修饰,表示“最终的”。</p><p>A.final标记的类不能被继承。提高安全性，提高程序的可读性。</p><p>如：String类、System类、StringBuffer类</p><p>B.final标记的方法不能被子类重写。</p><p>如：Object类中的getClass()。</p><p>C.final标记的变量(成员变量或局部变量)称为常量。名称大写，且只能被赋值一次,不可修改。final标记的成员变量必须在声明时或在每个构造器中或代码块中显式赋值，然后才能使用。</p><p>如：final double MY_PI &#x3D; 3.14;</p><p>static final：全局常量</p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>第一题：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Something</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">addOne</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token operator">++</span>x<span class="token punctuation">;</span> 错误，对x进行修改了<span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> 正确，对x没有变化，只是用x进行运算。<span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>第二题：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Something</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Other o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Other</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addOne</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addOne</span><span class="token punctuation">(</span><span class="token keyword">final</span> Other o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Other</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 错误，对象o重新赋值。        o<span class="token punctuation">.</span>i<span class="token operator">++</span><span class="token punctuation">;</span> 正确，对象o的属性依然可以重新改写。    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Other</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="final属性赋值位置"><a href="#final属性赋值位置" class="headerlink" title="final属性赋值位置"></a>final属性赋值位置</h2><p>加载类之前一定要赋值,否则此属性不能再赋值了。</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/faaa.png"></p><h1 id="抽象类、抽象方法"><a href="#抽象类、抽象方法" class="headerlink" title="抽象类、抽象方法"></a>抽象类、抽象方法</h1><p>有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>A.用abstract关键字来修饰一个类，这个类叫做抽象类。</p><p>B.用abstract来修饰一个方法，该方法叫做抽象方法。</p><p>抽象方法：只有方法的声明，没有方法的实现。以分号结束：</p><p>比如：public abstract void talk();</p><p>C.含有抽象方法的类必须被声明为抽象类。</p><p>D.抽象类不能被实例化。抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。</p><p>E.不能用abstract修饰变量、代码块、构造器；</p><p>F.不能用abstract修饰私有方法、静态方法、final的方法、final的类。</p><p>个人理解：相当于规定了子类应该有哪些方法，各个子类根据实际情况执行自己的代码。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>超类声明一个方法但不提供实现，该方法的实现由子类提供。这样的方法称为抽象方法。有一个或更多抽象方法的类称为抽象类。</p><h2 id="模板方法设计模式（多态的应用）"><a href="#模板方法设计模式（多态的应用）" class="headerlink" title="模板方法设计模式（多态的应用）"></a>模板方法设计模式（多态的应用）</h2><p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</p><p>解决的问题：</p><p>当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</p><p>换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h2><p>一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。</p><p>另一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又没有is-a的关系，仅仅是具有相同的行为特征而已。例如：鼠标、键盘、打印机、扫描仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等都支持USB连接。</p><p>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是&#x2F;要…则必须能…”的思想。继承是一个”是不是”的关系，而接口实现则是 “能不能”的关系。</p><p>接口的本质是契约，标准，规范，就像我们的法律一样。制定好后大家都要遵守。</p><p>接口(interface)是抽象方法和常量值定义的集合。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>A.用interface来定义。</p><p>B.接口中的所有成员变量都默认是由public static final修饰的。</p><p>C.接口中的所有抽象方法都默认是由public abstract修饰的。</p><p>D.接口中没有构造器。</p><p>E.接口采用多继承机制。</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/sfxgx.png"></p><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p>A.定义Java类的语法格式：先写extends，后写implements</p><p>class SubClass extends SuperClass implements InterfaceA{ }</p><p>B.一个类可以实现多个接口，接口也可以继承其它接口。</p><p>C.实现接口的类必须提供接口中所有方法的具体实现内容，方可实例化。否则，仍为抽象类。</p><p>D.接口的主要用途就是被实现类实现。（面向接口编程）</p><p>E.与继承关系类似，接口与实现类之间存在多态性</p><p>F.接口和类是并列关系，或者可以理解为一种特殊的类。从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义(JDK7.0及之前)，而没有变量和方法的实现。</p><p>G.分别介绍本类、父类、接口的调用：</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/ffegsgs.png"></p><h1 id="代理模式（接口的应用）"><a href="#代理模式（接口的应用）" class="headerlink" title="代理模式（接口的应用）"></a>代理模式（接口的应用）</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><pre><code>A.安全代理：屏蔽对真实角色的直接访问。B.远程代理：通过代理类处理远程方法调用（RMI）C.延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象</code></pre><p>比如你要开发一个大文档查看软件，大文档中有大的图片，有可能一个图片有100MB，在打开文件时，不可能将所有的图片都显示出来，这样就可以使用代理模式，当需要查看图片时，用proxy来进行大图片的打开。</p><p>分类:</p><pre><code>静态代理（静态定义代理类）动态代理（动态生成代理类）JDK自带的动态代理，需要反射等知识</code></pre><h1 id="接口与抽象类对比"><a href="#接口与抽象类对比" class="headerlink" title="接口与抽象类对比"></a>接口与抽象类对比</h1><h2 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h2><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/aegsah.png"></p><p>在开发中，常看到一个类不是去继承一个已经实现好的类，而是要么继承抽象类，要么实现接口。</p><h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/agag.png"></p><p>编译错误，接口和继承一个优先级，所以不确定此时x是哪个。</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/aggafzxb.png"></p><p>编译错误：The final field Rollable.ball cannot be assigned</p><p>任何在interface里声明的interface variable (接口变量，也可称成员变量)，默认为public static final。不可修改参数</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/agagwfjy.png"></p><h2 id="java-8的改进"><a href="#java-8的改进" class="headerlink" title="java 8的改进"></a>java 8的改进</h2><p>Java 8中，你可以为接口添加静态方法和默认方法。从技术角度来说，这是完全合法的，只是它看起来违反了接口作为一个抽象定义的理念。</p><p>静态方法：使用static 关键字修饰。可以通过接口直接调用静态方法，并执行其方法体。我们经常在相互一起使用的类中使用静态方法。你可以在标准库中找到像Collection&#x2F;Collections或者Path&#x2F;Paths这样成对的接口和类。</p><p>默认方法：默认方法使用default 关键字修饰。可以通过实现类对象来调用。我们在已有的接口中提供新方法的同时，还保持了与旧版本代码的兼容性。比如：java 8 API中对Collection、List、Comparator等接口提供了丰富的默认方法。</p><h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>若一个接口中定义了一个默认方法，而另外一个接口中也定义了一个同名同参数的方法（不管此方法是否是默认方法），在实现类同时实现了这两个接口时，会出现：接口冲突。</p><p>解决办法：实现类必须覆盖接口中同名同参数的方法，来解决冲突。</p><p>若一个接口中定义了一个默认方法，而父类中也定义了一个同名同参数的非抽象方法，则不会出现冲突问题。因为此时遵守：类优先原则。接口中具有相同名称和参数的默认方法会被忽略。</p><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h2><p>成员内部类作为类的成员的角色：</p><p>A.和外部类不同，Inner class还可以声明为private或protected；</p><p>B.可以调用外部类的结构;</p><p>C.可以声明为static的，但此时就不能再使用外层类的非static的成员变量；</p><p>成员内部类作为类的角色：</p><p>A.可以在内部定义属性、方法、构造器等结构</p><p>B.可以声明为abstract类，因此可以被其它的内部类继承</p><p>C.可以声明为final的</p><p>D.编译以后生成OuterClass$InnerClass.class字节码文件（也适用于局部内部类）</p><p>【注意】</p><ol><li><p>非static的成员内部类中的成员不能声明为static的，只有在外部类或static的成员内部类中才可声明static成员。</p></li><li><p>外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式</p></li><li><p>成员内部类可以直接使用外部类的所有成员，包括私有的数据</p></li><li><p>当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的</p></li></ol><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/hkuilllhl.png"></p><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><p>A.内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号，以及数字编号。</p><p>B.只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类。</p><p>C.局部内部类可以使用外部类的成员，包括私有的。</p><p>D.局部内部类可以使用外部方法的局部变量，但是必须是final的。由局部内部类和局部变量的声明周期不同所致。</p><p>E.局部内部类和局部变量地位类似，不能使用public,protected,缺省,private</p><p>F.局部内部类不能使用static修饰，因此也不能包含静态成员</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java（五）面向对象中</title>
      <link href="/2022/04/29/javanotes/java5/"/>
      <url>/2022/04/29/javanotes/java5/</url>
      
        <content type="html"><![CDATA[<h1 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h1><h2 id="为什么要有继承"><a href="#为什么要有继承" class="headerlink" title="为什么要有继承"></a>为什么要有继承</h2><p>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。</p><p>此处的多个类称为子类(派生类)，单独的这个类称为父类(基类或超类)。</p><h2 id="类继承语法规则"><a href="#类继承语法规则" class="headerlink" title="类继承语法规则"></a>类继承语法规则</h2><p><code>class Subclass extends SuperClass&#123; &#125;</code></p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li><p>减少了代码冗余，提高了代码的复用性。</p></li><li><p>更有利于功能的扩展。</p></li><li><p>让类与类之间产生了关系，提供了多态的前提。</p></li></ol><p>注意：不要仅为了获取其他类中某个功能而去继承</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p>子类继承了父类，就继承了父类的方法和属性。</p></li><li><p>在子类中，可以使用父类中定义的方法和属性，也可以创建新的数据和方法。</p></li><li><p>在Java 中，继承的关键字用的是“extends”，即子类不是父类的子集，而是对父类的“扩展”。</p></li><li><p>关于继承的规则：</p></li></ol><p>子类不能直接访问父类中私有的(private)的成员变量和方法。但此时，依然继承了这个私有的变量、方法。</p><ol start="5"><li>Java只支持单继承和多层继承，不允许多重继承</li></ol><p>一个子类只能有一个父类</p><p>一个父类可以派生出多个子类</p><p><code>class SubDemo extends Demo&#123; &#125; //ok</code></p><p><code>class SubDemo extends Demo1,Demo2...//error</code></p><ol start="6"><li>如果没有显示生命一个父类，则继承java.lang.object类。</li></ol><p>且所有类直接或间接继承java.lang.object类</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>第一次打印定义base类，运行的是base2类，所以相当于在base2类要找base类重写的方法。</p><p>第二次打印定义base2类，运行的也是base2类，所以直接在base2里找方法，优先匹配形式一致的方法。</p><h1 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h1><h2 id="定义：-override-x2F-overwrite"><a href="#定义：-override-x2F-overwrite" class="headerlink" title="定义：(override&#x2F;overwrite)"></a>定义：(override&#x2F;overwrite)</h2><p>在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。</p><h2 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h2><ol><li><p>子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表</p></li><li><p>子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型</p></li><li><p>子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限</p></li></ol><p>子类不能重写父类中声明为private权限的方法</p><p>子类方法抛出的异常不能大于父类被重写方法的异常</p><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为 static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法。</p><h1 id="super"><a href="#super" class="headerlink" title="super"></a>super</h1><h2 id="在Java类中使用super来调用父类中的指定操作："><a href="#在Java类中使用super来调用父类中的指定操作：" class="headerlink" title="在Java类中使用super来调用父类中的指定操作："></a>在Java类中使用super来调用父类中的指定操作：</h2><ol><li><p>super可用于访问父类中定义的属性</p></li><li><p>super可用于调用父类中定义的成员方法</p></li><li><p>super可用于在子类构造器中调用父类的构造器</p></li></ol><h2 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h2><ol><li><p>尤其当子父类出现同名成员时，可以用super表明调用的是父类中的成员</p></li><li><p>super的追溯不仅限于直接父类</p></li><li><p>super和this的用法相像，this代表本类对象的引用，super代表父类内存空间的标识</p></li></ol><h2 id="调用父类的构造器："><a href="#调用父类的构造器：" class="headerlink" title="调用父类的构造器："></a>调用父类的构造器：</h2><ol><li><p>子类中所有的构造器默认都会访问父类中空参数的构造器</p></li><li><p>当父类中没有空参数的构造器时，子类的构造器必须通过this(参数列表)或者super(参数列表)语句指定调用本类或者父类中相应的构造器。同时，只能”二选一”，且必须放在构造器的首行</p></li><li><p>如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译出错</p></li></ol><h2 id="this和super的区别"><a href="#this和super的区别" class="headerlink" title="this和super的区别"></a>this和super的区别</h2><h1 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol><li><p>多态性，是面向对象中最重要的概念，在Java中的体现：</p></li><li><p>对象的多态性：父类的引用指向子类的对象。可以直接应用在抽象类和接口上</p></li><li><p>Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。简称：编译时，看左边；运行时，看右边。</p></li></ol><p>若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism)</p><p>多态情况下，“看左边”：看的是父类的引用（父类中不具备子类特有的方法）</p><p>“看右边”：看的是子类的对象（实际运行的是子类重写父类的方法）</p><h2 id="对象的多态"><a href="#对象的多态" class="headerlink" title="对象的多态"></a>对象的多态</h2><ol><li>在Java中,子类的对象可以替代父类的对象使用</li></ol><p>一个变量只能有一种确定的数据类型</p><p>一个引用类型变量可能指向(引用)多种不同类型的对象</p><p>Person p &#x3D; new Student();</p><p>Object o &#x3D; new Person();&#x2F;&#x2F;Object类型的变量o，指向Person类型的对象</p><p>o &#x3D; new Student(); &#x2F;&#x2F;Object类型的变量o，指向Student类型的对象</p><ol start="2"><li><p>子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向上转型(upcasting)。</p></li><li><p>一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法</p></li></ol><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h2 id="方法的重载与重写"><a href="#方法的重载与重写" class="headerlink" title="方法的重载与重写"></a>方法的重载与重写</h2><p>从编译和运行的角度看：</p><p>重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。</p><p>所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；</p><p>而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。</p><h2 id="多态小结"><a href="#多态小结" class="headerlink" title="多态小结"></a>多态小结</h2><p>多态作用：</p><p>提高了代码的通用性，常称作接口重用</p><p>前提：</p><p>需要存在继承或者实现关系</p><p>有方法的重写</p><p>成员方法：</p><p>编译时：要查看引用变量所声明的类中是否有所调用的方法。</p><p>运行时：调用实际new的对象所属的类中的重写方法。</p><p>成员变量：</p><p>不具备多态性，只看引用变量所声明的类。</p><h2 id="子类继承父类"><a href="#子类继承父类" class="headerlink" title="子类继承父类"></a>子类继承父类</h2><p>若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。</p><p>对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量</p><p>即：多态性，把父类和子类的属性和方法都加载在堆中，运行的是父类的属性（子类的属性加载进来但不能调用）和子类重写的方法（此方法父类中必须包含）。</p><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>x instanceof A：检验变量x是否为类A的对象，返回值为boolean型。</p><p>要求x所属的类与类A必须是子类和父类的关系，否则编译错误。</p><p>如果x属于类A的子类B，x instanceof A值也为true。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">extends</span> <span class="token class-name">Object</span> <span class="token punctuation">{</span>…<span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>…<span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Graduate</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>…<span class="token punctuation">}</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span>Person e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 处理Person类及其子类对象</span><span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">Student</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//处理Student类及其子类对象</span><span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">Graduate</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//处理Graduate类及其子类对象</span><span class="token punctuation">}</span></code></pre><h2 id="对象类型转换-Casting"><a href="#对象类型转换-Casting" class="headerlink" title="对象类型转换(Casting )"></a>对象类型转换(Casting )</h2><p>1.基本数据类型的Casting：</p><p>自动类型转换：小的数据类型可以自动转换成大的数据类型</p><p>如long g&#x3D;20; double d&#x3D;12.0f</p><p>强制类型转换：可以把大的数据类型强制转换(casting)成小的数据类型</p><p>如float f&#x3D;(float)12.0; int a&#x3D;(int)1200L</p><p>2.对Java对象的强制类型转换称为造型</p><p>从子类到父类的类型转换可以自动进行</p><p>从父类到子类的类型转换必须通过造型(强制类型转换)实现</p><p>无继承关系的引用类型间的转换是非法的</p><p>在造型前可以使用instanceof操作符测试一个对象的类型</p><h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>在方法名上面加入@Test注解，然后add导包，即可对其中一个方法进行测试。</p><p>要求：类为public、有public无参构造器、方法名public且无返回值无形参。</p><h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p>Object类是所有Java类的根父类</p><p>如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类</p><h2 id="x3D-x3D"><a href="#x3D-x3D" class="headerlink" title="&#x3D;&#x3D;"></a>&#x3D;&#x3D;</h2><p>A.基本类型比较值:只要两个变量的值相等，即为true。</p><p>int a&#x3D;5; if(a&#x3D;&#x3D;6){…}</p><p>B.引用类型比较引用(是否指向同一个对象)：只有指向同一个对象时，&#x3D;&#x3D;才返回true。</p><p>Person p1&#x3D;new Person();</p><p>Person p2&#x3D;new Person();</p><p>if (p1&#x3D;&#x3D;p2){…}</p><p>此时比较的是p1、p2是否是同一地址。用“&#x3D;&#x3D;”进行比较时，符号两边的数据类型必须兼容(可自动转换的基本数据类型除外)，否则编译出错。</p><h2 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h2><p>A.所有类都继承了Object，也就获得了equals()方法。还可以重写。</p><p>B.只能比较引用类型，其作用与“&#x3D;&#x3D;”相同,比较是否指向同一个对象。（地址值）</p><p>格式:obj1.equals(obj2)</p><p>C.特例：</p><p>当用equals()方法进行比较时，对类File、String、Date及包装类（Wrapper Class）来说，是比较类型及内容而不考虑引用的是否是同一个对象；</p><p>原因：</p><p>在这些类中重写了Object类的equals()方法。当自定义使用equals()时，可以重写。用于比较两个对象的“内容”是否都相等</p><p>D.任何情况下</p><p>x.equals(null)，永远返回是“false”；</p><p>x.equals(和x不同类型的对象)永远返回是“false”。</p><h2 id="x3D-x3D-和equals的区别"><a href="#x3D-x3D-和equals的区别" class="headerlink" title="&#x3D;&#x3D;和equals的区别"></a>&#x3D;&#x3D;和equals的区别</h2><ol><li><p>&#x3D;&#x3D; 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址</p></li><li><p>equals的话，它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也</p></li></ol><p>是&#x3D;&#x3D;;我们可以看到String等类的equals方法是被重写过的，而且String类在日常开发中用的比较多，久而久之，形成了equals是比较值的错误观点。</p><ol start="3"><li><p>具体要看自定义类里有没有重写Object的equals方法来判断。</p></li><li><p>通常情况下，重写equals方法，会比较类中的相应属性是否都相等。</p></li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> it <span class="token operator">=</span> <span class="token number">65</span><span class="token punctuation">;</span><span class="token keyword">float</span> fl <span class="token operator">=</span> <span class="token number">65.0f</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>“<span class="token number">65</span>和<span class="token number">65.0f</span>是否相等？” <span class="token operator">+</span> <span class="token punctuation">(</span>it <span class="token operator">==</span> fl<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span><span class="token keyword">char</span> ch1 <span class="token operator">=</span> <span class="token string">'A'</span><span class="token punctuation">;</span> <span class="token keyword">char</span> ch2 <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"65和'A'是否相等？"</span> <span class="token operator">+</span> <span class="token punctuation">(</span>it <span class="token operator">==</span> ch1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>“<span class="token number">12</span>和ch2是否相等？" <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">12</span> <span class="token operator">==</span> ch2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span></code></pre><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><ol><li><p>toString()方法在Object类中定义，其返回值是String类型，返回类名和它的引用地址。</p></li><li><p>在进行String与其它类型数据的连接操作时，自动调用toString()方法</p></li></ol><p>Date now&#x3D;new Date();</p><p>System.out.println(“now&#x3D;”+now); 相当于System.out.println(“now&#x3D;”+now.toString());</p><ol start="3"><li>可以根据需要在用户自定义类型中重写toString()方法</li></ol><p>如String 类重写了toString()方法，返回字符串的值。</p><p>s1&#x3D;“hello”;</p><p>System.out.println(s1);&#x2F;&#x2F;相当于System.out.println(s1.toString());</p><p>基本类型数据转换为String类型时，调用了对应包装类的toString()方法</p><p>int a&#x3D;10; System.out.println(“a&#x3D;”+a);</p><p>面试题：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//abc</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[I@1c655221</span><span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token number">1.1</span><span class="token punctuation">,</span> <span class="token number">2.2</span><span class="token punctuation">,</span> <span class="token number">3.3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[D@58d25a40</span></code></pre><h1 id="包装类的使用"><a href="#包装类的使用" class="headerlink" title="包装类的使用"></a>包装类的使用</h1><h2 id="装箱拆箱"><a href="#装箱拆箱" class="headerlink" title="装箱拆箱"></a>装箱拆箱</h2><p>JDK1.5之后，支持自动装箱，自动拆箱。但类型必须匹配。</p><p>A.基本数据类型包装成包装类的实例—装箱</p><p>通过包装类的构造器实现：</p><p><code>int i = 500; Integer t = new Integer(i);</code></p><p>还可以通过字符串参数构造包装类对象：</p><p><code>Float f = new Float(“4.56”);</code></p><p><code>Long l = new Long(“asdf”); //NumberFormatException</code></p><p>B.获得包装类对象中包装的基本类型变量—拆箱</p><p>调用包装类的.xxxValue()方法：</p><p><code>boolean b = flag.booleanValue();</code></p><h2 id="字符串、基本数据类型转换"><a href="#字符串、基本数据类型转换" class="headerlink" title="字符串、基本数据类型转换"></a>字符串、基本数据类型转换</h2><p>A.字符串转换成基本数据类型</p><p>通过包装类的构造器实现：</p><p><code>int i = new Integer(“12”);</code></p><p>通过包装类的parseXxx(String s)静态方法：</p><p><code>Float f = Float.parseFloat(“12.1”);</code></p><p>B.基本数据类型转换成字符串</p><p>调用字符串重载的valueOf()方法：</p><p><code>String fstr = String.valueOf(2.34f);</code></p><p>更直接的方式：</p><p><code>String intStr = 5 + “”</code></p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><pre class=" language-java"><code class="language-java">Object o1 <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Double</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>o1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1.0</span>执行三元判断时，都运行了，所以<span class="token keyword">int</span>型，类型提升Integer i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Integer j <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false （两个地址值不一样）</span>Integer m <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>Integer n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m <span class="token operator">==</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// true</span>（为快速加载，该类提前定义数组<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">128</span>，<span class="token number">127</span><span class="token punctuation">]</span>，所以没有经过<span class="token keyword">new</span>，两个<span class="token number">1</span>均从数组里取值）Integer x <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>Integer y <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x <span class="token operator">==</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// false （超过127，需要重新new）</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java（四）面向对象上</title>
      <link href="/2022/04/20/javanotes/java4/"/>
      <url>/2022/04/20/javanotes/java4/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="面向过程-POP-与-面向对象-OOP"><a href="#面向过程-POP-与-面向对象-OOP" class="headerlink" title="面向过程(POP) 与 面向对象(OOP)"></a>面向过程(POP) 与 面向对象(OOP)</h2><p>二者都是一种思想，面向对象是相对于面向过程而言的。</p><p>面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做。</p><p>面向对象，将功能封装进对象，强调具备了功能的对象，以类&#x2F;对象为最小单位，考虑谁来做。</p><h2 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h2><p>封装(Encapsulation)</p><p>继承(Inheritance)</p><p>多态(Polymorphism)</p><h2 id="面向对象的思想概述"><a href="#面向对象的思想概述" class="headerlink" title="面向对象的思想概述"></a>面向对象的思想概述</h2><p>类(Class)和对象(Object)是面向对象的核心概念。</p><p>类是对一类事物的描述，是抽象的、概念上的定义</p><p>对象是实际存在的该类事物的每个个体，因而也称为实例(instance)。</p><h2 id="常见的类的成员"><a href="#常见的类的成员" class="headerlink" title="常见的类的成员"></a>常见的类的成员</h2><p>属性：对应类中的成员变量</p><p>行为：对应类中的成员方法</p><p>Field &#x3D; 属性&#x3D; 成员变量，Method &#x3D; (成员)方法&#x3D; 函数</p><h2 id="自定义类"><a href="#自定义类" class="headerlink" title="自定义类"></a>自定义类</h2><p>步骤：</p><ol><li><p>定义类（考虑修饰符、类名）</p></li><li><p>编写类的属性（考虑修饰符、属性类型、属性名、初始化值）</p></li><li><p>编写类的方法（考虑修饰符、返回值类型、方法名、形参等）</p></li></ol><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>语法：类名 对象名&#x3D; new 类名();</p><p>使用 “对象名.对象成员” 的方式访问对象成员（包括属性和方法）</p><h2 id="类的访问机制："><a href="#类的访问机制：" class="headerlink" title="类的访问机制："></a>类的访问机制：</h2><p>在一个类中的访问机制：类中的方法可以直接访问类中的成员变量。（例外：static方法访问非static，编译不通过。）</p><p>在不同类中的访问机制：先创建要访问类的对象，再用对象访问类中定义的成员。</p><h2 id="内存解析"><a href="#内存解析" class="headerlink" title="内存解析"></a>内存解析</h2><p>堆（Heap），此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。</p><p>栈（Stack），是指虚拟机栈。虚拟机栈用于存储局部变量等。局部变量表存放了编译期可知长度的各种基本数据类型（boolean、byte、char 、short 、int 、float 、long 、double）、对象引用（reference类型，它不等同于对象本身，是对象在堆内存的首地址）。方法执行完，自动释放。</p><p>方法区（Method Area），用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><p>我们也可以不定义对象的句柄，而直接调用这个对象的方法。这样的对象叫做匿名对象。</p><p>如：new Person().shout();</p><p>使用情况：如果对一个对象只需要进行一次方法调用，那么就可以使用匿名对象。我们经常将匿名对象作为实参传递给一个方法调用。</p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="语法格式："><a href="#语法格式：" class="headerlink" title="语法格式："></a>语法格式：</h2><p>修饰符 数据类型 属性名&#x3D; 初始化值;</p><p>说明1: 修饰符</p><p>常用的权限修饰符有：private、缺省、protected、public</p><p>其他修饰符：static、final (暂不考虑)</p><p>说明2：数据类型</p><p>任何基本数据类型(如int、Boolean) 或任何引用数据类型。</p><p>说明3：属性名</p><p>属于标识符，符合命名规则和规范即可。</p><h2 id="变量的分类"><a href="#变量的分类" class="headerlink" title="变量的分类"></a>变量的分类</h2><p>在方法体外，类体内声明的变量称为 成员变量。</p><p>在方法体内部声明的变量称为 局部变量。</p><h2 id="赋值的位置："><a href="#赋值的位置：" class="headerlink" title="赋值的位置："></a>赋值的位置：</h2><p>① 默认初始化</p><p>② 显式初始化</p><p>③ 构造器中初始化</p><p>④ 通过“对象.属性“或“对象.方法”的方式赋值</p><p>赋值的先后顺序：</p><p>① - ② - ③ - ④</p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p>如果循环体外还想用变量，可以把变量的声明放在外面，复制在循环体里面，这样循环完还可以继续用这个变量</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>方法是类或对象行为特征的抽象，用来完成某个功能操作。在某些语言中也称为函数或过程。将功能封装为方法的目的是，可以实现代码重用，简化代码</p><p>Java里的方法不能独立存在，所有的方法必须定义在类里。</p><h2 id="声明格式"><a href="#声明格式" class="headerlink" title="声明格式"></a>声明格式</h2><p>修饰符 返回值 类型 方法名（参数类型形参1, 参数类型形参2, ….）｛</p><p>方法体 程序代码</p><p>return 返回值;</p><p>｝</p><p>方法中只能调用方法或属性，不可以在方法内部定义方法。</p><h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h2><p>概念：</p><p>在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同。</p><p>特点：</p><p>与返回值类型无关，只看参数列表，且参数列表必须不同。(参数个数或参数类型)。调用时，根据方法参数列表的不同来区别。</p><h2 id="可变个数的形参"><a href="#可变个数的形参" class="headerlink" title="可变个数的形参"></a>可变个数的形参</h2><p>&#x2F;&#x2F;JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量</p><p>public static void test(int a ,String[] books);</p><p>&#x2F;&#x2F;JDK5.0：采用可变个数形参来定义方法，传入多个同一类型变量</p><p>public static void test(int a ,String…books);</p><p>说明：</p><ol><li><p>声明格式：方法名(参数的类型名 …参数名)</p></li><li><p>可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个</p></li><li><p>可变个数形参的方法与同名的方法之间，彼此构成重载</p></li><li><p>可变参数方法的使用与方法参数部分使用数组是一致的</p></li><li><p>方法的参数部分有可变形参，需要放在形参声明的最后</p></li><li><p>在一个方法的形参位置，最多只能声明一个可变个数形参</p></li></ol><h2 id="方法参数的值传递机制"><a href="#方法参数的值传递机制" class="headerlink" title="方法参数的值传递机制"></a>方法参数的值传递机制</h2><p>形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参</p><p>形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参</p><p>失败：change会新创建一个变量放在栈里，两个x各走各的。</p><p>成功：change和main共用一个对象，放在堆里，修改的是一个对象。</p><p>拓展题目：</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>一个方法体内调用它自身。</p><p>方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。</p><p>递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。</p><h2 id="封装和隐藏"><a href="#封装和隐藏" class="headerlink" title="封装和隐藏"></a>封装和隐藏</h2><p>我们程序设计追求“高内聚，低耦合”。</p><p>高内聚：类的内部数据操作细节自己完成，不允许外部干涉；</p><p>低耦合：仅对外暴露少量的方法用于使用。</p><p>隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。</p><p>通过将数据声明为私有的(private)，再提供公共的（public）方法:getXxx()和setXxx()实现对该属性的操作，以实现下述目的：</p><p>隐藏一个类中不需要对外提供的实现细节；</p><p>便于修改，增强代码的可维护性；</p><p>只能通过事先定制好的方法来访问数据，可以加入控制逻辑，限制对属性的不合理操作；</p><h1 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h1><h2 id="语法格式：-1"><a href="#语法格式：-1" class="headerlink" title="语法格式："></a>语法格式：</h2><p>修饰符类名(参数列表) {</p><p>初始化语句；</p><p>}</p><h2 id="构造器的特征："><a href="#构造器的特征：" class="headerlink" title="构造器的特征："></a>构造器的特征：</h2><ol><li><p>它具有与类相同的名称</p></li><li><p>它不声明返回值类型。（与声明为void不同）</p></li><li><p>不能被static、final、synchronized、abstract、native修饰，不能有return语句返回值</p></li></ol><h2 id="构造器的作用："><a href="#构造器的作用：" class="headerlink" title="构造器的作用："></a>构造器的作用：</h2><ol><li><p>创建对象；</p></li><li><p>给对象进行初始化</p></li></ol><p>如：Order o &#x3D; new Order(); Person p &#x3D; new Person(“Peter”,15);</p><p>如同我们规定每个“人”一出生就必须先洗澡，我们就可以在“人”的构造器中加入完成“洗澡”的程序代码，于是每个“人”一出生就会自动完成“洗澡”，程序就不必再在每个人刚出生时一个一个地告诉他们要“洗澡”了。</p><p>创建Animal类的实例：Animal a &#x3D; new Animal(); 调用构造器，将legs初始化为4。</p><p>根据参数不同，构造器可以分为如下两类：</p><ol><li><p>隐式无参构造器（系统默认提供）</p></li><li><p>显式定义一个或多个构造器（无参、有参）</p></li></ol><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ol><li><p>Java语言中，每个类都至少有一个构造器</p></li><li><p>默认构造器的修饰符与所属类的修饰符一致</p></li><li><p>一旦显式定义了构造器，则系统不再提供默认构造器</p></li><li><p>一个类可以创建多个重载的构造器</p></li><li><p>父类的构造器不可被子类继承</p></li></ol><h1 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h1><p>JavaBean是一种Java语言写成的可重用组件。</p><p>所谓javaBean，是指符合如下标准的Java类：</p><ol><li><p>类是公共的</p></li><li><p>有一个无参的公共的构造器</p></li><li><p>有属性，且有对应的get、set方法</p></li></ol><p>用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。用户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。</p><h1 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h1><ol><li><p>+表示public 类型，- 表示private 类型，#表示protected类型</p></li><li><p>方法的写法: 方法的类型(+、-) 方法名(参数名：参数类型)：返回值类型</p></li></ol><h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol><li><p>它在方法内部使用，即这个方法所属对象的引用；<br>它在构造器内部使用，表示该构造器正在初始化的对象。</p></li><li><p>this可以调用类的属性、方法和构造器</p></li><li><p>当在方法内需要用到调用该方法的对象时，就用this。</p></li></ol><p>具体的：我们可以用this来区分属性和局部变量。</p><p>比如：this.name &#x3D; name;</p><h2 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h2><ol><li><p>在任意方法或构造器内，如果使用当前类的成员变量或成员方法可以在其前面添加this，增强程序的阅读性。不过，通常我们都习惯省略this。</p></li><li><p>当形参与成员变量同名时，如果在方法内或构造器内需要使用成员变量，必须添加this来表明该变量是类的成员变量</p></li><li><p>使用this访问属性和方法时，如果在本类中未找到，会从父类中查找</p></li><li><p>this可以作为一个类中构造器相互调用的特殊格式</p></li></ol><p>(3)注意（构造器相互调用）：<br>1.可以在类的构造器中使用”this(形参列表)”的方式，调用本类中重载的其他的构造器！</p><p>2.明确：构造器中不能通过”this(形参列表)”的方式调用自身构造器</p><p>3.如果一个类中声明了n个构造器，则最多有 n - 1个构造器中使用了”this(形参列表)”</p><p>4.”this(形参列表)”必须声明在类的构造器的首行！</p><p>5.在类的一个构造器中，最多只能声明一个”this(形参列表)”</p><h1 id="package"><a href="#package" class="headerlink" title="package"></a>package</h1><p>package语句作为Java源文件的第一条语句，指明该文件中定义的类所在的包。(若缺省该语句，则指定为无名包)。它的格式为：</p><p>package 顶层包名.子包名;</p><p>包对应于文件系统的目录，package语句中，用“.” 来指明包(目录)的层次；</p><p>包通常用小写单词标识。通常使用所在公司域名的倒置：com.atguigu.xxx</p><p>举例：pack1\pack2\PackageTest.java</p><p>package pack1.pack2; &#x2F;&#x2F;指定类PackageTest属于包pack1.pack2</p><h1 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h1><p> 192 节 课后练习4</p><p>定义类Student，包含三个属性：学号number(int)，年级state(int)，成绩score(int)。创建20个学生对象，学号为1到20，年级和成绩都由随机数确定。</p><p>问题一：打印出3年级(state值为3）的学生信息。</p><p>问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息 </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java（三）数组</title>
      <link href="/2022/04/12/javanotes/java3/"/>
      <url>/2022/04/12/javanotes/java3/</url>
      
        <content type="html"><![CDATA[<h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/77767409030bc88b31f380d640998dda.png"></p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/c6bcc7a0e0f6b15c390869c63f27c32b.png"></p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/a5c4aaf447f8b313c04a2439efd43e3d.png"></p><p>打印二维数组的外层数组，其实相当于打印一个一维数组，只会打印出这个数组存放的地址。其中“[I@15db…”的‘[’表示一维，‘I’ 表示int型。</p><p>倒数第二行为null，即使二维数组是double，但里面的元素数组还未定义类型，而数组的为初始化为null。报错是因为未初始化就取值会报错。</p><h1 id="数组的赋值与复制"><a href="#数组的赋值与复制" class="headerlink" title="数组的赋值与复制"></a>数组的赋值与复制</h1><p>（1）数组的赋值：</p><p>慎用array1 &#x3D; array2 来赋值，虽然把array2 赋值给array1，但修改array1同样修改的是array2，只是将array2的地址给了array1，他俩共用一个数组。</p><p>（2）数组的复制：</p><p>开辟一个新的堆，存放新数组</p><pre class=" language-java"><code class="language-java">array1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>array2<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> array1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    array1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> array2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="打印数组"><a href="#打印数组" class="headerlink" title="打印数组"></a>打印数组</h1><p>将数组转成String：Arrays.toString()</p><p>System.out.println(“等级” + Arrays.toString(abcd));</p><h1 id="数组算法"><a href="#数组算法" class="headerlink" title="数组算法"></a>数组算法</h1><p>（1）衡量排序算法的优劣</p><p>1.时间复杂度：分析关键字的比较次数和记录的移动次数</p><p>2.空间复杂度：分析排序算法中需要多少辅助内存</p><p>3.稳定性：若两个记录A和B的关键字值相等，但排序后A、B的先后次序保持不变，则称这种排序算法是稳定的。</p><p>（2）排序算法分类</p><p>内部排序和外部排序。</p><p>内部排序：整个排序过程不需要借助于外部存储器（如磁盘等），所有排序操作都在内存中完成。</p><p>外部排序：参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助于外部存储器（如磁盘）。外部排序最常见的是多路归并排序。可以认为外部排序是由多次内部排序组成。</p><p>（3）十大内部排序算法</p><p>a选择排序</p><p>直接选择排序、堆排序</p><p>b交换排序</p><p>冒泡排序、快速排序</p><p>c插入排序</p><p>直接插入排序、折半插入排序、Shell排序</p><p>d归并排序</p><p>e桶式排序</p><p>f基数排序</p><p>(3)冒泡排序</p><p>介绍：</p><p>冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。</p><p>排序思想：</p><ol><li><p>比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。</p></li><li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p></li><li><p>针对所有的元素重复以上的步骤，除了最后一个。</p></li><li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较为止。</p></li></ol><p>(4)快速排序</p><p>介绍：</p><p>快速排序通常明显比同为O(nlogn)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。</p><p>快速排序（Quick Sort）由图灵奖获得者Tony Hoare发明，被列为20世纪十大算法之一，是迄今为止所有内排序算法中速度最快的一种。冒泡排序的升级版，交换排序的一种。快速排序的时间复杂度为O(nlog(n))。</p><p>排序思想：</p><ol><li><p>从数列中挑出一个元素，称为”基准”（pivot），</p></li><li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</p></li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p></li><li><p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java（二）基本语法</title>
      <link href="/2022/04/06/javanotes/java2/"/>
      <url>/2022/04/06/javanotes/java2/</url>
      
        <content type="html"><![CDATA[<h1 id="关键字-keyword"><a href="#关键字-keyword" class="headerlink" title="关键字(keyword)"></a>关键字(keyword)</h1><p>定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）</p><p>特点：关键字中所有字母都为小写</p><h1 id="保留字-reserved-word"><a href="#保留字-reserved-word" class="headerlink" title="保留字(reserved word)"></a>保留字(reserved word)</h1><p>现有Java版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字：</p><p>goto 、const</p><h1 id="标识符-Identifier"><a href="#标识符-Identifier" class="headerlink" title="标识符(Identifier)"></a>标识符(Identifier)</h1><p>Java 对各种变量、方法和类等要素命名时使用的字符序列称为标识符</p><p>技巧：凡是自己可以起名字的地方都叫标识符。</p><h2 id="定义合法标识符规则："><a href="#定义合法标识符规则：" class="headerlink" title="定义合法标识符规则："></a>定义合法标识符规则：</h2><p>A.由26个英文字母大小写，0-9 ，_或$ 组成</p><p>B.数字不可以开头。</p><p>C.不可以使用关键字和保留字，但能包含关键字和保留字。</p><p>D.Java中严格区分大小写，长度无限制。</p><p>E.标识符不能包含空格。</p><h2 id="Java中的名称命名规范："><a href="#Java中的名称命名规范：" class="headerlink" title="Java中的名称命名规范："></a>Java中的名称命名规范：</h2><p>包名：多单词组成时所有字母都小写：xxxyyyzzz</p><p>类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz</p><p>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个开始首字母大写：xxxYyyZzz</p><p>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</p><p>注意1：在起名字时，为了提高阅读性，要尽量有意义，“见名知意”。</p><p>注意2：java采用unicode字符集，因此标识符也可以使用汉字声明，但是不建议使用。</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值</p><h2 id="变量的分类"><a href="#变量的分类" class="headerlink" title="变量的分类"></a>变量的分类</h2><h3 id="按数据类型"><a href="#按数据类型" class="headerlink" title="按数据类型"></a>按数据类型</h3><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/5f627a070ac3741d7c8bcd3c54955412.png"></p><h3 id="按声明的位置的不同"><a href="#按声明的位置的不同" class="headerlink" title="按声明的位置的不同"></a>按声明的位置的不同</h3><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/7ad96ec73c6094764e008806c67f1458.png"></p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h3><p>（1）整数类型：byte、short、int、long</p><p>整型常量默认为int 型，声明long型常量须后加‘l’或‘L’ ，否则默认为int。</p><p>Java程序中变量通常声明为int型，除非不足以表示较大的数，才使用long。</p><p>（2）浮点类型：float、double</p><p>double:双精度，精度是float的两倍。通常采用此类型。</p><p>浮点型常量默认为double型，声明float型常量，须后加‘f’或‘F’。否则默认为double。</p><p>如下图：因为b1已经为int，f1已经为double。</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/fa88680fb758f54fff69db8fc35d790a.png"></p><h3 id="字符型：char"><a href="#字符型：char" class="headerlink" title="字符型：char"></a>字符型：char</h3><p>用来表示通常意义上“字符”(2字节) ，Java中的所有字符都使用Unicode编码，</p><p>故一个字符可以存储一个字母，一个汉字，或其他书面语的一个字符。</p><p>字符型变量的三种表现形式：</p><p>（1）字符常量是用单引号(‘ ’)括起来的单个字符。</p><p>例如：char c1 &#x3D; ‘a’; char c2 &#x3D; ‘中’; char c3 &#x3D; ‘9’;</p><p>（2）Java中还允许使用转义字符‘\’来将其后的字符转变为特殊字符型常量。</p><p>例如：char c3 &#x3D; ‘\n’; &#x2F;&#x2F; ‘\n’表示换行符</p><p>（3）直接用Unicode值表示字符型常量：‘\uXXXX’。XXXX代表一个十六进制整数。</p><p>例如：\u000a 表示\n。</p><p>char类型是可以进行运算的。因为它都对应有Unicode码。</p><p>Char c1 &#x3D; 97; 和char c2 &#x3D; ‘97’; 是不一样的，c1输出的是Unicode码，c2输出的是符号对应的Unicode码。</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/201eac85b29cc67fed3887802ab7c07d.png"></p><h3 id="布尔型：boolean"><a href="#布尔型：boolean" class="headerlink" title="布尔型：boolean"></a>布尔型：boolean</h3><p>只允许取值true和false，无null。</p><p>不可以使用0或非0 的整数替代false和true，这点和C语言不同。</p><p>编译后使用java虚拟机中的int数据类型来代替：true用1表示，false用0表示。</p><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p>字符串类型：String , String不是基本数据类型，属于引用数据类型</p><h2 id="使用变量注意"><a href="#使用变量注意" class="headerlink" title="使用变量注意"></a>使用变量注意</h2><p>A.Java中每个变量必须先声明，后使用</p><p>B.使用变量名来访问这块区域的数据</p><p>C.变量的作用域：其定义所在的一对{ }内</p><p>D.变量只有在其作用域内才有效</p><p>E.同一个作用域内，不能定义重名的变量</p><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><p>A.语法：&lt;数据类型&gt; &lt;变量名称&gt;</p><p>例如：int var;</p><p>B.变量的赋值</p><p>语法：&lt;变量名称&gt; &#x3D; &lt;值&gt;</p><p>例如：var &#x3D; 10;</p><p>C.声明和赋值变量</p><p>语法：&lt;数据类型&gt; &lt;变量名&gt; &#x3D; &lt;初始化值&gt;</p><p>例如：int var &#x3D; 10;</p><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为：</p><p> <img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/27b11274ffd79db659683643d0b4f71b.png"></p><p>A.有多种类型的数据混合运算时，自动将所有数据转换成容量最大的类型，再进行计算。</p><p>B. byte,short,char之间不会相互转换，他们三者在计算时首先转换为int类型。</p><p>C. boolean类型不能与其它数据类型运算。</p><p>D.当把任何基本数据类型的值和字符串(String)进行连接运算时(+)，基本数据类型的值将自动转化为字符串(String)类型。</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/6e1abbe118542ffbf58749a624e8deed.png"></p><p> ‘a’为char，和后面的int 1 自动升级int值97，97 +1 &#x3D; 98 再升级为字符串</p><p> <img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/5c1c56fc02373c2d8cf48ede348966b0.png"></p><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符：()，但可能造成精度降低或溢出,格外要注意。</p><p>通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型。如：String a &#x3D; “43”; int i &#x3D; Integer.parseInt(a);</p><p>boolean类型不可以转换为其它的数据类型。</p><p>例子：byte b &#x3D; 3;</p><p>b &#x3D; (byte)(b+4); 因为b+4，所以b本应该转为int，强制转为byte。</p><h1 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h1><p>计算机以二进制补码的形式保存所有的整数。</p><p>二进制的整数有如下三种形式：</p><p>原码：直接将一个数值换成二进制数。最高位是符号位</p><p>负数的反码：是对原码按位取反，只是最高位（符号位）确定为1。</p><p>负数的补码：其反码加1。</p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/179340a832b9598d2647f5a9a945cca6.png"></p><p>注意：</p><p>（1）算术“与”，是他们的二进制对位相乘</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/b6173a8c4299bc0ac4c4ef3a4255a451.png"></p><p>十进制的60转为十六进制</p><p>第三行强制转char，就可以把i2-10（int） + ‘A’（char）输出char型的字符</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/97036da0445e779eee4093d4e43a3033.png"></p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/4364d6b2393b25cbb8f13607f76be3bc.png"></p><p>练习：表示三位数的各个位：</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/d701ed856ca0f8ab75265be767d04ed7.png"></p><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>+&#x3D;, -&#x3D;, *&#x3D;, &#x2F;&#x3D;, %&#x3D;</p><p>以+&#x3D;为例，格式都一样的:</p><p>x +&#x3D; 2； (不改变数据类型)</p><p>x &#x3D; x + 2; （x初始为short，输出的x应为int，所以编译错误，没有强行转换）</p><p>练习：</p><p>int n &#x3D; 10;</p><p>n +&#x3D; (n++) + (++n);</p><p>System.out.println(n); 答案：n &#x3D; 32；</p><p>解答：n &#x3D; n + (n++) + (++n)</p><p>每个n对应的值： 10 10 12</p><h2 id="比较运算符（关系运算符）"><a href="#比较运算符（关系运算符）" class="headerlink" title="比较运算符（关系运算符）"></a>比较运算符（关系运算符）</h2><p> <img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/2feb64c93276156a1d4d76a76dc11858.png"></p><p> <img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/15dea6b312bcf143fefe414eaf182f07.png"></p><p> 第七行是把true赋值给y，这个（y&#x3D;true）括号就为真</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>&amp;—逻辑与| —逻辑或！—逻辑非</p><p>&amp;&amp; —短路与|| —短路或^ —逻辑异或</p><p>开发中推荐 &amp;&amp; 和 ||</p><p>A.“&amp;”和“&amp;&amp;”的区别：</p><p>&amp;时，左边无论真假，右边都进行运算；</p><p>&amp;&amp;时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。</p><p>int n &#x3D; 10;</p><p>false &amp; (n++); n &#x3D; 11 true&amp; (n++); n &#x3D; 11</p><p>false &amp;&amp; (n++); n &#x3D; 10 true&amp;&amp; (n++); n &#x3D; 11</p><p>B.“|”和“||”的区别同理，||表示：当左边为真，右边不参与运算。</p><p>C.异或( ^ )与或( | )的不同之处是：当左右都为true时，结果为false。</p><p>理解：异或，追求的是“异”!</p><p>D.在Java中不可以写成3&lt;x&lt;6，应该写成x&gt;3 &amp; x&lt;6 。因为前面3&lt;x已经为布尔型数据，不能再和6去比较了。</p><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算是直接对整数的二进制进行的运算</p><p> <img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/31adb1eae51860922821e7ae1afd859d.png"></p><p> <img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/19ac3471509dba3505b8823a23201b3a.png"></p><p> <img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/6518e66a4d8449126432f613ccbea5f1.png"></p><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p> <img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/e8dc59a21791b53e9c35d00a21c9ebc9.png"></p><p> 表达式1和表达式2为同种类型，可以嵌套</p><p>三元运算符与if-else的联系与区别：</p><p>1）三元运算符可简化if-else语句,比if -else运行效率高。</p><p>2）三元运算符要求必须返回一个结果。</p><p>3）if后的代码块可有多个语句</p><p>练习：</p><p>A.两个数比大小</p><p>int n &#x3D; 10;</p><p>int m &#x3D; 20;</p><p>int out &#x3D; (m&gt;n) ? “m大” ：（(n &#x3D;&#x3D; m) ? “m和n一样大” ：“n大”）</p><p>B.三个数取最大</p><p>Int n &#x3D; 10;</p><p>int m &#x3D; 20;</p><p>int z &#x3D; 30;</p><p>int max &#x3D; (n&lt;m) ? ((m&lt;z) ? z : m) : ((n&gt;z) ? n : z)</p><h1 id="控制台输入"><a href="#控制台输入" class="headerlink" title="控制台输入"></a>控制台输入</h1><p> <img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/e1147b40591a9cc107f80be9e2578c3f.png"></p><p> 通过Scanner类来输入，如果是String，调用next（），其他类型数据就nextXxx（）。</p><p> <img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/e31ca3f0cc7045a7ef0d1a0e2aa39e89.png"></p><h1 id="程序流程控制"><a href="#程序流程控制" class="headerlink" title="程序流程控制"></a>程序流程控制</h1><p>流程控制语句是用来控制程序中各语句执行顺序的语句</p><h2 id="三种基本流程结构"><a href="#三种基本流程结构" class="headerlink" title="三种基本流程结构:"></a>三种基本流程结构:</h2><p>A.顺序结构</p><p>B.分支结构</p><p>根据条件，选择性地执行某段代码。</p><p>有if…else和switch-case两种分支语句。</p><p>C.循环结构</p><p>根据循环条件，重复性的执行某段代码。</p><p>有while、do…while、for三种循环语句。</p><p>注：JDK1.5提供了foreach循环，方便的遍历集合、数组元素。</p><p>循环语句的四个组成部分：</p><p>A.初始化部分(init_statement)</p><p>B.循环条件部分(test_exp)</p><p>C.循环体部分(body_statement)</p><p>D.迭代部分(alter_statement)</p><h2 id="if-else结构"><a href="#if-else结构" class="headerlink" title="if-else结构"></a>if-else结构</h2><p>注意：</p><p>当多个条件是“互斥”关系时，条件判断语句及执行语句间顺序无所谓</p><p>当多个条件是“包含”关系时，“小上大下 &#x2F; 子上父下”</p><h2 id="switch-case结构"><a href="#switch-case结构" class="headerlink" title="switch-case结构"></a>switch-case结构</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">switch</span><span class="token punctuation">(</span>表达式<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> 常量<span class="token number">1</span><span class="token operator">:</span>        语句<span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// break;</span>    <span class="token keyword">case</span> 常量<span class="token number">2</span><span class="token operator">:</span>        语句<span class="token number">2</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// break;</span>     … …    <span class="token keyword">case</span> 常量N<span class="token operator">:</span>        语句N<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// break;</span>    <span class="token keyword">default</span><span class="token operator">:</span>        语句<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// break;</span><span class="token punctuation">}</span></code></pre><p>switch和if语句的对比：</p><p>（1）如果判断的具体数值不多，而且符合byte、short 、char、int、String、枚举等几</p><p>种类型。虽然两个语句都可以使用，建议使用swtich语句。因为效率稍高。</p><p>（2）其他情况：对区间判断，对结果为boolean类型判断，使用if，if的使用范围更广。</p><p>也就是说，使用switch-case的，都可以改写为if-else。反之不成立。</p><p>注意：</p><p>（1）switch(表达式)中表达式的值必须是下述几种类型之一：</p><p>byte，short，char，int，枚举(jdk 5.0)，String (jdk 7.0)；</p><p>（2）case子句中的值必须是常量，不能是变量名或不确定的表达式值；</p><p>（3）同一个switch语句，所有case子句中的常量值互不相同；</p><p>（4）break语句用来在执行完一个case分支后使程序跳出switch语句块；</p><p>如果没有break，程序会顺序执行到switch结尾</p><p>（5）default子句是可任选的。同时，位置也是灵活的。当没有匹配的case时，执行default</p><p>（6）多个case执行相同语句，可以考虑合并</p><p> <img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/3a91ccc7b58fb53e845fdb107744ddc4.png"></p><p>（7）编写程序：从键盘上输入2019年的“month”和“day”，要求通过程序输出输入的日期为2019年的第几天。</p><p>break不加的情况。</p><p>倒着写，把前面的结果累加。</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/96138c3f812a2d5cfb6d06167868f7a5.png"></p><p>每次加的是上个月的天数，最后加一下本月的天数。</p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span>①初始化部分<span class="token punctuation">;</span> ②循环条件部分<span class="token punctuation">;</span> ④迭代部分<span class="token punctuation">)</span>｛③循环体部分<span class="token punctuation">;</span>｝</code></pre><p>执行过程：<br>①-②-③-④-②-③-④-②-③-④-…..-②</p><p>说明：</p><p>②循环条件部分为boolean类型表达式，当值为false时，退出循环</p><p>①初始化部分可以声明多个变量，但必须是同一个类型，用逗号分隔</p><p>④可以有多个变量更新，用逗号分隔</p><p>题目：输入两个正整数m和n，求其最大公约数和最小公倍数。</p><p>比如：12和20的最大公约数是4，最小公倍数是60。</p><p>说明：break关键字的使用。比如公约数为1，2，4，找最大，可以倒着判断，从大到小取模，会先找到4，4ok就退出循环。</p><p> <img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/929c119a33c59f0de3aacd04c466ae99.png"></p><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>语法格式</p><pre class=" language-java"><code class="language-java">①初始化部分<span class="token keyword">while</span><span class="token punctuation">(</span>②循环条件部分<span class="token punctuation">)</span>｛    ③循环体部分<span class="token punctuation">;</span>    ④迭代部分<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>执行过程：</p><p>①-②-③-④-②-③-④-②-③-④-…-②</p><p>说明：</p><p>注意不要忘记声明④迭代部分。否则，循环将不能结束，变成死循环。</p><p>for循环和while循环可以相互转换</p><p> <img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/543e421b7d51a9b188265fc3f21c52d0.png"></p><p> 不确定循环次数，通过循环体内容判断，然后break跳出循环体。</p><p>Boolean isFlag &#x3D; true；</p><p>while（isFlag）{</p><p>…….</p><p>If(…….){</p><p>…..</p><p>Break;</p><p>}</p><p>}</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/31fa3ecfe1d4d863e8c85901b21d0216.png"></p><h2 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h2><p>语法格式</p><p>①初始化部分;</p><p>do{</p><p>③循环体部分</p><p>④迭代部分</p><p>}while(②循环条件部分);</p><p>执行过程：</p><p>①-③-④-②-③-④-②-③-④-…②</p><p>说明：</p><p>do-while循环至少执行一次循环体。</p><p>练习：100以内的所有质数</p><p> <img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/ecf81322038570559e05accbaa55309f.png"></p><p> 1.Math.sqrt()为开根号，如果可以被除开，或有一对数，一大一小，小的数&lt;开根号，极大提高速度。</p><p>2.break，发现有一个被除开，就不要继续运算了</p><h2 id="break、continue、return"><a href="#break、continue、return" class="headerlink" title="break、continue、return"></a>break、continue、return</h2><p>（1）break</p><p>break语句用于终止某个语句块的执行</p><p>{ ……</p><p>break;</p><p>……</p><p>}</p><p>break语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是</p><p>哪一层语句块</p><p>label1: { ……</p><p>label2: { ……</p><p>label3: { ……</p><p>break label2;</p><p>……</p><p>}</p><p>}</p><p>}</p><p>（2）continue</p><p>continue只能使用在循环结构中</p><p>continue语句用于跳过其所在循环语句块的一次执行，继续下一次循环</p><p>continue语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环</p><p>（3）return</p><p>并非专门用于结束循环的，它的功能是结束一个方法。</p><p>当一个方法执行到一个return语句时，这个方法将被结束。</p><p>与break和continue不同的是，return直接结束整个方法，不管return处于多少层循环之内</p><p>总结：</p><p>break只能用于switch语句和循环语句中。</p><p>continue 只能用于循环语句中。</p><p>二者功能类似，但continue是终止本次循环，break是终止本层循环。</p><p>break、continue之后不能有其他的语句，因为程序永远不会执行其后的语句。</p><p>标号语句必须紧接在循环的头部。标号语句不能用在非循环语句的前面。</p><p>很多语言都有goto语句，goto语句可以随意将控制转移到程序中的任意一条语句上，然后执行它。但使程序容易出错。Java中的break和continue是不同于goto的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java零碎知识</title>
      <link href="/2022/04/05/javanotes/java12/"/>
      <url>/2022/04/05/javanotes/java12/</url>
      
        <content type="html"><![CDATA[<p>1.在字符串“”中，加入双引号，会与方法中的“”混淆。</p><p>分别在前面加 \ ,即可打印出双引号</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/949868f61ded78a8084ad5ed940b29a5.png"></p><p>2.产生随机数</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">90</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// [10.0, 100.0)</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span>b<span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>b <span class="token operator">-</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> a<span class="token punctuation">)</span></code></pre><p>3.\t</p><pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"制表符：这是一个 \t 空格"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是一个斜杠t：\\t ，双斜杠取消修饰符"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/28e5cf22c4063fa83f1e1797d6c76b58.png"></p><p>4.数组是有序的，对数组其中一位删除，后面的要依次往前补一个</p><p>5.判断数据是否等于某字符串时，把字符串放在前面，避免data出现空指针（.equals报错）</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/3a5573c36513d23751dfacf16bfd172b.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java（一）语言概述</title>
      <link href="/2022/03/28/javanotes/java1/"/>
      <url>/2022/03/28/javanotes/java1/</url>
      
        <content type="html"><![CDATA[<h1 id="java语言的特点是什么？"><a href="#java语言的特点是什么？" class="headerlink" title="java语言的特点是什么？"></a>java语言的特点是什么？</h1><p>面向对象性：两个基本概念（要素）：类、对象；三大特性：封装、继承、多态<br>健壮性：吸收了C&#x2F;C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制<br>跨平台性：通过Java语言编写的应用程序在不同的系统平台上都可以运行。“Write once , Run Anywhere”</p><h1 id="软件开发"><a href="#软件开发" class="headerlink" title="软件开发"></a>软件开发</h1><p>软件，即一系列按照特定顺序组织的计算机数据和指令的集合。有系统软件和应用软件之分。</p><p>系统软件：windows、mac os、linux、android、ios…</p><p>应用软件：ppt、画图板、word…</p><h1 id="人机交互方式"><a href="#人机交互方式" class="headerlink" title="人机交互方式"></a>人机交互方式</h1><p>图形化界面(Graphical User Interface GUI)：这种方式简单直观</p><p>命令行方式(Command Line Interface CLI)：需要有一个控制台，输入特定的指令，让计算机完成一些操作。</p><p>Pascal之父Nicklaus Wirth：“Algorithms+Data Structures&#x3D;Programs”</p><p>应用程序 &#x3D; 算法 + 数据结构</p><h1 id="常用的DOS命令（cmd）"><a href="#常用的DOS命令（cmd）" class="headerlink" title="常用的DOS命令（cmd）"></a>常用的DOS命令（cmd）</h1><p>dir : 列出当前目录下的文件以及文件夹</p><p>md : 创建目录</p><p>rd : 删除目录</p><p>cd : 进入指定目录</p><p>cd.. : 退回到上一级目录</p><p>cd: 退回到根目录</p><p>del : 删除文件</p><p>exit : 退出dos 命令行</p><h1 id="Java优势"><a href="#Java优势" class="headerlink" title="Java优势"></a>Java优势</h1><p>A.纯粹的面向对象</p><p>B.舍弃了C语言中容易引起错误的指针</p><p>C.增加了垃圾回收器功能</p><h1 id="Java两种核心机制"><a href="#Java两种核心机制" class="headerlink" title="Java两种核心机制"></a>Java两种核心机制</h1><p>Java虚拟机（Java Virtal Machine），JVM</p><p>垃圾收集机制（Garbage Collection），也会出现内存泄漏、内存溢出事件。</p><h1 id="System-out-println-和System-out-print-什么区别呢？"><a href="#System-out-println-和System-out-print-什么区别呢？" class="headerlink" title="System.out.println()和System.out.print()什么区别呢？"></a>System.out.println()和System.out.print()什么区别呢？</h1><p>System.out.println();打印完后，会换行。</p><p>System.out.print();打印完后，不会换行。</p><p>\n(换行)，\t(制表符)</p><h1 id="一个”-java”源文件中是否可以包括多个类（不是内部类）？"><a href="#一个”-java”源文件中是否可以包括多个类（不是内部类）？" class="headerlink" title="一个”.java”源文件中是否可以包括多个类（不是内部类）？"></a>一个”.java”源文件中是否可以包括多个类（不是内部类）？</h1><p>答：可以。但最多只有一个类名声明为public，与文件名相同。</p><h1 id="文件名和类名"><a href="#文件名和类名" class="headerlink" title="文件名和类名"></a>文件名和类名</h1><p>Something类的文件名叫OtherThing.java</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Something</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> something_to_do<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Do something ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个很明显。</p><p>答案: 正确。从来没有人说过Java的class名字必须和其文件名相同。但public class的名字必须和文件名相同。</p><h1 id="配置环境变量为什么要设置path（设置path的目的是什么）？"><a href="#配置环境变量为什么要设置path（设置path的目的是什么）？" class="headerlink" title="配置环境变量为什么要设置path（设置path的目的是什么）？"></a>配置环境变量为什么要设置path（设置path的目的是什么）？</h1><p>目的是为了在控制台的任何文件路径下，都可以调用jdk指定目录下的所有指令。</p><h1 id="JDK-JRE和JVM，以及关系是什么？"><a href="#JDK-JRE和JVM，以及关系是什么？" class="headerlink" title="JDK,JRE和JVM，以及关系是什么？"></a>JDK,JRE和JVM，以及关系是什么？</h1><p>JDK: Java Development Kit Java 开发工具包</p><p>JRE: Java Runtime Environment Java运行环境</p><p>关系：</p><p>使用JDK的开发工具完成的Java程序，交给JRE运行。</p><p>JDK包含JRE，JRE包含JVM.</p><p>JDK &#x3D; JRE + 开发工具集（如javac编译工具）</p><p>JRE &#x3D; JVM + Java SE 标准类库</p><h1 id="终端／cmd运行程序格式？"><a href="#终端／cmd运行程序格式？" class="headerlink" title="终端／cmd运行程序格式？"></a>终端／cmd运行程序格式？</h1><p>编译：javac 源文件名.java （会生成类名.calss的文件，称为字节码文件）</p><p>运行：java 类名 （不要加后缀.class）</p><h1 id="程序的入口"><a href="#程序的入口" class="headerlink" title="程序的入口"></a>程序的入口</h1><p>main()方法</p><p>Public static void main(String[] args)</p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>分为单行注释、多行注释、文档注释（java特有）</p><p>单行注释、多行注释——对程序进行说明，增加可读性，不参与编译，.class文件不包含。</p><p>文档注释——可以被jdk提供的工具javadoc解析，生成一套以网页文件形式的说明文档。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="/2022/02/20/git/"/>
      <url>/2022/02/20/git/</url>
      
        <content type="html"><![CDATA[<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><ul><li><h2 id="初始化本地库"><a href="#初始化本地库" class="headerlink" title="初始化本地库"></a>初始化本地库</h2></li></ul><pre class=" language-Bash"><code class="language-Bash">git init</code></pre><ul><li><h2 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h2></li></ul><pre class=" language-Bash"><code class="language-Bash">git status</code></pre><h1 id="推"><a href="#推" class="headerlink" title="推"></a>推</h1><ul><li><h2 id="添加到暂缓区"><a href="#添加到暂缓区" class="headerlink" title="添加到暂缓区"></a>添加到暂缓区</h2></li></ul><pre class=" language-Bash"><code class="language-Bash">git add .</code></pre><ul><li><h2 id="提交至本地库"><a href="#提交至本地库" class="headerlink" title="提交至本地库"></a>提交至本地库</h2></li></ul><pre class=" language-Bash"><code class="language-Bash">git commit -m '提交信息'</code></pre><ul><li><h2 id="推到远程仓库"><a href="#推到远程仓库" class="headerlink" title="推到远程仓库"></a>推到远程仓库</h2></li></ul><pre class=" language-Bash"><code class="language-Bash">git push</code></pre><h1 id="拉"><a href="#拉" class="headerlink" title="拉"></a>拉</h1><ul><li><h2 id="下拉并与本地合并"><a href="#下拉并与本地合并" class="headerlink" title="下拉并与本地合并"></a>下拉并与本地合并</h2></li></ul><pre class=" language-Bash"><code class="language-Bash">git pull</code></pre><ul><li><h2 id="如未知关联的仓库"><a href="#如未知关联的仓库" class="headerlink" title="如未知关联的仓库"></a>如未知关联的仓库</h2></li></ul><pre class=" language-Bash"><code class="language-Bash">git pull 仓库名 分支名</code></pre><h1 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h1><p>冲突产生的表现：后面状态为MERGING</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/img/57e02acec7b8b8e0f654934c039e9bb3.png"></p><ul><li>查看状态</li></ul><pre class=" language-Bash"><code class="language-Bash">git status</code></pre><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/img/fd0174cbfce59addaf90bb936b2fd5eb.png"></p><p>解决合并问题：</p><p>1）编辑有冲突的文件，删除特殊符号，决定要使用的内容</p><p>特殊符号：<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 当前分支的代码======= 合并过来的代码&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code></p><p>2）添加到暂存区</p><pre class=" language-Bash"><code class="language-Bash">git add XXXX（文件名） 或 git add .</code></pre><p>3）查看解决状态，全部绿色（modified修改过）</p><pre class=" language-Bash"><code class="language-Bash">git status</code></pre><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/img/552a8ad42e123ea5e10a70e027dba00e.png"></p><p>4）执行提交（注意：此时使用git commit 命令时不能带文件名）</p><pre class=" language-Bash"><code class="language-Bash">git commit -m ' '</code></pre><p>发现后面MERGING 消失，变为正常</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/img/52b7fdf6e1ddb65b57e28ce92189a6ec.png"></p><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><ul><li><h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2></li></ul><pre class=" language-Bash"><code class="language-Bash">git branch 分支名</code></pre><ul><li><h2 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h2></li></ul><pre class=" language-Bash"><code class="language-Bash">git branch -v</code></pre><ul><li><h2 id="切换分支（切换分支的本质就是移动HEAD-指针）"><a href="#切换分支（切换分支的本质就是移动HEAD-指针）" class="headerlink" title="切换分支（切换分支的本质就是移动HEAD 指针）"></a>切换分支（切换分支的本质就是移动HEAD 指针）</h2></li></ul><pre class=" language-Bash"><code class="language-Bash">git checkout 分支名</code></pre><ul><li><h2 id="指定分支合并到当前分支"><a href="#指定分支合并到当前分支" class="headerlink" title="指定分支合并到当前分支"></a>指定分支合并到当前分支</h2></li></ul><pre class=" language-Bash"><code class="language-Bash">git merge 分支名</code></pre><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/img/b2ac0f41fb9fa4621cdc29209adcd2bd.png"></p><h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><ul><li><h2 id="查看历史记录"><a href="#查看历史记录" class="headerlink" title="查看历史记录"></a>查看历史记录</h2></li></ul><pre class=" language-Bash"><code class="language-Bash">git reflog</code></pre><ul><li><h2 id="版本穿梭"><a href="#版本穿梭" class="headerlink" title="版本穿梭"></a>版本穿梭</h2></li></ul><pre class=" language-Bash"><code class="language-Bash">git reset --hard 版本号</code></pre><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/img/ed7d30769d8dcd9b6b10fc6b00e47bca.png"></p><h1 id="vim相关操作"><a href="#vim相关操作" class="headerlink" title="vim相关操作"></a>vim相关操作</h1><p>主要用到：</p><p>“a”进入编辑</p><p>“Esc”退出编辑</p><p>“shift + :”开始编辑命令</p><p>“:wq”保存</p><p>“:q”退出vim</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/img/5320d98f969a0ceb31459fc7709aee67.png"></p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/img/4be93568a0522540764bf5a8f66b6ae7.png"></p><h1 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h1><pre><code>git remote add 仓库名（本地自拟） git@xxx.github.com:用户名/仓库.git</code></pre><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/img/83939ba5a3ff4ac70ac4de6a49408d18.png"><br>如果是推到新的仓库，出现以下情况，</p><p>则是：远程仓库中有着本地仓库没有的文件，由于远程仓库和本地仓库没有共同的commit，需要先pull<br><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/img/a7b47c89caeca75e6a55961785655fa6.png"><br>拒绝合并不相关的历史<br><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/img/bff674eb63d3e263de3d7c57612ec168.png"><br>所以需要：</p><pre class=" language-Bash"><code class="language-Bash">git pull origin master --allow-unrelated-histories</code></pre><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/img/6afab4a5a34889f623d1dfdb69f11007.png"><br>完成！</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown</title>
      <link href="/2022/02/16/markdown/"/>
      <url>/2022/02/16/markdown/</url>
      
        <content type="html"><![CDATA[<p>Markdown 是一种轻量级标记语言，它用简洁的语法代替排版，使我们专心于码字。它的目标是实现易读易写，成为一种适用于网络的书写语言。同时，Markdown支持嵌入html标签。<br>注意：符号后面必须跟至少1个空格才有效！</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><pre class=" language-markdown"><code class="language-markdown"><span class="token title important"><span class="token punctuation">#</span> 一级标题</span><span class="token title important"><span class="token punctuation">##</span> 二级标题</span><span class="token title important"><span class="token punctuation">###</span> 三级标题</span></code></pre><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ul><li>Red</li><li>Green</li><li>Blue</li></ul><pre class=" language-markdown"><code class="language-markdown"><span class="token list punctuation">-</span> Red<span class="token list punctuation">-</span> Green<span class="token list punctuation">-</span> Blue</code></pre><h2 id="标号"><a href="#标号" class="headerlink" title="标号"></a>标号</h2><ol><li>Red</li><li>Green</li><li>Blue</li></ol><pre class=" language-markdown"><code class="language-markdown"><span class="token list punctuation">1.</span> Red<span class="token list punctuation">2.</span> Green<span class="token list punctuation">3.</span> Blue</code></pre><h2 id="打开本地服务器"><a href="#打开本地服务器" class="headerlink" title="打开本地服务器"></a>打开本地服务器</h2><blockquote><p>一级引用</p><blockquote><p>二级引用</p><blockquote><p>三级引用</p></blockquote></blockquote></blockquote><blockquote><p>引用 ，注意：在<code>&gt;</code>后面有 1 个空格</p><pre><code>这是引用的代码块形式    //在`&gt;`后面有 5 个空格</code></pre></blockquote><blockquote><p>代码例子：<br>    protected void onCreate(Bundle savedInstanceState) {<br>        super.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>    }</p></blockquote><pre class=" language-markdown"><code class="language-markdown"><span class="token blockquote punctuation">></span> 一级引用<span class="token blockquote punctuation">> ></span> 二级引用<span class="token blockquote punctuation">> > ></span> 三级引用</code></pre><pre class=" language-markdown"><code class="language-markdown"><span class="token blockquote punctuation">></span> 引用 ，注意：在<span class="token code keyword">`>`</span>后面有 1 个空格<span class="token blockquote punctuation">></span> <span class="token blockquote punctuation">></span><span class="token code keyword">     这是引用的代码块形式    //在`>`后面有 5 个空格</span></code></pre><pre class=" language-markdown"><code class="language-markdown"><span class="token blockquote punctuation">></span> 代码例子：<span class="token code keyword">    protected void onCreate(Bundle savedInstanceState) {</span><span class="token code keyword">        super.onCreate(savedInstanceState);</span><span class="token code keyword">        setContentView(R.layout.activity_main);</span><span class="token code keyword">    }</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo</title>
      <link href="/2022/02/15/hexo/"/>
      <url>/2022/02/15/hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h2><pre class=" language-bash"><code class="language-bash">hexo clean</code></pre><h2 id="构建静态文件"><a href="#构建静态文件" class="headerlink" title="构建静态文件"></a>构建静态文件</h2><pre class=" language-bash"><code class="language-bash">hexo g</code></pre><h2 id="上传至仓库"><a href="#上传至仓库" class="headerlink" title="上传至仓库"></a>上传至仓库</h2><pre class=" language-bash"><code class="language-bash">hexo d</code></pre><h2 id="打开本地服务器"><a href="#打开本地服务器" class="headerlink" title="打开本地服务器"></a>打开本地服务器</h2><pre class=" language-bash"><code class="language-bash">hexo server //可进行本地调试</code></pre>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
