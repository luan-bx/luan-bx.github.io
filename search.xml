<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java笔记（六）面向对象（下）</title>
      <link href="/2022/04/25/java6/"/>
      <url>/2022/04/25/java6/</url>
      
        <content type="html"><![CDATA[<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="类属性、类方法"><a href="#类属性、类方法" class="headerlink" title="类属性、类方法"></a>类属性、类方法</h2><p>类属性作为该类各个对象之间共享的变量。在设计类时,分析哪些属性不因对象的不同而改变，将这些属性设置为类属性。相应的方法设置为类方法。</p><p>类变量（类属性）由该类的所有实例共享.</p><p>如果方法与调用者无关，则这样的方法通常被声明为类方法，由于不需要创建对象就可以调用类方法，从而简化了方法的调用。</p><h2 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h2><p>在Java类中，可用static修饰：属性、方法、代码块、内部类 </p><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><ol><li>随着类的加载而加载 </li><li>优先于对象存在 </li><li>修饰的成员，被所有对象所共享 </li><li>访问权限允许时，可不创建对象，直接被类调用(如Person.id、Person.add(int num) )</li><li>调用时，在一处修改了static的变量或方法，所有调用该static的均同步变化。</li><li>在static方法内部只能访问类的static修饰的属性或方法，不能访问类的非static结构。</li><li>因为不需要实例就可访问static方法，因此static方法内部不能有this,也不能有super 。</li><li>static修饰的方法不能被重写。</li></ol><h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。“套路” </p><h2 id="单例设计模式-1"><a href="#单例设计模式-1" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的构造器的访问权限设置为private，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的。</p><h2 id="单例-饿汉式"><a href="#单例-饿汉式" class="headerlink" title="单例-饿汉式"></a>单例-饿汉式</h2><p>一加载类就new好了，等待调用。</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/709cf37cc9f052e30b95c055e1b82d72.png"></p><h2 id="单例-懒汉式"><a href="#单例-懒汉式" class="headerlink" title="单例-懒汉式"></a>单例-懒汉式</h2><p>用的时候再new</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/4d4d17c8c32a7ad6530086db0c91d857.png"></p><h2 id="单例模式的优点"><a href="#单例模式的优点" class="headerlink" title="单例模式的优点"></a>单例模式的优点</h2><p>由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。</p><h2 id="单例设计模式应用"><a href="#单例设计模式应用" class="headerlink" title="单例设计模式应用"></a>单例设计模式应用</h2><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/75c18bbd715c20b17f6c8ffa1511c05e.png"></p><h1 id="main"><a href="#main" class="headerlink" title="main"></a>main</h1><p>因为main() 方法是静态的，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员。</p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>对Java类或对象进行初始化</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>一个类中代码块若有修饰符，则只能被static修饰，称为静态代码块(static block)，没有使用static修饰的，为非静态代码块。</p><p>static代码块通常用于初始化static的属性</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>A.静态代码块：用static 修饰的代码块</p><ol><li><p>可以有输出语句。</p></li><li><p>可以对类的属性、类的声明进行初始化操作。</p></li><li><p>不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。</p></li><li><p>若有多个静态的代码块，那么按照从上到下的顺序依次执行。</p></li><li><p>静态代码块的执行要先于非静态代码块。</p></li><li><p>静态代码块随着类的加载而加载，且只执行一次。</p></li></ol><p>B.非静态代码块：没有static修饰的代码块</p><ol><li><p>可以有输出语句。</p></li><li><p>可以对类的属性、类的声明进行初始化操作。</p></li><li><p>除了调用非静态的结构外，还可以调用静态的变量或方法。</p></li><li><p>若有多个非静态的代码块，那么按照从上到下的顺序依次执行。</p></li><li><p>每次创建对象的时候，都会执行一次。且先于构造器执行。</p></li></ol><h2 id="分析运行顺序"><a href="#分析运行顺序" class="headerlink" title="分析运行顺序"></a>分析运行顺序</h2><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/a7f2a2103ec4c85b8f7560dc2bbd8fa7.png"></p><p>先执行的是father的static代码块，然后son的static代码块，才是打印“777777777”，因为main方法的运行，需要son类的加载，又继承了father，所以从father开始打印。</p><h2 id="属性赋值的位置"><a href="#属性赋值的位置" class="headerlink" title="属性赋值的位置"></a>属性赋值的位置</h2><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/01ff1c2927b7a994314cb03b0e3fec01.png"></p><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>声明类、变量和方法时，可使用关键字final来修饰,表示“最终的”。</p><p>A.final标记的类不能被继承。提高安全性，提高程序的可读性。</p><p>如：String类、System类、StringBuffer类</p><p>B.final标记的方法不能被子类重写。</p><p>如：Object类中的getClass()。</p><p>C.final标记的变量(成员变量或局部变量)称为常量。名称大写，且只能被赋值一次,不可修改。final标记的成员变量必须在声明时或在每个构造器中或代码块中显式赋值，然后才能使用。</p><p>如：final double MY_PI &#x3D; 3.14;</p><p>static final：全局常量</p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>第一题：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Something</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">addOne</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">++</span>x<span class="token punctuation">;</span> 错误，对x进行修改了        <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> 正确，对x没有变化，只是用x进行运算。    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>第二题：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Something</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Other o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Other</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addOne</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addOne</span><span class="token punctuation">(</span><span class="token keyword">final</span> Other o<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Other</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 错误，对象o重新赋值。        o<span class="token punctuation">.</span>i<span class="token operator">++</span><span class="token punctuation">;</span> 正确，对象o的属性依然可以重新改写。    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">class</span> <span class="token class-name">Other</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>         <span class="token keyword">public</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="final属性赋值位置"><a href="#final属性赋值位置" class="headerlink" title="final属性赋值位置"></a>final属性赋值位置</h2><p>加载类之前一定要赋值,否则此属性不能再赋值了。</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/634faa1a27ec57c6e5b2a36e7b52d69a.png"></p><h1 id="抽象类、抽象方法"><a href="#抽象类、抽象方法" class="headerlink" title="抽象类、抽象方法"></a>抽象类、抽象方法</h1><p>有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ol><li><p>用abstract关键字来修饰一个类，这个类叫做抽象类。</p></li><li><p>用abstract来修饰一个方法，该方法叫做抽象方法。</p><p> 抽象方法：只有方法的声明，没有方法的实现。以分号结束：</p><p> 比如：public abstract void talk();</p></li><li><p>含有抽象方法的类必须被声明为抽象类。</p></li><li><p>抽象类不能被实例化。抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。</p></li><li><p>不能用abstract修饰变量、代码块、构造器；</p></li><li><p>不能用abstract修饰私有方法、静态方法、final的方法、final的类。</p></li></ol><p>个人理解：相当于规定了子类应该有哪些方法，各个子类根据实际情况执行自己的代码。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>超类声明一个方法但不提供实现，该方法的实现由子类提供。这样的方法称为抽象方法。有一个或更多抽象方法的类称为抽象类。</p><h2 id="模板方法设计模式（多态的应用）"><a href="#模板方法设计模式（多态的应用）" class="headerlink" title="模板方法设计模式（多态的应用）"></a>模板方法设计模式（多态的应用）</h2><p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</p><p>解决的问题：</p><p>当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</p><p>换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h2><p>一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。</p><p>另一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又没有is-a的关系，仅仅是具有相同的行为特征而已。例如：鼠标、键盘、打印机、扫描仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等都支持USB连接。</p><p>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是&#x2F;要…则必须能…”的思想。继承是一个”是不是”的关系，而接口实现则是 “能不能”的关系。</p><p>接口的本质是契约，标准，规范，就像我们的法律一样。制定好后大家都要遵守。</p><p>接口(interface)是抽象方法和常量值定义的集合。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li><p>用interface来定义。</p></li><li><p>接口中的所有成员变量都默认是由public static final修饰的。</p></li><li><p>接口中的所有抽象方法都默认是由public abstract修饰的。</p></li><li><p>接口中没有构造器。</p></li><li><p>接口采用多继承机制。</p></li></ol><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/b546e6d5db2292cf4971ac6d72e20375.png"></p><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><ol><li>定义Java类的语法格式：先写extends，后写implements</li></ol><p><code>class SubClass extends SuperClass implements InterfaceA&#123; &#125;</code></p><ol start="2"><li><p>一个类可以实现多个接口，接口也可以继承其它接口。</p></li><li><p>实现接口的类必须提供接口中所有方法的具体实现内容，方可实例化。否则，仍为抽象类。</p></li><li><p>接口的主要用途就是被实现类实现。（面向接口编程）</p></li><li><p>与继承关系类似，接口与实现类之间存在多态性</p></li><li><p>接口和类是并列关系，或者可以理解为一种特殊的类。从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义(JDK7.0及之前)，而没有变量和方法的实现。</p></li><li><p>分别介绍本类、父类、接口的调用：</p></li></ol><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/8fe06d507ad6ca7bf22811b1a5bb784f.png"></p><h1 id="代理模式（接口的应用）"><a href="#代理模式（接口的应用）" class="headerlink" title="代理模式（接口的应用）"></a>代理模式（接口的应用）</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li><p>安全代理：屏蔽对真实角色的直接访问。</p></li><li><p>远程代理：通过代理类处理远程方法调用（RMI）</p></li><li><p>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象</p></li></ol><p>比如你要开发一个大文档查看软件，大文档中有大的图片，有可能一个图片有100MB，在打开文件时，不可能将所有的图片都显示出来，这样就可以使用代理模式，当需要查看图片时，用proxy来进行大图片的打开。</p><p>分类:</p><p>静态代理（静态定义代理类）</p><p>动态代理（动态生成代理类）</p><p>JDK自带的动态代理，需要反射等知识</p><h1 id="接口与抽象类对比"><a href="#接口与抽象类对比" class="headerlink" title="接口与抽象类对比"></a>接口与抽象类对比</h1><h2 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h2><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/b5a26bc11945b4112ee36b9496add9e6.png"></p><p>在开发中，常看到一个类不是去继承一个已经实现好的类，而是要么继承抽象类，要么实现接口。</p><h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/5163d2a46e34631286a0d77c843db3c0.png"></p><p>编译错误，接口和继承一个优先级，所以不确定此时x是哪个。</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/f30143fce0d4f84c33dfd00fba1557d7.png"></p><p>编译错误：<code>The final field Rollable.ball cannot be assigned</code></p><p>任何在interface里声明的interface variable (接口变量，也可称成员变量)，默认为public static final。不可修改参数</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/5e4c76fbf6c6d631e8c9551a8c894ac4.png"></p><h2 id="java-8的改进"><a href="#java-8的改进" class="headerlink" title="java 8的改进"></a>java 8的改进</h2><p>Java 8中，你可以为接口添加静态方法和默认方法。从技术角度来说，这是完全合法的，只是它看起来违反了接口作为一个抽象定义的理念。</p><p>静态方法：使用static 关键字修饰。可以通过接口直接调用静态方法，并执行其方法体。我们经常在相互一起使用的类中使用静态方法。你可以在标准库中找到像Collection&#x2F;Collections或者Path&#x2F;Paths这样成对的接口和类。</p><p>默认方法：默认方法使用default 关键字修饰。可以通过实现类对象来调用。我们在已有的接口中提供新方法的同时，还保持了与旧版本代码的兼容性。比如：java 8 API中对Collection、List、Comparator等接口提供了丰富的默认方法。</p><h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>若一个接口中定义了一个默认方法，而另外一个接口中也定义了一个同名同参数的方法（不管此方法是否是默认方法），在实现类同时实现了这两个接口时，会出现：接口冲突。</p><p>解决办法：实现类必须覆盖接口中同名同参数的方法，来解决冲突。</p><p>若一个接口中定义了一个默认方法，而父类中也定义了一个同名同参数的非抽象方法，则不会出现冲突问题。因为此时遵守：类优先原则。接口中具有相同名称和参数的默认方法会被忽略。</p><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h2><p>成员内部类作为类的成员的角色：</p><ol><li><p>和外部类不同，Inner class还可以声明为private或protected；</p></li><li><p>可以调用外部类的结构;</p></li><li><p>可以声明为static的，但此时就不能再使用外层类的非static的成员变量；</p></li></ol><p>成员内部类作为类的角色：</p><ol><li><p>可以在内部定义属性、方法、构造器等结构</p></li><li><p>可以声明为abstract类，因此可以被其它的内部类继承</p></li><li><p>可以声明为final的</p></li><li><p>编译以后生成OuterClass$InnerClass.class字节码文件（也适用于局部内部类）</p></li></ol><p>【注意】</p><ol><li><p>非static的成员内部类中的成员不能声明为static的，只有在外部类或static的成员内部类中才可声明static成员。</p></li><li><p>外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式</p></li><li><p>成员内部类可以直接使用外部类的所有成员，包括私有的数据</p></li><li><p>当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的</p></li></ol><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/fc1953d02ec6a928f1280de2ad9e91fb.png"></p><p>（2）特点</p><ol><li><p>内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号，以及数字编号。</p></li><li><p>只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类。</p></li><li><p>局部内部类可以使用外部类的成员，包括私有的。</p></li><li><p>局部内部类可以使用外部方法的局部变量，但是必须是final的。由局部内部类和局部变量的声明周期不同所致。</p></li><li><p>局部内部类和局部变量地位类似，不能使用public,protected,缺省,private</p></li><li><p>局部内部类不能使用static修饰，因此也不能包含静态成员</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java笔记 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（三）数组</title>
      <link href="/2022/04/12/java3/"/>
      <url>/2022/04/12/java3/</url>
      
        <content type="html"><![CDATA[<h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/77767409030bc88b31f380d640998dda.png"></p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/c6bcc7a0e0f6b15c390869c63f27c32b.png"></p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/a5c4aaf447f8b313c04a2439efd43e3d.png"></p><p>打印二维数组的外层数组，其实相当于打印一个一维数组，只会打印出这个数组存放的地址。其中“[I@15db…”的‘[’表示一维，‘I’ 表示int型。</p><p>倒数第二行为null，即使二维数组是double，但里面的元素数组还未定义类型，而数组的为初始化为null。报错是因为未初始化就取值会报错。</p><h1 id="数组的赋值与复制"><a href="#数组的赋值与复制" class="headerlink" title="数组的赋值与复制"></a>数组的赋值与复制</h1><p>（1）数组的赋值：</p><p>慎用array1 &#x3D; array2 来赋值，虽然把array2 赋值给array1，但修改array1同样修改的是array2，只是将array2的地址给了array1，他俩共用一个数组。</p><p>（2）数组的复制：</p><p>开辟一个新的堆，存放新数组</p><pre class=" language-java"><code class="language-java">array1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>array2<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> array1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    array1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> array2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h1 id="打印数组"><a href="#打印数组" class="headerlink" title="打印数组"></a>打印数组</h1><p>将数组转成String：Arrays.toString()</p><p>System.out.println(“等级” + Arrays.toString(abcd));</p><h1 id="数组算法"><a href="#数组算法" class="headerlink" title="数组算法"></a>数组算法</h1><p>（1）衡量排序算法的优劣</p><p>1.时间复杂度：分析关键字的比较次数和记录的移动次数</p><p>2.空间复杂度：分析排序算法中需要多少辅助内存</p><p>3.稳定性：若两个记录A和B的关键字值相等，但排序后A、B的先后次序保持不变，则称这种排序算法是稳定的。</p><p>（2）排序算法分类</p><p>内部排序和外部排序。</p><p>内部排序：整个排序过程不需要借助于外部存储器（如磁盘等），所有排序操作都在内存中完成。</p><p>外部排序：参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助于外部存储器（如磁盘）。外部排序最常见的是多路归并排序。可以认为外部排序是由多次内部排序组成。</p><p>（3）十大内部排序算法</p><p>a选择排序</p><p>直接选择排序、堆排序</p><p>b交换排序</p><p>冒泡排序、快速排序</p><p>c插入排序</p><p>直接插入排序、折半插入排序、Shell排序</p><p>d归并排序</p><p>e桶式排序</p><p>f基数排序</p><p>(3)冒泡排序</p><p>介绍：</p><p>冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。</p><p>排序思想：</p><ol><li><p>比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。</p></li><li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p></li><li><p>针对所有的元素重复以上的步骤，除了最后一个。</p></li><li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较为止。</p></li></ol><p>(4)快速排序</p><p>介绍：</p><p>快速排序通常明显比同为O(nlogn)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。</p><p>快速排序（Quick Sort）由图灵奖获得者Tony Hoare发明，被列为20世纪十大算法之一，是迄今为止所有内排序算法中速度最快的一种。冒泡排序的升级版，交换排序的一种。快速排序的时间复杂度为O(nlog(n))。</p><p>排序思想：</p><ol><li><p>从数列中挑出一个元素，称为”基准”（pivot），</p></li><li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</p></li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p></li><li><p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java笔记 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（二）基本语法</title>
      <link href="/2022/04/06/java2/"/>
      <url>/2022/04/06/java2/</url>
      
        <content type="html"><![CDATA[<h1 id="关键字-keyword"><a href="#关键字-keyword" class="headerlink" title="关键字(keyword)"></a>关键字(keyword)</h1><p>定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）</p><p>特点：关键字中所有字母都为小写</p><h1 id="保留字-reserved-word"><a href="#保留字-reserved-word" class="headerlink" title="保留字(reserved word)"></a>保留字(reserved word)</h1><p>现有Java版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字：</p><p>goto 、const</p><h1 id="标识符-Identifier"><a href="#标识符-Identifier" class="headerlink" title="标识符(Identifier)"></a>标识符(Identifier)</h1><p>Java 对各种变量、方法和类等要素命名时使用的字符序列称为标识符</p><p>技巧：凡是自己可以起名字的地方都叫标识符。</p><h2 id="定义合法标识符规则："><a href="#定义合法标识符规则：" class="headerlink" title="定义合法标识符规则："></a>定义合法标识符规则：</h2><p>A.由26个英文字母大小写，0-9 ，_或$ 组成</p><p>B.数字不可以开头。</p><p>C.不可以使用关键字和保留字，但能包含关键字和保留字。</p><p>D.Java中严格区分大小写，长度无限制。</p><p>E.标识符不能包含空格。</p><h2 id="Java中的名称命名规范："><a href="#Java中的名称命名规范：" class="headerlink" title="Java中的名称命名规范："></a>Java中的名称命名规范：</h2><p>包名：多单词组成时所有字母都小写：xxxyyyzzz</p><p>类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz</p><p>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个开始首字母大写：xxxYyyZzz</p><p>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</p><p>注意1：在起名字时，为了提高阅读性，要尽量有意义，“见名知意”。</p><p>注意2：java采用unicode字符集，因此标识符也可以使用汉字声明，但是不建议使用。</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值</p><h2 id="变量的分类"><a href="#变量的分类" class="headerlink" title="变量的分类"></a>变量的分类</h2><h3 id="按数据类型"><a href="#按数据类型" class="headerlink" title="按数据类型"></a>按数据类型</h3><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/5f627a070ac3741d7c8bcd3c54955412.png"></p><h3 id="按声明的位置的不同"><a href="#按声明的位置的不同" class="headerlink" title="按声明的位置的不同"></a>按声明的位置的不同</h3><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/7ad96ec73c6094764e008806c67f1458.png"></p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h3><p>（1）整数类型：byte、short、int、long</p><p>整型常量默认为int 型，声明long型常量须后加‘l’或‘L’ ，否则默认为int。</p><p>Java程序中变量通常声明为int型，除非不足以表示较大的数，才使用long。</p><p>（2）浮点类型：float、double</p><p>double:双精度，精度是float的两倍。通常采用此类型。</p><p>浮点型常量默认为double型，声明float型常量，须后加‘f’或‘F’。否则默认为double。</p><p>如下图：因为b1已经为int，f1已经为double。</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/fa88680fb758f54fff69db8fc35d790a.png"></p><h3 id="字符型：char"><a href="#字符型：char" class="headerlink" title="字符型：char"></a>字符型：char</h3><p>用来表示通常意义上“字符”(2字节) ，Java中的所有字符都使用Unicode编码，</p><p>故一个字符可以存储一个字母，一个汉字，或其他书面语的一个字符。</p><p>字符型变量的三种表现形式：</p><p>（1）字符常量是用单引号(‘ ’)括起来的单个字符。</p><p>例如：char c1 &#x3D; ‘a’; char c2 &#x3D; ‘中’; char c3 &#x3D; ‘9’;</p><p>（2）Java中还允许使用转义字符‘\’来将其后的字符转变为特殊字符型常量。</p><p>例如：char c3 &#x3D; ‘\n’; &#x2F;&#x2F; ‘\n’表示换行符</p><p>（3）直接用Unicode值表示字符型常量：‘\uXXXX’。XXXX代表一个十六进制整数。</p><p>例如：\u000a 表示\n。</p><p>char类型是可以进行运算的。因为它都对应有Unicode码。</p><p>Char c1 &#x3D; 97; 和char c2 &#x3D; ‘97’; 是不一样的，c1输出的是Unicode码，c2输出的是符号对应的Unicode码。</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/201eac85b29cc67fed3887802ab7c07d.png"></p><h3 id="布尔型：boolean"><a href="#布尔型：boolean" class="headerlink" title="布尔型：boolean"></a>布尔型：boolean</h3><p>只允许取值true和false，无null。</p><p>不可以使用0或非0 的整数替代false和true，这点和C语言不同。</p><p>编译后使用java虚拟机中的int数据类型来代替：true用1表示，false用0表示。</p><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p>字符串类型：String , String不是基本数据类型，属于引用数据类型</p><h2 id="使用变量注意"><a href="#使用变量注意" class="headerlink" title="使用变量注意"></a>使用变量注意</h2><p>A.Java中每个变量必须先声明，后使用</p><p>B.使用变量名来访问这块区域的数据</p><p>C.变量的作用域：其定义所在的一对{ }内</p><p>D.变量只有在其作用域内才有效</p><p>E.同一个作用域内，不能定义重名的变量</p><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><p>A.语法：&lt;数据类型&gt; &lt;变量名称&gt;</p><p>例如：int var;</p><p>B.变量的赋值</p><p>语法：&lt;变量名称&gt; &#x3D; &lt;值&gt;</p><p>例如：var &#x3D; 10;</p><p>C.声明和赋值变量</p><p>语法：&lt;数据类型&gt; &lt;变量名&gt; &#x3D; &lt;初始化值&gt;</p><p>例如：int var &#x3D; 10;</p><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为：</p><p> <img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/27b11274ffd79db659683643d0b4f71b.png"></p><p>A.有多种类型的数据混合运算时，自动将所有数据转换成容量最大的类型，再进行计算。</p><p>B. byte,short,char之间不会相互转换，他们三者在计算时首先转换为int类型。</p><p>C. boolean类型不能与其它数据类型运算。</p><p>D.当把任何基本数据类型的值和字符串(String)进行连接运算时(+)，基本数据类型的值将自动转化为字符串(String)类型。</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/6e1abbe118542ffbf58749a624e8deed.png"></p><p> ‘a’为char，和后面的int 1 自动升级int值97，97 +1 &#x3D; 98 再升级为字符串</p><p> <img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/5c1c56fc02373c2d8cf48ede348966b0.png"></p><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符：()，但可能造成精度降低或溢出,格外要注意。</p><p>通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型。如：String a &#x3D; “43”; int i &#x3D; Integer.parseInt(a);</p><p>boolean类型不可以转换为其它的数据类型。</p><p>例子：byte b &#x3D; 3;</p><p>b &#x3D; (byte)(b+4); 因为b+4，所以b本应该转为int，强制转为byte。</p><h1 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h1><p>计算机以二进制补码的形式保存所有的整数。</p><p>二进制的整数有如下三种形式：</p><p>原码：直接将一个数值换成二进制数。最高位是符号位</p><p>负数的反码：是对原码按位取反，只是最高位（符号位）确定为1。</p><p>负数的补码：其反码加1。</p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/179340a832b9598d2647f5a9a945cca6.png"></p><p>注意：</p><p>（1）算术“与”，是他们的二进制对位相乘</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/b6173a8c4299bc0ac4c4ef3a4255a451.png"></p><p>十进制的60转为十六进制</p><p>第三行强制转char，就可以把i2-10（int） + ‘A’（char）输出char型的字符</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/97036da0445e779eee4093d4e43a3033.png"></p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/4364d6b2393b25cbb8f13607f76be3bc.png"></p><p>练习：表示三位数的各个位：</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/d701ed856ca0f8ab75265be767d04ed7.png"></p><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>+&#x3D;, -&#x3D;, *&#x3D;, &#x2F;&#x3D;, %&#x3D;</p><p>以+&#x3D;为例，格式都一样的:</p><p>x +&#x3D; 2； (不改变数据类型)</p><p>x &#x3D; x + 2; （x初始为short，输出的x应为int，所以编译错误，没有强行转换）</p><p>练习：</p><p>int n &#x3D; 10;</p><p>n +&#x3D; (n++) + (++n);</p><p>System.out.println(n); 答案：n &#x3D; 32；</p><p>解答：n &#x3D; n + (n++) + (++n)</p><p>每个n对应的值： 10 10 12</p><h2 id="比较运算符（关系运算符）"><a href="#比较运算符（关系运算符）" class="headerlink" title="比较运算符（关系运算符）"></a>比较运算符（关系运算符）</h2><p> <img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/2feb64c93276156a1d4d76a76dc11858.png"></p><p> <img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/15dea6b312bcf143fefe414eaf182f07.png"></p><p> 第七行是把true赋值给y，这个（y&#x3D;true）括号就为真</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>&amp;—逻辑与| —逻辑或！—逻辑非</p><p>&amp;&amp; —短路与|| —短路或^ —逻辑异或</p><p>开发中推荐 &amp;&amp; 和 ||</p><p>A.“&amp;”和“&amp;&amp;”的区别：</p><p>&amp;时，左边无论真假，右边都进行运算；</p><p>&amp;&amp;时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。</p><p>int n &#x3D; 10;</p><p>false &amp; (n++); n &#x3D; 11 true&amp; (n++); n &#x3D; 11</p><p>false &amp;&amp; (n++); n &#x3D; 10 true&amp;&amp; (n++); n &#x3D; 11</p><p>B.“|”和“||”的区别同理，||表示：当左边为真，右边不参与运算。</p><p>C.异或( ^ )与或( | )的不同之处是：当左右都为true时，结果为false。</p><p>理解：异或，追求的是“异”!</p><p>D.在Java中不可以写成3&lt;x&lt;6，应该写成x&gt;3 &amp; x&lt;6 。因为前面3&lt;x已经为布尔型数据，不能再和6去比较了。</p><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算是直接对整数的二进制进行的运算</p><p> <img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/31adb1eae51860922821e7ae1afd859d.png"></p><p> <img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/19ac3471509dba3505b8823a23201b3a.png"></p><p> <img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/6518e66a4d8449126432f613ccbea5f1.png"></p><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p> <img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/e8dc59a21791b53e9c35d00a21c9ebc9.png"></p><p> 表达式1和表达式2为同种类型，可以嵌套</p><p>三元运算符与if-else的联系与区别：</p><p>1）三元运算符可简化if-else语句,比if -else运行效率高。</p><p>2）三元运算符要求必须返回一个结果。</p><p>3）if后的代码块可有多个语句</p><p>练习：</p><p>A.两个数比大小</p><p>int n &#x3D; 10;</p><p>int m &#x3D; 20;</p><p>int out &#x3D; (m&gt;n) ? “m大” ：（(n &#x3D;&#x3D; m) ? “m和n一样大” ：“n大”）</p><p>B.三个数取最大</p><p>Int n &#x3D; 10;</p><p>int m &#x3D; 20;</p><p>int z &#x3D; 30;</p><p>int max &#x3D; (n&lt;m) ? ((m&lt;z) ? z : m) : ((n&gt;z) ? n : z)</p><h1 id="控制台输入"><a href="#控制台输入" class="headerlink" title="控制台输入"></a>控制台输入</h1><p> <img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/e1147b40591a9cc107f80be9e2578c3f.png"></p><p> 通过Scanner类来输入，如果是String，调用next（），其他类型数据就nextXxx（）。</p><p> <img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/e31ca3f0cc7045a7ef0d1a0e2aa39e89.png"></p><h1 id="程序流程控制"><a href="#程序流程控制" class="headerlink" title="程序流程控制"></a>程序流程控制</h1><p>流程控制语句是用来控制程序中各语句执行顺序的语句</p><h2 id="三种基本流程结构"><a href="#三种基本流程结构" class="headerlink" title="三种基本流程结构:"></a>三种基本流程结构:</h2><p>A.顺序结构</p><p>B.分支结构</p><p>根据条件，选择性地执行某段代码。</p><p>有if…else和switch-case两种分支语句。</p><p>C.循环结构</p><p>根据循环条件，重复性的执行某段代码。</p><p>有while、do…while、for三种循环语句。</p><p>注：JDK1.5提供了foreach循环，方便的遍历集合、数组元素。</p><p>循环语句的四个组成部分：</p><p>A.初始化部分(init_statement)</p><p>B.循环条件部分(test_exp)</p><p>C.循环体部分(body_statement)</p><p>D.迭代部分(alter_statement)</p><h2 id="if-else结构"><a href="#if-else结构" class="headerlink" title="if-else结构"></a>if-else结构</h2><p>注意：</p><p>当多个条件是“互斥”关系时，条件判断语句及执行语句间顺序无所谓</p><p>当多个条件是“包含”关系时，“小上大下 &#x2F; 子上父下”</p><h2 id="switch-case结构"><a href="#switch-case结构" class="headerlink" title="switch-case结构"></a>switch-case结构</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">switch</span><span class="token punctuation">(</span>表达式<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> 常量<span class="token number">1</span><span class="token operator">:</span>        语句<span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// break;</span>    <span class="token keyword">case</span> 常量<span class="token number">2</span><span class="token operator">:</span>        语句<span class="token number">2</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// break;</span>     … …    <span class="token keyword">case</span> 常量N<span class="token operator">:</span>        语句N<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// break;</span>    <span class="token keyword">default</span><span class="token operator">:</span>        语句<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// break;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>switch和if语句的对比：</p><p>（1）如果判断的具体数值不多，而且符合byte、short 、char、int、String、枚举等几</p><p>种类型。虽然两个语句都可以使用，建议使用swtich语句。因为效率稍高。</p><p>（2）其他情况：对区间判断，对结果为boolean类型判断，使用if，if的使用范围更广。</p><p>也就是说，使用switch-case的，都可以改写为if-else。反之不成立。</p><p>注意：</p><p>（1）switch(表达式)中表达式的值必须是下述几种类型之一：</p><p>byte，short，char，int，枚举(jdk 5.0)，String (jdk 7.0)；</p><p>（2）case子句中的值必须是常量，不能是变量名或不确定的表达式值；</p><p>（3）同一个switch语句，所有case子句中的常量值互不相同；</p><p>（4）break语句用来在执行完一个case分支后使程序跳出switch语句块；</p><p>如果没有break，程序会顺序执行到switch结尾</p><p>（5）default子句是可任选的。同时，位置也是灵活的。当没有匹配的case时，执行default</p><p>（6）多个case执行相同语句，可以考虑合并</p><p> <img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/3a91ccc7b58fb53e845fdb107744ddc4.png"></p><p>（7）编写程序：从键盘上输入2019年的“month”和“day”，要求通过程序输出输入的日期为2019年的第几天。</p><p>break不加的情况。</p><p>倒着写，把前面的结果累加。</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/96138c3f812a2d5cfb6d06167868f7a5.png"></p><p>每次加的是上个月的天数，最后加一下本月的天数。</p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span>①初始化部分<span class="token punctuation">;</span> ②循环条件部分<span class="token punctuation">;</span> ④迭代部分<span class="token punctuation">)</span>｛③循环体部分<span class="token punctuation">;</span>｝</code></pre><p>执行过程：<br>①-②-③-④-②-③-④-②-③-④-…..-②</p><p>说明：</p><p>②循环条件部分为boolean类型表达式，当值为false时，退出循环</p><p>①初始化部分可以声明多个变量，但必须是同一个类型，用逗号分隔</p><p>④可以有多个变量更新，用逗号分隔</p><p>题目：输入两个正整数m和n，求其最大公约数和最小公倍数。</p><p>比如：12和20的最大公约数是4，最小公倍数是60。</p><p>说明：break关键字的使用。比如公约数为1，2，4，找最大，可以倒着判断，从大到小取模，会先找到4，4ok就退出循环。</p><p> <img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/929c119a33c59f0de3aacd04c466ae99.png"></p><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>语法格式</p><pre class=" language-java"><code class="language-java">①初始化部分<span class="token keyword">while</span><span class="token punctuation">(</span>②循环条件部分<span class="token punctuation">)</span>｛    ③循环体部分<span class="token punctuation">;</span>    ④迭代部分<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>执行过程：</p><p>①-②-③-④-②-③-④-②-③-④-…-②</p><p>说明：</p><p>注意不要忘记声明④迭代部分。否则，循环将不能结束，变成死循环。</p><p>for循环和while循环可以相互转换</p><p> <img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/543e421b7d51a9b188265fc3f21c52d0.png"></p><p> 不确定循环次数，通过循环体内容判断，然后break跳出循环体。</p><p>Boolean isFlag &#x3D; true；</p><p>while（isFlag）{</p><p>…….</p><p>If(…….){</p><p>…..</p><p>Break;</p><p>}</p><p>}</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/31fa3ecfe1d4d863e8c85901b21d0216.png"></p><h2 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h2><p>语法格式</p><p>①初始化部分;</p><p>do{</p><p>③循环体部分</p><p>④迭代部分</p><p>}while(②循环条件部分);</p><p>执行过程：</p><p>①-③-④-②-③-④-②-③-④-…②</p><p>说明：</p><p>do-while循环至少执行一次循环体。</p><p>练习：100以内的所有质数</p><p> <img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/java/ecf81322038570559e05accbaa55309f.png"></p><p> 1.Math.sqrt()为开根号，如果可以被除开，或有一对数，一大一小，小的数&lt;开根号，极大提高速度。</p><p>2.break，发现有一个被除开，就不要继续运算了</p><h2 id="break、continue、return"><a href="#break、continue、return" class="headerlink" title="break、continue、return"></a>break、continue、return</h2><p>（1）break</p><p>break语句用于终止某个语句块的执行</p><p>{ ……</p><p>break;</p><p>……</p><p>}</p><p>break语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是</p><p>哪一层语句块</p><p>label1: { ……</p><p>label2: { ……</p><p>label3: { ……</p><p>break label2;</p><p>……</p><p>}</p><p>}</p><p>}</p><p>（2）continue</p><p>continue只能使用在循环结构中</p><p>continue语句用于跳过其所在循环语句块的一次执行，继续下一次循环</p><p>continue语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环</p><p>（3）return</p><p>并非专门用于结束循环的，它的功能是结束一个方法。</p><p>当一个方法执行到一个return语句时，这个方法将被结束。</p><p>与break和continue不同的是，return直接结束整个方法，不管return处于多少层循环之内</p><p>总结：</p><p>break只能用于switch语句和循环语句中。</p><p>continue 只能用于循环语句中。</p><p>二者功能类似，但continue是终止本次循环，break是终止本层循环。</p><p>break、continue之后不能有其他的语句，因为程序永远不会执行其后的语句。</p><p>标号语句必须紧接在循环的头部。标号语句不能用在非循环语句的前面。</p><p>很多语言都有goto语句，goto语句可以随意将控制转移到程序中的任意一条语句上，然后执行它。但使程序容易出错。Java中的break和continue是不同于goto的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java笔记 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记（一）语言概述</title>
      <link href="/2022/03/28/java1/"/>
      <url>/2022/03/28/java1/</url>
      
        <content type="html"><![CDATA[<h1 id="java语言的特点是什么？"><a href="#java语言的特点是什么？" class="headerlink" title="java语言的特点是什么？"></a>java语言的特点是什么？</h1><p>面向对象性：两个基本概念（要素）：类、对象；三大特性：封装、继承、多态<br>健壮性：吸收了C&#x2F;C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制<br>跨平台性：通过Java语言编写的应用程序在不同的系统平台上都可以运行。“Write once , Run Anywhere”</p><h1 id="软件开发"><a href="#软件开发" class="headerlink" title="软件开发"></a>软件开发</h1><p>软件，即一系列按照特定顺序组织的计算机数据和指令的集合。有系统软件和应用软件之分。</p><p>系统软件：windows、mac os、linux、android、ios…</p><p>应用软件：ppt、画图板、word…</p><h1 id="人机交互方式"><a href="#人机交互方式" class="headerlink" title="人机交互方式"></a>人机交互方式</h1><p>图形化界面(Graphical User Interface GUI)：这种方式简单直观</p><p>命令行方式(Command Line Interface CLI)：需要有一个控制台，输入特定的指令，让计算机完成一些操作。</p><p>Pascal之父Nicklaus Wirth：“Algorithms+Data Structures&#x3D;Programs”</p><p>应用程序 &#x3D; 算法 + 数据结构</p><h1 id="常用的DOS命令（cmd）"><a href="#常用的DOS命令（cmd）" class="headerlink" title="常用的DOS命令（cmd）"></a>常用的DOS命令（cmd）</h1><p>dir : 列出当前目录下的文件以及文件夹</p><p>md : 创建目录</p><p>rd : 删除目录</p><p>cd : 进入指定目录</p><p>cd.. : 退回到上一级目录</p><p>cd: 退回到根目录</p><p>del : 删除文件</p><p>exit : 退出dos 命令行</p><h1 id="Java优势"><a href="#Java优势" class="headerlink" title="Java优势"></a>Java优势</h1><p>A.纯粹的面向对象</p><p>B.舍弃了C语言中容易引起错误的指针</p><p>C.增加了垃圾回收器功能</p><h1 id="Java两种核心机制"><a href="#Java两种核心机制" class="headerlink" title="Java两种核心机制"></a>Java两种核心机制</h1><p>Java虚拟机（Java Virtal Machine），JVM</p><p>垃圾收集机制（Garbage Collection），也会出现内存泄漏、内存溢出事件。</p><h1 id="System-out-println-和System-out-print-什么区别呢？"><a href="#System-out-println-和System-out-print-什么区别呢？" class="headerlink" title="System.out.println()和System.out.print()什么区别呢？"></a>System.out.println()和System.out.print()什么区别呢？</h1><p>System.out.println();打印完后，会换行。</p><p>System.out.print();打印完后，不会换行。</p><p>\n(换行)，\t(制表符)</p><h1 id="一个”-java”源文件中是否可以包括多个类（不是内部类）？"><a href="#一个”-java”源文件中是否可以包括多个类（不是内部类）？" class="headerlink" title="一个”.java”源文件中是否可以包括多个类（不是内部类）？"></a>一个”.java”源文件中是否可以包括多个类（不是内部类）？</h1><p>答：可以。但最多只有一个类名声明为public，与文件名相同。</p><h1 id="文件名和类名"><a href="#文件名和类名" class="headerlink" title="文件名和类名"></a>文件名和类名</h1><p>Something类的文件名叫OtherThing.java</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Something</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> something_to_do<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Do something ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>这个很明显。</p><p>答案: 正确。从来没有人说过Java的class名字必须和其文件名相同。但public class的名字必须和文件名相同。</p><h1 id="配置环境变量为什么要设置path（设置path的目的是什么）？"><a href="#配置环境变量为什么要设置path（设置path的目的是什么）？" class="headerlink" title="配置环境变量为什么要设置path（设置path的目的是什么）？"></a>配置环境变量为什么要设置path（设置path的目的是什么）？</h1><p>目的是为了在控制台的任何文件路径下，都可以调用jdk指定目录下的所有指令。</p><h1 id="JDK-JRE和JVM，以及关系是什么？"><a href="#JDK-JRE和JVM，以及关系是什么？" class="headerlink" title="JDK,JRE和JVM，以及关系是什么？"></a>JDK,JRE和JVM，以及关系是什么？</h1><p>JDK: Java Development Kit Java 开发工具包</p><p>JRE: Java Runtime Environment Java运行环境</p><p>关系：</p><p>使用JDK的开发工具完成的Java程序，交给JRE运行。</p><p>JDK包含JRE，JRE包含JVM.</p><p>JDK &#x3D; JRE + 开发工具集（如javac编译工具）</p><p>JRE &#x3D; JVM + Java SE 标准类库</p><h1 id="终端／cmd运行程序格式？"><a href="#终端／cmd运行程序格式？" class="headerlink" title="终端／cmd运行程序格式？"></a>终端／cmd运行程序格式？</h1><p>编译：javac 源文件名.java （会生成类名.calss的文件，称为字节码文件）</p><p>运行：java 类名 （不要加后缀.class）</p><h1 id="程序的入口"><a href="#程序的入口" class="headerlink" title="程序的入口"></a>程序的入口</h1><p>main()方法</p><p>Public static void main(String[] args)</p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>分为单行注释、多行注释、文档注释（java特有）</p><p>单行注释、多行注释——对程序进行说明，增加可读性，不参与编译，.class文件不包含。</p><p>文档注释——可以被jdk提供的工具javadoc解析，生成一套以网页文件形式的说明文档。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java笔记 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="/2022/02/20/git/"/>
      <url>/2022/02/20/git/</url>
      
        <content type="html"><![CDATA[<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><ul><li><h2 id="初始化本地库"><a href="#初始化本地库" class="headerlink" title="初始化本地库"></a>初始化本地库</h2></li></ul><pre class=" language-Bash"><code class="language-Bash">git init</code></pre><ul><li><h2 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h2></li></ul><pre class=" language-Bash"><code class="language-Bash">git status</code></pre><h1 id="推"><a href="#推" class="headerlink" title="推"></a>推</h1><ul><li><h2 id="添加到暂缓区"><a href="#添加到暂缓区" class="headerlink" title="添加到暂缓区"></a>添加到暂缓区</h2></li></ul><pre class=" language-Bash"><code class="language-Bash">git add .</code></pre><ul><li><h2 id="提交至本地库"><a href="#提交至本地库" class="headerlink" title="提交至本地库"></a>提交至本地库</h2></li></ul><pre class=" language-Bash"><code class="language-Bash">git commit -m '提交信息'</code></pre><ul><li><h2 id="推到远程仓库"><a href="#推到远程仓库" class="headerlink" title="推到远程仓库"></a>推到远程仓库</h2></li></ul><pre class=" language-Bash"><code class="language-Bash">git push</code></pre><h1 id="拉"><a href="#拉" class="headerlink" title="拉"></a>拉</h1><ul><li><h2 id="下拉并与本地合并"><a href="#下拉并与本地合并" class="headerlink" title="下拉并与本地合并"></a>下拉并与本地合并</h2></li></ul><pre class=" language-Bash"><code class="language-Bash">git pull</code></pre><ul><li><h2 id="如未知关联的仓库"><a href="#如未知关联的仓库" class="headerlink" title="如未知关联的仓库"></a>如未知关联的仓库</h2></li></ul><pre class=" language-Bash"><code class="language-Bash">git pull 仓库名 分支名</code></pre><h1 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h1><p>冲突产生的表现：后面状态为MERGING</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/img/57e02acec7b8b8e0f654934c039e9bb3.png"></p><ul><li>查看状态</li></ul><pre class=" language-Bash"><code class="language-Bash">git status</code></pre><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/img/fd0174cbfce59addaf90bb936b2fd5eb.png"></p><p>解决合并问题：</p><p>1）编辑有冲突的文件，删除特殊符号，决定要使用的内容</p><p>特殊符号：<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 当前分支的代码======= 合并过来的代码&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code></p><p>2）添加到暂存区</p><pre class=" language-Bash"><code class="language-Bash">git add XXXX（文件名） 或 git add .</code></pre><p>3）查看解决状态，全部绿色（modified修改过）</p><pre class=" language-Bash"><code class="language-Bash">git status</code></pre><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/img/552a8ad42e123ea5e10a70e027dba00e.png"></p><p>4）执行提交（注意：此时使用git commit 命令时不能带文件名）</p><pre class=" language-Bash"><code class="language-Bash">git commit -m ' '</code></pre><p>发现后面MERGING 消失，变为正常</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/img/52b7fdf6e1ddb65b57e28ce92189a6ec.png"></p><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><ul><li><h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2></li></ul><pre class=" language-Bash"><code class="language-Bash">git branch 分支名</code></pre><ul><li><h2 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h2></li></ul><pre class=" language-Bash"><code class="language-Bash">git branch -v</code></pre><ul><li><h2 id="切换分支（切换分支的本质就是移动HEAD-指针）"><a href="#切换分支（切换分支的本质就是移动HEAD-指针）" class="headerlink" title="切换分支（切换分支的本质就是移动HEAD 指针）"></a>切换分支（切换分支的本质就是移动HEAD 指针）</h2></li></ul><pre class=" language-Bash"><code class="language-Bash">git checkout 分支名</code></pre><ul><li><h2 id="指定分支合并到当前分支"><a href="#指定分支合并到当前分支" class="headerlink" title="指定分支合并到当前分支"></a>指定分支合并到当前分支</h2></li></ul><pre class=" language-Bash"><code class="language-Bash">git merge 分支名</code></pre><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/img/b2ac0f41fb9fa4621cdc29209adcd2bd.png"></p><h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><ul><li><h2 id="查看历史记录"><a href="#查看历史记录" class="headerlink" title="查看历史记录"></a>查看历史记录</h2></li></ul><pre class=" language-Bash"><code class="language-Bash">git reflog</code></pre><ul><li><h2 id="版本穿梭"><a href="#版本穿梭" class="headerlink" title="版本穿梭"></a>版本穿梭</h2></li></ul><pre class=" language-Bash"><code class="language-Bash">git reset --hard 版本号</code></pre><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/img/ed7d30769d8dcd9b6b10fc6b00e47bca.png"></p><h1 id="vim相关操作"><a href="#vim相关操作" class="headerlink" title="vim相关操作"></a>vim相关操作</h1><p>主要用到：</p><p>“a”进入编辑</p><p>“Esc”退出编辑</p><p>“shift + :”开始编辑命令</p><p>“:wq”保存</p><p>“:q”退出vim</p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/img/5320d98f969a0ceb31459fc7709aee67.png"></p><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/img/4be93568a0522540764bf5a8f66b6ae7.png"></p><h1 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h1><pre><code>git remote add 仓库名（本地自拟） git@xxx.github.com:用户名/仓库.git</code></pre><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/img/83939ba5a3ff4ac70ac4de6a49408d18.png"><br>如果是推到新的仓库，出现以下情况，</p><p>则是：远程仓库中有着本地仓库没有的文件，由于远程仓库和本地仓库没有共同的commit，需要先pull<br><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/img/a7b47c89caeca75e6a55961785655fa6.png"><br>拒绝合并不相关的历史<br><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/img/bff674eb63d3e263de3d7c57612ec168.png"><br>所以需要：</p><pre class=" language-Bash"><code class="language-Bash">git pull origin master --allow-unrelated-histories</code></pre><p><img src="https://raw.githubusercontent.com/luan-bx/PicGO/main/img/6afab4a5a34889f623d1dfdb69f11007.png"><br>完成！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown</title>
      <link href="/2022/02/16/markdown/"/>
      <url>/2022/02/16/markdown/</url>
      
        <content type="html"><![CDATA[<p>Markdown 是一种轻量级标记语言，它用简洁的语法代替排版，使我们专心于码字。它的目标是实现易读易写，成为一种适用于网络的书写语言。同时，Markdown支持嵌入html标签。<br>注意：符号后面必须跟至少1个空格才有效！</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><pre class=" language-markdown"><code class="language-markdown"><span class="token title important"><span class="token punctuation">#</span> 一级标题</span><span class="token title important"><span class="token punctuation">##</span> 二级标题</span><span class="token title important"><span class="token punctuation">###</span> 三级标题</span></code></pre><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ul><li>Red</li><li>Green</li><li>Blue</li></ul><pre class=" language-markdown"><code class="language-markdown"><span class="token list punctuation">-</span> Red<span class="token list punctuation">-</span> Green<span class="token list punctuation">-</span> Blue</code></pre><h2 id="标号"><a href="#标号" class="headerlink" title="标号"></a>标号</h2><ol><li>Red</li><li>Green</li><li>Blue</li></ol><pre class=" language-markdown"><code class="language-markdown"><span class="token list punctuation">1.</span> Red<span class="token list punctuation">2.</span> Green<span class="token list punctuation">3.</span> Blue</code></pre><h2 id="打开本地服务器"><a href="#打开本地服务器" class="headerlink" title="打开本地服务器"></a>打开本地服务器</h2><blockquote><p>一级引用</p><blockquote><p>二级引用</p><blockquote><p>三级引用</p></blockquote></blockquote></blockquote><blockquote><p>引用 ，注意：在<code>&gt;</code>后面有 1 个空格</p><pre><code>这是引用的代码块形式    //在`&gt;`后面有 5 个空格</code></pre></blockquote><blockquote><p>代码例子：<br>    protected void onCreate(Bundle savedInstanceState) {<br>        super.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>    }</p></blockquote><pre class=" language-markdown"><code class="language-markdown"><span class="token blockquote punctuation">></span> 一级引用<span class="token blockquote punctuation">> ></span> 二级引用<span class="token blockquote punctuation">> > ></span> 三级引用</code></pre><pre class=" language-markdown"><code class="language-markdown"><span class="token blockquote punctuation">></span> 引用 ，注意：在<span class="token code keyword">`>`</span>后面有 1 个空格<span class="token blockquote punctuation">></span> <span class="token blockquote punctuation">></span><span class="token code keyword">     这是引用的代码块形式    //在`>`后面有 5 个空格</span></code></pre><pre class=" language-markdown"><code class="language-markdown"><span class="token blockquote punctuation">></span> 代码例子：<span class="token code keyword">    protected void onCreate(Bundle savedInstanceState) &amp;#123;</span><span class="token code keyword">        super.onCreate(savedInstanceState);</span><span class="token code keyword">        setContentView(R.layout.activity_main);</span><span class="token code keyword">    &amp;#125;</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo</title>
      <link href="/2022/02/15/hexo/"/>
      <url>/2022/02/15/hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h2><pre class=" language-bash"><code class="language-bash">hexo clean</code></pre><h2 id="构建静态文件"><a href="#构建静态文件" class="headerlink" title="构建静态文件"></a>构建静态文件</h2><pre class=" language-bash"><code class="language-bash">hexo g</code></pre><h2 id="上传至仓库"><a href="#上传至仓库" class="headerlink" title="上传至仓库"></a>上传至仓库</h2><pre class=" language-bash"><code class="language-bash">hexo d</code></pre><h2 id="打开本地服务器"><a href="#打开本地服务器" class="headerlink" title="打开本地服务器"></a>打开本地服务器</h2><pre class=" language-bash"><code class="language-bash">hexo server //可进行本地调试</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
