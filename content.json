{"meta":{"title":"MyBlog","subtitle":"这里是我所热爱的世界！","description":"记录成长历程","author":"Luan-bx","url":"https://luan-bx.github.io","root":"/"},"pages":[{"title":"about","date":"2023-02-19T08:01:01.000Z","updated":"2023-02-20T09:42:42.477Z","comments":true,"path":"about/index.html","permalink":"https://luan-bx.github.io/about/index.html","excerpt":"","text":"profile: avatar: &#x2F;medias&#x2F;2.jpg career: 本人很好 introduction: 好好学习，热爱生活!"},{"title":"categories","date":"2023-02-19T07:59:39.000Z","updated":"2023-02-19T07:59:39.435Z","comments":true,"path":"categories/index.html","permalink":"https://luan-bx.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2023-02-19T08:03:42.000Z","updated":"2023-02-19T08:03:42.387Z","comments":true,"path":"friends/index.html","permalink":"https://luan-bx.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-02-19T08:00:24.000Z","updated":"2023-02-20T13:03:47.067Z","comments":true,"path":"tags/index.html","permalink":"https://luan-bx.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java笔记（三）数组","slug":"java3","date":"2022-04-12T11:15:42.000Z","updated":"2023-03-06T13:21:51.360Z","comments":true,"path":"2022/04/12/java3/","link":"","permalink":"https://luan-bx.github.io/2022/04/12/java3/","excerpt":"","text":"二维数组 打印二维数组的外层数组，其实相当于打印一个一维数组，只会打印出这个数组存放的地址。其中“[I@15db…”的‘[’表示一维，‘I’ 表示int型。 倒数第二行为null，即使二维数组是double，但里面的元素数组还未定义类型，而数组的为初始化为null。报错是因为未初始化就取值会报错。 数组的赋值与复制（1）数组的赋值： 慎用array1 &#x3D; array2 来赋值，虽然把array2 赋值给array1，但修改array1同样修改的是array2，只是将array2的地址给了array1，他俩共用一个数组。 （2）数组的复制： 开辟一个新的堆，存放新数组 array1 = new int[array2.length]; for(int i = 0;i &lt; array1.length;i++)&amp;#123; array1[i] = array2[i]; &amp;#125; 打印数组将数组转成String：Arrays.toString() System.out.println(“等级” + Arrays.toString(abcd)); 数组算法（1）衡量排序算法的优劣 1.时间复杂度：分析关键字的比较次数和记录的移动次数 2.空间复杂度：分析排序算法中需要多少辅助内存 3.稳定性：若两个记录A和B的关键字值相等，但排序后A、B的先后次序保持不变，则称这种排序算法是稳定的。 （2）排序算法分类 内部排序和外部排序。 内部排序：整个排序过程不需要借助于外部存储器（如磁盘等），所有排序操作都在内存中完成。 外部排序：参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助于外部存储器（如磁盘）。外部排序最常见的是多路归并排序。可以认为外部排序是由多次内部排序组成。 （3）十大内部排序算法 a选择排序 直接选择排序、堆排序 b交换排序 冒泡排序、快速排序 c插入排序 直接插入排序、折半插入排序、Shell排序 d归并排序 e桶式排序 f基数排序 (3)冒泡排序 介绍： 冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。 排序思想： 比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较为止。 (4)快速排序 介绍： 快速排序通常明显比同为O(nlogn)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。 快速排序（Quick Sort）由图灵奖获得者Tony Hoare发明，被列为20世纪十大算法之一，是迄今为止所有内排序算法中速度最快的一种。冒泡排序的升级版，交换排序的一种。快速排序的时间复杂度为O(nlog(n))。 排序思想： 从数列中挑出一个元素，称为”基准”（pivot）， 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。","categories":[],"tags":[{"name":"Java笔记","slug":"Java笔记","permalink":"https://luan-bx.github.io/tags/Java%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/tags/Java/"}]},{"title":"Java笔记（二）基本语法","slug":"java2","date":"2022-04-06T08:52:19.000Z","updated":"2023-03-06T13:20:40.666Z","comments":true,"path":"2022/04/06/java2/","link":"","permalink":"https://luan-bx.github.io/2022/04/06/java2/","excerpt":"","text":"关键字(keyword)定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词） 特点：关键字中所有字母都为小写 保留字(reserved word)现有Java版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字： goto 、const 标识符(Identifier)Java 对各种变量、方法和类等要素命名时使用的字符序列称为标识符 技巧：凡是自己可以起名字的地方都叫标识符。 定义合法标识符规则：A.由26个英文字母大小写，0-9 ，_或$ 组成 B.数字不可以开头。 C.不可以使用关键字和保留字，但能包含关键字和保留字。 D.Java中严格区分大小写，长度无限制。 E.标识符不能包含空格。 Java中的名称命名规范：包名：多单词组成时所有字母都小写：xxxyyyzzz 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个开始首字母大写：xxxYyyZzz 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ 注意1：在起名字时，为了提高阅读性，要尽量有意义，“见名知意”。 注意2：java采用unicode字符集，因此标识符也可以使用汉字声明，但是不建议使用。 变量变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值 变量的分类按数据类型 按声明的位置的不同 说明数值型（1）整数类型：byte、short、int、long 整型常量默认为int 型，声明long型常量须后加‘l’或‘L’ ，否则默认为int。 Java程序中变量通常声明为int型，除非不足以表示较大的数，才使用long。 （2）浮点类型：float、double double:双精度，精度是float的两倍。通常采用此类型。 浮点型常量默认为double型，声明float型常量，须后加‘f’或‘F’。否则默认为double。 如下图：因为b1已经为int，f1已经为double。 字符型：char用来表示通常意义上“字符”(2字节) ，Java中的所有字符都使用Unicode编码， 故一个字符可以存储一个字母，一个汉字，或其他书面语的一个字符。 字符型变量的三种表现形式： （1）字符常量是用单引号(‘ ’)括起来的单个字符。 例如：char c1 &#x3D; ‘a’; char c2 &#x3D; ‘中’; char c3 &#x3D; ‘9’; （2）Java中还允许使用转义字符‘\\’来将其后的字符转变为特殊字符型常量。 例如：char c3 &#x3D; ‘\\n’; &#x2F;&#x2F; ‘\\n’表示换行符 （3）直接用Unicode值表示字符型常量：‘\\uXXXX’。XXXX代表一个十六进制整数。 例如：\\u000a 表示\\n。 char类型是可以进行运算的。因为它都对应有Unicode码。 Char c1 &#x3D; 97; 和char c2 &#x3D; ‘97’; 是不一样的，c1输出的是Unicode码，c2输出的是符号对应的Unicode码。 布尔型：boolean只允许取值true和false，无null。 不可以使用0或非0 的整数替代false和true，这点和C语言不同。 编译后使用java虚拟机中的int数据类型来代替：true用1表示，false用0表示。 引用数据类型字符串类型：String , String不是基本数据类型，属于引用数据类型 使用变量注意A.Java中每个变量必须先声明，后使用 B.使用变量名来访问这块区域的数据 C.变量的作用域：其定义所在的一对{ }内 D.变量只有在其作用域内才有效 E.同一个作用域内，不能定义重名的变量 声明变量A.语法：&lt;数据类型&gt; &lt;变量名称&gt; 例如：int var; B.变量的赋值 语法：&lt;变量名称&gt; &#x3D; &lt;值&gt; 例如：var &#x3D; 10; C.声明和赋值变量 语法：&lt;数据类型&gt; &lt;变量名&gt; &#x3D; &lt;初始化值&gt; 例如：int var &#x3D; 10; 数据类型转换容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为： A.有多种类型的数据混合运算时，自动将所有数据转换成容量最大的类型，再进行计算。 B. byte,short,char之间不会相互转换，他们三者在计算时首先转换为int类型。 C. boolean类型不能与其它数据类型运算。 D.当把任何基本数据类型的值和字符串(String)进行连接运算时(+)，基本数据类型的值将自动转化为字符串(String)类型。 ‘a’为char，和后面的int 1 自动升级int值97，97 +1 &#x3D; 98 再升级为字符串 强制类型转换自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符：()，但可能造成精度降低或溢出,格外要注意。 通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型。如：String a &#x3D; “43”; int i &#x3D; Integer.parseInt(a); boolean类型不可以转换为其它的数据类型。 例子：byte b &#x3D; 3; b &#x3D; (byte)(b+4); 因为b+4，所以b本应该转为int，强制转为byte。 二进制计算机以二进制补码的形式保存所有的整数。 二进制的整数有如下三种形式： 原码：直接将一个数值换成二进制数。最高位是符号位 负数的反码：是对原码按位取反，只是最高位（符号位）确定为1。 负数的补码：其反码加1。 运算符算术运算符 注意： （1）算术“与”，是他们的二进制对位相乘 十进制的60转为十六进制 第三行强制转char，就可以把i2-10（int） + ‘A’（char）输出char型的字符 练习：表示三位数的各个位： 赋值运算符+&#x3D;, -&#x3D;, *&#x3D;, &#x2F;&#x3D;, %&#x3D; 以+&#x3D;为例，格式都一样的: x +&#x3D; 2； (不改变数据类型) x &#x3D; x + 2; （x初始为short，输出的x应为int，所以编译错误，没有强行转换） 练习： int n &#x3D; 10; n +&#x3D; (n++) + (++n); System.out.println(n); 答案：n &#x3D; 32； 解答：n &#x3D; n + (n++) + (++n) 每个n对应的值： 10 10 12 比较运算符（关系运算符） 第七行是把true赋值给y，这个（y&#x3D;true）括号就为真 逻辑运算符&amp;—逻辑与| —逻辑或！—逻辑非 &amp;&amp; —短路与|| —短路或^ —逻辑异或 开发中推荐 &amp;&amp; 和 || A.“&amp;”和“&amp;&amp;”的区别： &amp;时，左边无论真假，右边都进行运算； &amp;&amp;时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。 int n &#x3D; 10; false &amp; (n++); n &#x3D; 11 true&amp; (n++); n &#x3D; 11 false &amp;&amp; (n++); n &#x3D; 10 true&amp;&amp; (n++); n &#x3D; 11 B.“|”和“||”的区别同理，||表示：当左边为真，右边不参与运算。 C.异或( ^ )与或( | )的不同之处是：当左右都为true时，结果为false。 理解：异或，追求的是“异”! D.在Java中不可以写成3&lt;x&lt;6，应该写成x&gt;3 &amp; x&lt;6 。因为前面3&lt;x已经为布尔型数据，不能再和6去比较了。 位运算符位运算是直接对整数的二进制进行的运算 三元运算符 表达式1和表达式2为同种类型，可以嵌套 三元运算符与if-else的联系与区别： 1）三元运算符可简化if-else语句,比if -else运行效率高。 2）三元运算符要求必须返回一个结果。 3）if后的代码块可有多个语句 练习： A.两个数比大小 int n &#x3D; 10; int m &#x3D; 20; int out &#x3D; (m&gt;n) ? “m大” ：（(n &#x3D;&#x3D; m) ? “m和n一样大” ：“n大”） B.三个数取最大 Int n &#x3D; 10; int m &#x3D; 20; int z &#x3D; 30; int max &#x3D; (n&lt;m) ? ((m&lt;z) ? z : m) : ((n&gt;z) ? n : z) 控制台输入 通过Scanner类来输入，如果是String，调用next（），其他类型数据就nextXxx（）。 程序流程控制流程控制语句是用来控制程序中各语句执行顺序的语句 三种基本流程结构:A.顺序结构 B.分支结构 根据条件，选择性地执行某段代码。 有if…else和switch-case两种分支语句。 C.循环结构 根据循环条件，重复性的执行某段代码。 有while、do…while、for三种循环语句。 注：JDK1.5提供了foreach循环，方便的遍历集合、数组元素。 循环语句的四个组成部分： A.初始化部分(init_statement) B.循环条件部分(test_exp) C.循环体部分(body_statement) D.迭代部分(alter_statement) if-else结构注意： 当多个条件是“互斥”关系时，条件判断语句及执行语句间顺序无所谓 当多个条件是“包含”关系时，“小上大下 &#x2F; 子上父下” switch-case结构switch(表达式) &amp;#123; case 常量1: 语句1; // break; case 常量2: 语句2; // break; … … case 常量N: 语句N; // break; default: 语句; // break; &amp;#125; switch和if语句的对比： （1）如果判断的具体数值不多，而且符合byte、short 、char、int、String、枚举等几 种类型。虽然两个语句都可以使用，建议使用swtich语句。因为效率稍高。 （2）其他情况：对区间判断，对结果为boolean类型判断，使用if，if的使用范围更广。 也就是说，使用switch-case的，都可以改写为if-else。反之不成立。 注意： （1）switch(表达式)中表达式的值必须是下述几种类型之一： byte，short，char，int，枚举(jdk 5.0)，String (jdk 7.0)； （2）case子句中的值必须是常量，不能是变量名或不确定的表达式值； （3）同一个switch语句，所有case子句中的常量值互不相同； （4）break语句用来在执行完一个case分支后使程序跳出switch语句块； 如果没有break，程序会顺序执行到switch结尾 （5）default子句是可任选的。同时，位置也是灵活的。当没有匹配的case时，执行default （6）多个case执行相同语句，可以考虑合并 （7）编写程序：从键盘上输入2019年的“month”和“day”，要求通过程序输出输入的日期为2019年的第几天。 break不加的情况。 倒着写，把前面的结果累加。 每次加的是上个月的天数，最后加一下本月的天数。 for循环for (①初始化部分; ②循环条件部分; ④迭代部分)｛ ③循环体部分; ｝ 执行过程：①-②-③-④-②-③-④-②-③-④-…..-② 说明： ②循环条件部分为boolean类型表达式，当值为false时，退出循环 ①初始化部分可以声明多个变量，但必须是同一个类型，用逗号分隔 ④可以有多个变量更新，用逗号分隔 题目：输入两个正整数m和n，求其最大公约数和最小公倍数。 比如：12和20的最大公约数是4，最小公倍数是60。 说明：break关键字的使用。比如公约数为1，2，4，找最大，可以倒着判断，从大到小取模，会先找到4，4ok就退出循环。 while循环语法格式 ①初始化部分 while(②循环条件部分)｛ ③循环体部分; ④迭代部分; &amp;#125; 执行过程： ①-②-③-④-②-③-④-②-③-④-…-② 说明： 注意不要忘记声明④迭代部分。否则，循环将不能结束，变成死循环。 for循环和while循环可以相互转换 不确定循环次数，通过循环体内容判断，然后break跳出循环体。 Boolean isFlag &#x3D; true； while（isFlag）{ ……. If(…….){ ….. Break; } } do-while循环语法格式 ①初始化部分; do{ ③循环体部分 ④迭代部分 }while(②循环条件部分); 执行过程： ①-③-④-②-③-④-②-③-④-…② 说明： do-while循环至少执行一次循环体。 练习：100以内的所有质数 1.Math.sqrt()为开根号，如果可以被除开，或有一对数，一大一小，小的数&lt;开根号，极大提高速度。 2.break，发现有一个被除开，就不要继续运算了 break、continue、return（1）break break语句用于终止某个语句块的执行 { …… break; …… } break语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是 哪一层语句块 label1: { …… label2: { …… label3: { …… break label2; …… } } } （2）continue continue只能使用在循环结构中 continue语句用于跳过其所在循环语句块的一次执行，继续下一次循环 continue语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环 （3）return 并非专门用于结束循环的，它的功能是结束一个方法。 当一个方法执行到一个return语句时，这个方法将被结束。 与break和continue不同的是，return直接结束整个方法，不管return处于多少层循环之内 总结： break只能用于switch语句和循环语句中。 continue 只能用于循环语句中。 二者功能类似，但continue是终止本次循环，break是终止本层循环。 break、continue之后不能有其他的语句，因为程序永远不会执行其后的语句。 标号语句必须紧接在循环的头部。标号语句不能用在非循环语句的前面。 很多语言都有goto语句，goto语句可以随意将控制转移到程序中的任意一条语句上，然后执行它。但使程序容易出错。Java中的break和continue是不同于goto的。","categories":[],"tags":[{"name":"Java笔记","slug":"Java笔记","permalink":"https://luan-bx.github.io/tags/Java%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/tags/Java/"}]},{"title":"Java笔记（一）语言概述","slug":"java1","date":"2022-03-28T04:56:44.000Z","updated":"2023-03-06T13:13:48.227Z","comments":true,"path":"2022/03/28/java1/","link":"","permalink":"https://luan-bx.github.io/2022/03/28/java1/","excerpt":"","text":"java语言的特点是什么？面向对象性：两个基本概念（要素）：类、对象；三大特性：封装、继承、多态健壮性：吸收了C&#x2F;C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制跨平台性：通过Java语言编写的应用程序在不同的系统平台上都可以运行。“Write once , Run Anywhere” 软件开发软件，即一系列按照特定顺序组织的计算机数据和指令的集合。有系统软件和应用软件之分。 系统软件：windows、mac os、linux、android、ios… 应用软件：ppt、画图板、word… 人机交互方式图形化界面(Graphical User Interface GUI)：这种方式简单直观 命令行方式(Command Line Interface CLI)：需要有一个控制台，输入特定的指令，让计算机完成一些操作。 Pascal之父Nicklaus Wirth：“Algorithms+Data Structures&#x3D;Programs” 应用程序 &#x3D; 算法 + 数据结构 常用的DOS命令（cmd）dir : 列出当前目录下的文件以及文件夹 md : 创建目录 rd : 删除目录 cd : 进入指定目录 cd.. : 退回到上一级目录 cd: 退回到根目录 del : 删除文件 exit : 退出dos 命令行 Java优势A.纯粹的面向对象 B.舍弃了C语言中容易引起错误的指针 C.增加了垃圾回收器功能 Java两种核心机制Java虚拟机（Java Virtal Machine），JVM 垃圾收集机制（Garbage Collection），也会出现内存泄漏、内存溢出事件。 System.out.println()和System.out.print()什么区别呢？System.out.println();打印完后，会换行。 System.out.print();打印完后，不会换行。 \\n(换行)，\\t(制表符) 一个”.java”源文件中是否可以包括多个类（不是内部类）？答：可以。但最多只有一个类名声明为public，与文件名相同。 文件名和类名Something类的文件名叫OtherThing.java class Something&amp;#123; public static void main(String[] something_to_do)&amp;#123; System.out.println(\"Do something ...\"); &amp;#125; &amp;#125; 这个很明显。 答案: 正确。从来没有人说过Java的class名字必须和其文件名相同。但public class的名字必须和文件名相同。 配置环境变量为什么要设置path（设置path的目的是什么）？目的是为了在控制台的任何文件路径下，都可以调用jdk指定目录下的所有指令。 JDK,JRE和JVM，以及关系是什么？JDK: Java Development Kit Java 开发工具包 JRE: Java Runtime Environment Java运行环境 关系： 使用JDK的开发工具完成的Java程序，交给JRE运行。 JDK包含JRE，JRE包含JVM. JDK &#x3D; JRE + 开发工具集（如javac编译工具） JRE &#x3D; JVM + Java SE 标准类库 终端／cmd运行程序格式？编译：javac 源文件名.java （会生成类名.calss的文件，称为字节码文件） 运行：java 类名 （不要加后缀.class） 程序的入口main()方法 Public static void main(String[] args) 注释分为单行注释、多行注释、文档注释（java特有） 单行注释、多行注释——对程序进行说明，增加可读性，不参与编译，.class文件不包含。 文档注释——可以被jdk提供的工具javadoc解析，生成一套以网页文件形式的说明文档。","categories":[],"tags":[{"name":"Java笔记","slug":"Java笔记","permalink":"https://luan-bx.github.io/tags/Java%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/tags/Java/"}]},{"title":"git常用命令","slug":"git","date":"2022-02-20T11:38:38.000Z","updated":"2023-03-06T09:31:07.836Z","comments":true,"path":"2022/02/20/git/","link":"","permalink":"https://luan-bx.github.io/2022/02/20/git/","excerpt":"","text":"基本操作 初始化本地库 git init 查看状态 git status 推 添加到暂缓区 git add . 提交至本地库 git commit -m '提交信息' 推到远程仓库 git push 拉 下拉并与本地合并 git pull 如未知关联的仓库 git pull 仓库名 分支名 冲突冲突产生的表现：后面状态为MERGING 查看状态 git status 解决合并问题： 1）编辑有冲突的文件，删除特殊符号，决定要使用的内容 特殊符号：&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 当前分支的代码======= 合并过来的代码&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2）添加到暂存区 git add XXXX（文件名） 或 git add . 3）查看解决状态，全部绿色（modified修改过） git status 4）执行提交（注意：此时使用git commit 命令时不能带文件名） git commit -m ' ' 发现后面MERGING 消失，变为正常 分支 创建分支 git branch 分支名 查看分支 git branch -v 切换分支（切换分支的本质就是移动HEAD 指针） git checkout 分支名 指定分支合并到当前分支 git merge 分支名 版本 查看历史记录 git reflog 版本穿梭 git reset --hard 版本号 vim相关操作主要用到： “a”进入编辑 “Esc”退出编辑 “shift + :”开始编辑命令 “:wq”保存 “:q”退出vim 添加远程仓库git remote add 仓库名（本地自拟） git@xxx.github.com:用户名/仓库.git 如果是推到新的仓库，出现以下情况， 则是：远程仓库中有着本地仓库没有的文件，由于远程仓库和本地仓库没有共同的commit，需要先pull拒绝合并不相关的历史所以需要： git pull origin master --allow-unrelated-histories 完成！","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://luan-bx.github.io/tags/Git/"}]},{"title":"Markdown","slug":"Markdown","date":"2022-02-16T14:06:12.000Z","updated":"2023-03-06T09:31:00.312Z","comments":true,"path":"2022/02/16/markdown/","link":"","permalink":"https://luan-bx.github.io/2022/02/16/markdown/","excerpt":"","text":"Markdown 是一种轻量级标记语言，它用简洁的语法代替排版，使我们专心于码字。它的目标是实现易读易写，成为一种适用于网络的书写语言。同时，Markdown支持嵌入html标签。注意：符号后面必须跟至少1个空格才有效！ 常用命令标题# 一级标题 ## 二级标题 ### 三级标题 列表 Red Green Blue - Red - Green - Blue 标号 Red Green Blue 1. Red 2. Green 3. Blue 打开本地服务器 一级引用 二级引用 三级引用 引用 ，注意：在&gt;后面有 1 个空格 这是引用的代码块形式 //在`&gt;`后面有 5 个空格 代码例子： protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } > 一级引用 > > 二级引用 > > > 三级引用 > 引用 ，注意：在`>`后面有 1 个空格 > > 这是引用的代码块形式 //在`>`后面有 5 个空格 > 代码例子： protected void onCreate(Bundle savedInstanceState) &amp;#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &amp;#125;","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://luan-bx.github.io/tags/Markdown/"}]},{"title":"Hexo","slug":"hexo","date":"2022-02-15T07:21:33.000Z","updated":"2023-03-06T09:31:04.616Z","comments":true,"path":"2022/02/15/hexo/","link":"","permalink":"https://luan-bx.github.io/2022/02/15/hexo/","excerpt":"","text":"常用命令清理hexo clean 构建静态文件hexo g 上传至仓库hexo d 打开本地服务器hexo server //可进行本地调试","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://luan-bx.github.io/tags/Hexo/"}]}],"categories":[],"tags":[{"name":"Java笔记","slug":"Java笔记","permalink":"https://luan-bx.github.io/tags/Java%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/tags/Java/"},{"name":"Git","slug":"Git","permalink":"https://luan-bx.github.io/tags/Git/"},{"name":"Markdown","slug":"Markdown","permalink":"https://luan-bx.github.io/tags/Markdown/"},{"name":"Hexo","slug":"Hexo","permalink":"https://luan-bx.github.io/tags/Hexo/"}]}