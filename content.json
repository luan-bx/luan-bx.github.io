{"meta":{"title":"MyBlog","subtitle":"这里是我所热爱的世界！","description":"记录成长历程","author":"Luan-bx","url":"https://luan-bx.github.io","root":"/"},"pages":[{"title":"about","date":"2023-02-19T08:01:01.000Z","updated":"2023-02-20T09:42:42.477Z","comments":true,"path":"about/index.html","permalink":"https://luan-bx.github.io/about/index.html","excerpt":"","text":"profile: avatar: &#x2F;medias&#x2F;2.jpg career: 本人很好 introduction: 好好学习，热爱生活!"},{"title":"categories","date":"2023-02-19T07:59:39.000Z","updated":"2023-03-08T06:58:11.061Z","comments":true,"path":"categories/index.html","permalink":"https://luan-bx.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-02-19T08:00:24.000Z","updated":"2023-02-20T13:03:47.067Z","comments":true,"path":"tags/index.html","permalink":"https://luan-bx.github.io/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2023-02-19T08:03:42.000Z","updated":"2023-03-08T10:17:01.809Z","comments":true,"path":"friends/index.html","permalink":"https://luan-bx.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"Cookie和Session","slug":"module/CookieSession","date":"2023-04-06T06:27:16.000Z","updated":"2023-04-17T09:27:16.508Z","comments":true,"path":"2023/04/06/module/cookiesession/","link":"","permalink":"https://luan-bx.github.io/2023/04/06/module/cookiesession/","excerpt":"","text":"相同点cookie和session都是用来跟踪浏览器用户身份的会话方式。 工作原理Cookie 浏览器端第一次发送请求到服务器端 服务器端创建Cookie，该Cookie中包含用户的信息，然后将该Cookie发送到浏览器端 浏览器端再次访问服务器端时会携带服务器端创建的Cookie 服务器端通过Cookie中携带的数据区分不同的用户 Session 浏览器端第一次发送请求到服务器端，服务器端创建一个Session，同时会创建一个特殊的Cookie（name为JSESSIONID的固定值，value为session对象的ID），然后将该Cookie发送至浏览器端 浏览器端发送第N（N&gt;1）次请求到服务器端,浏览器端访问服务器端时就会携带该name为JSESSIONID的Cookie对象 服务器端根据name为JSESSIONID的Cookie的value(sessionId),去查询Session对象，从而区分不同用户。 name为JSESSIONID的Cookie不存在（关闭或更换浏览器），返回1中重新去创建Session与特殊的Cookiename为JSESSIONID的Cookie存在，根据value中的SessionId去寻找session对象value为SessionId不存在Session对象默认存活30分钟，返回1中重新去创建Session与特殊的Cookievalue为SessionId存在，返回session对象 异同点：cookie数据保存在客户端，session数据保存在服务端。 cookiesessionid是服务器和客户端连接时候随机分配的，如果浏览器使用的是cookie，那么所有数据都保存在浏览器端，比如你登陆以后，服务器设置了cookie用户名，那么当你再次请求服务器的时候，浏览器会将用户名一块发送给服务器，这些变量有一定的特殊标记。服务器会解释为cookie变量，所以只要不关闭浏览器，那么cookie变量一直是有效的，所以能够保证长时间不掉线。 如果你能够截获某个用户的cookie变量，然后伪造一个数据包发送过去，那么服务器还是认为你是合法的。所以，使用cookie被攻击的可能性比较大。 如果cookie设置了有效值，那么cookie会保存到客户端的硬盘上，下次在访问网站的时候，浏览器先检查有没有cookie，如果有的话，读取cookie，然后发送给服务器。 所以你在机器上面保存了某个论坛cookie，有效期是一年，如果有人入侵你的机器，将你的cookie拷走，放在他机器下面，那么他登陆该网站的时候就是用你的身份登陆的。当然，伪造的时候需要注意，直接copy cookie文件到cookie目录，浏览器是不认的，他有一个index.dat文件，存储了 cookie文件的建立时间，以及是否有修改，所以你必须先要有该网站的 cookie文件，并且要从保证时间上骗过浏览器 两个都可以用来存私密的东西，session过期与否，取决于服务器的设定。cookie过期与否，可以在cookie生成的时候设置进去。 session简单的说，当你登陆一个网站的时候，如果web服务器端使用的是session，那么所有的数据都保存在服务器上，客户端每次请求服务器的时候会发送当前会话sessionid，服务器根据当前sessionid判断相应的用户数据标志，以确定用户是否登陆或具有某种权限。由于数据是存储在服务器上面，所以你不能伪造。 session常用方法 resquest.getSession()：得到请求游览器(客户端)对应的session。如果没有，那么就创建应该新的session。如果有那么就返回对应的session setAttribute(String s, Object o)：在session存放属性 getAttribute(String s)：从session中得到s所对应的属性 removeAttribute(String s)：从session中删除s对应的属性 getId()：得到session所对应的id invalidate()：使session立即无效 setMaxInactiveInterval(int i)：设置session最大的有效时间。注意，这个有效时间是两次访问服务器所间隔的最大时间，如果超过最大的有效时间，那么这个session就失效了。当传一个等于0或小于0的数时，session对象会永远有效，所以尽量不给他设置负值。 //得到session HttpSession session = request.getSession(); //设置最长访问间隔时间(一天) session.setMaxInactiveInterval(60*60*24); //将用户名存入session session.setAttribute(\"username\",username); 比较 cookie数据存放在客户的浏览器上，session数据放在服务器上 cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session session会在一定时间内保存在服务器上。当访问增多，会比较占用服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE 单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K。 所以：将登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中。","categories":[{"name":"Cookie和Session","slug":"Cookie和Session","permalink":"https://luan-bx.github.io/categories/Cookie%E5%92%8CSession/"}],"tags":[{"name":"Cookie","slug":"Cookie","permalink":"https://luan-bx.github.io/tags/Cookie/"},{"name":"Session","slug":"Session","permalink":"https://luan-bx.github.io/tags/Session/"}]},{"title":"前后端交互","slug":"module/html2","date":"2023-03-30T07:23:06.000Z","updated":"2023-04-12T12:36:19.130Z","comments":true,"path":"2023/03/30/module/html2/","link":"","permalink":"https://luan-bx.github.io/2023/03/30/module/html2/","excerpt":"","text":"前后端交互前端显示数据库查询的默认值，并且可以在输入框修改信息并提交 HTMLth:value是input输入框默认值，用来接后端数据。name命名参数，用于后端接受修改的字段。 &lt;form th:action=\"@{/updataInformationEntity}\" class=\"form-horizontal form-label-left\"> &lt;div class=\"form-group row \"> &lt;label class=\"control-label col-md-3 col-sm-3 \">企业名称：&lt;/label> &lt;div class=\"col-md-9 col-sm-9 \"> &lt;input type=\"text\" class=\"form-control\" name=\"company\" th:value=\"${informationEntity.company}\"> &lt;/div> &lt;/div> &lt;div class=\"form-group row \"> &lt;label class=\"control-label col-md-3 col-sm-3 \">行业：&lt;/label> &lt;div class=\"col-md-9 col-sm-9 \"> &lt;input type=\"text\" class=\"form-control\" name=\"industry\" th:value=\"${informationEntity.industry}\"> &lt;/div> &lt;/div> &lt;div class=\"form-group row \"> &lt;label class=\"control-label col-md-3 col-sm-3 \">企业描述：&lt;/label> &lt;div class=\"col-md-9 col-sm-9 \"> &lt;input type=\"text\" class=\"form-control\" name=\"description\" th:value=\"${informationEntity.description}\"> &lt;/div> &lt;/div> &lt;div class=\"form-group row \"> &lt;label class=\"control-label col-md-3 col-sm-3 \">监测点：&lt;/label> &lt;div class=\"col-md-9 col-sm-9 \"> &lt;div class=\"col-md-6 col-sm-6 \" style=\"padding: 10px;\"> &lt;span th:each=\"mc:${allMonitor}\" th:text=\"${mc}\" class=\"badge badge-danger\"> &lt;/span> &lt;/div> &lt;/div> &lt;/div> &lt;div class=\"form-group\"> &lt;div class=\"col-md-9 col-sm-9 offset-md-3\"> &lt;button type=\"button\" class=\"btn btn-primary\">取消&lt;/button> &lt;button type=\"reset\" class=\"btn btn-primary\">复位&lt;/button> &lt;button type=\"submit\" class=\"btn btn-success\">提交&lt;/button> &lt;/div> &lt;/div> &lt;/form> Controller @RequestMapping(\"/updateInformation\") public String updateInformation(HttpServletRequest request) { InformationEntity informationEntity = informationMapping.getInformation(); List&lt;String> allMonitor = MonitorDeviceService.getAllMonitor(); request.setAttribute(Constants.ALLMONITOR, allMonitor); request.setAttribute(\"informationEntity\", informationEntity); log.info(\"进入企业信息修改页面成功！\"); return \"updateInformation\"; } @RequestMapping(\"/updataInformationEntity\") public String updataInformationEntity(HttpServletRequest request, InformationEntity informationEntity) { try{ informationMapping.updateInformation(informationEntity); }catch (Exception e){ log.error(\"企业信息修改失败！\" +e); return updateInformation(request); } request.setAttribute(\"msg\", \"企业信息修改成功！\"); log.info(\"企业信息修改成功！\"); return indexWeb(request); } Mapping@Mapper public interface InformationMapping { @Update(\"UPDATE `information` SET `company`=#{company}, `industry`=#{industry},\" + \"`description`=#{description} WHERE `id`= 1;\") void updateInformation(InformationEntity informationEntity); @Select(\"select * from `information` WHERE `id`= 1;\") InformationEntity getInformation(); }","categories":[{"name":"前后端交互","slug":"前后端交互","permalink":"https://luan-bx.github.io/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://luan-bx.github.io/tags/HTML/"},{"name":"标签属性","slug":"标签属性","permalink":"https://luan-bx.github.io/tags/%E6%A0%87%E7%AD%BE%E5%B1%9E%E6%80%A7/"},{"name":"交互数据","slug":"交互数据","permalink":"https://luan-bx.github.io/tags/%E4%BA%A4%E4%BA%92%E6%95%B0%E6%8D%AE/"}]},{"title":"Linux下MySQL命令","slug":"mysql/mysql","date":"2023-03-21T05:23:16.000Z","updated":"2023-04-11T09:41:44.199Z","comments":true,"path":"2023/03/21/mysql/mysql/","link":"","permalink":"https://luan-bx.github.io/2023/03/21/mysql/mysql/","excerpt":"","text":"注意每条命令后面加上分号“；”，否则认为命令未输完。 进入MySQLmysql -u root -p 查看数据库show databases; 创建数据库create database XXXX; 执行sql文件（数据库迁移）//先选择数据库 use XXX; //执行sql文件 source 绝对路径 查看数据库所有表show tables; 查看表结构describe 表名; 查看表记录select * from 表名;","categories":[{"name":"MySQL命令","slug":"MySQL命令","permalink":"https://luan-bx.github.io/categories/MySQL%E5%91%BD%E4%BB%A4/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://luan-bx.github.io/tags/MySQL/"},{"name":"Linux","slug":"Linux","permalink":"https://luan-bx.github.io/tags/Linux/"}]},{"title":"CRUD","slug":"mysql/CRUD","date":"2023-03-21T05:23:10.000Z","updated":"2023-04-21T05:41:35.541Z","comments":true,"path":"2023/03/21/mysql/crud/","link":"","permalink":"https://luan-bx.github.io/2023/03/21/mysql/crud/","excerpt":"","text":"增@Insert@Insert(\"INSERT INTO `user`(`user_name`, `password`, `phone`, `email`, `gender`,`icon`, `number`, `post_id`, `post_name`) \" + \"values(#{userName}, #{password}, #{phone}, #{email}, #{gender}, #{icon}, #{number}, #{postId}, #{postName});\") void insert(UserEntity customerUserEntity); 删@Delete@Delete(\"delete from `user` where user_name = #{userName}\") void deleteUserByUserName(String userName); 查@Select普通查询//查全表 @Select(\"SELECT * FROM `alarm_records`\") List&lt;AlarmRecordEntity> getAllAlarmRecords(); //查某列（某字段） @Select(\"SELECT name FROM `user`\") List&lt;AlarmRecordEntity> getAllAlarmRecords(); //根据某字段查所有符合条件的 @Select(\"SELECT * from `user` WHERE number = #{number};\") UserEntity queryUserByNumber(@Param(\"number\") String number); 重复的只取一次遍历某个字段，重复的只取一个（时间戳最近的一个） 把company换成*，即取出整条记录 示例为alarm_records_company表中，company重复的按alarm_time时间最近的取值。 mapper@Select(\" select classtab.company FROM (SELECT company, MAX(alarm_time) alarm_time FROM alarm_records_company GROUP BY company) \" + \"tmp LEFT JOIN alarm_records_company classtab ON \" + \"classtab.company = tmp.company AND classtab.alarm_time = tmp.alarm_time;\") List&lt;String> getAllCompany(); 条件查询@SelectProvider前端返回需要查询的参数，AlarmService.class层做逻辑判断，不为空的参数即为要查询的 mapper@SelectProvider(type = AlarmService.class, method = \"selectRecordsByDynamicSql\") List&lt;AlarmRecordEntity> getAlarmRecordsByFeature(HashMap&lt;String,String> features); AlarmService.classpublic String selectRecordsByDynamicSql(HashMap&lt;String,String> features){ String sql = new SQL(){ { SELECT(\"*\"); FROM(\"alarm_records\"); if (!ObjectUtil.isEmptyString(features.get(\"monitor\"))){ WHERE(\"monitor = '\"+features.get(\"monitor\")+\"'\"); } if (!ObjectUtil.isEmptyString(features.get(\"monitorClass\"))){ WHERE(\"monitor_class = '\"+features.get(\"monitorClass\")+\"'\"); } if (!ObjectUtil.isEmptyString(features.get(\"monitorValue\"))){ WHERE(\"monitor_value = '\"+features.get(\"monitorValue\")+\"'\"); } if (!ObjectUtil.isEmptyString(features.get(\"startTime\"))){ WHERE(\"alarm_time >= '\"+features.get(\"startTime\")+\"'\"); } if (!ObjectUtil.isEmptyString(features.get(\"endTime\"))){ WHERE(\"alarm_time &lt;= '\"+features.get(\"endTime\")+\"'\"); } } }.toString(); return sql; } 改@Update&#96;&#96;&#96;sql&#x2F;&#x2F;根据某个字段更新该记录的另一个字段@Update(“UPDATE user SET icon&#x3D;#{icon} WHERE user_name&#x3D;#{userName};”)void updateIconByUserName(@Param(“userName”) String userName, @Param(“icon”) String icon); &#x2F;&#x2F;在整条记录上修改各个字段（id主键不会变）@Update(“UPDATE alarm_settings “ + “SET “ + “monitor_class &#x3D; #{monitorClass}, “ + “monitor_value &#x3D; #{monitorValue}, “ + “lower_limit &#x3D; #{lowerLimit}, “ + “upper_limit &#x3D; #{upperLimit}, “ + “message &#x3D; #{message} “ + “WHERE id&#x3D;#{id}”)public int updateAlarmSetting(AlarmSettingsEntity alarmSettingsEntity);","categories":[{"name":"CRUD","slug":"CRUD","permalink":"https://luan-bx.github.io/categories/CRUD/"}],"tags":[{"name":"CRUD","slug":"CRUD","permalink":"https://luan-bx.github.io/tags/CRUD/"},{"name":"MySQL","slug":"MySQL","permalink":"https://luan-bx.github.io/tags/MySQL/"}]},{"title":"rtsp视频流快照","slug":"module/rtspPhoto","date":"2023-03-15T15:01:15.000Z","updated":"2023-03-22T06:12:13.835Z","comments":true,"path":"2023/03/15/module/rtspphoto/","link":"","permalink":"https://luan-bx.github.io/2023/03/15/module/rtspphoto/","excerpt":"","text":"对rtsp视频流快速截图可以连续截图，也可以覆盖截图 import com.shark.aio.util.Constants; import lombok.Getter; import lombok.NoArgsConstructor; import lombok.SneakyThrows; import org.bytedeco.ffmpeg.global.avutil; import org.bytedeco.javacv.FFmpegFrameGrabber; import org.bytedeco.javacv.FFmpegFrameRecorder; import org.bytedeco.javacv.Frame; import org.bytedeco.javacv.FrameRecorder.Exception; import org.springframework.stereotype.Service; import java.io.File; import java.text.SimpleDateFormat; /** * @author lbx * @date 2023/2/27 - 15:04 **/ /** * 连续截图，覆盖截图 * @author eguid */ @Service @NoArgsConstructor @Getter public class ImageRecorderService implements Runnable{ private String input; private String output; private Integer width; private Integer height; private String mode; private static SimpleDateFormat DataFormat = new java.text.SimpleDateFormat(\"yyyy-MM-dd\"); private static String url = Constants.IMGOUTPUTPATH; //该方法监测的文件夹路径 private String PARENT_DIR; /** * 视频快照，连续截图，覆盖截图 * @author eguid * @param input 可以是动态图片(apng,gif等等)，视频文件（mp4,flv,avi等等）,流媒体地址（http-flv,rtmp，rtsp等等） * @param width 图像宽度 * @param height 图像高度 * @param mode 模式（1-覆盖模式，0-连续截图，根据文件名称模板顺序生成） */ // public static void record(String input,String output,Integer width,Integer height,String mode) throws Exception, org.bytedeco.javacv.FrameGrabber.Exception{ // // } public ImageRecorderService(String input,Integer width,Integer height,String mode,String monitorName){ this.input = input; this.output = url + monitorName + \"\\\\%Y-%m-%d_%H-%M-%S.jpg\"; this.width = width; this.height = height; this.mode = mode; this.PARENT_DIR = url + monitorName; } @SneakyThrows @Override public void run() { File localPath1 = new File(PARENT_DIR); if (!localPath1.exists()) { // 获得文件目录，判断目录是否存在，不存在就新建一个 localPath1.mkdirs(); } FFmpegFrameGrabber grabber = new FFmpegFrameGrabber(input); //虽然rtsp本身是协议，但是对于ffmpeg来说，rtsp只是个多路复用器/解复用器。可以支持普通的rtp传输，也可以支持RDT传输的Real-RTSP协议 grabber.setFormat(\"rtsp\"); //设置要从服务器接受的媒体类型，为空默认支持所有媒体类型，支持的媒体类型：[video，audio，data] grabber.setOption(\"allowed_media_types\", \"video\"); //设置RTSP传输协议为tcp传输模式 grabber.setOption(\"rtsp_transport\", \"tcp\"); /* * rtsp_flags:[filter_src,prefer_tcp,listen] * filter_src:仅接受来自协商对等地址和端口的数据包。 * prefer_tcp:如果TCP可用作RTSP RTP传输，请首先尝试使用TCP进行RTP传输。 * listen:充当rtsp服务器，监听rtsp连接 * rtp传输首选使用tcp传输模式 */ grabber.setOption(\"rtsp_flags\", \"prefer_tcp\"); //socket网络超时时间 grabber.setOption(\"stimeout\",\"3000000\"); //设置要缓冲以处理重新排序的数据包的数据包数量 // grabber.setOption(\"reorder_queue_size\",\"\"); //设置本地最小的UDP端口，默认为5000端口。 // grabber.setOption(\"min_port\",\"5000\"); //设置本地最大的UDP端口，默认为65000端口。 // grabber.setOption(\"max_port\",\"65000\"); grabber.start(); if(width==null||height==null) { width=grabber.getImageWidth(); height=grabber.getImageHeight(); } FFmpegFrameRecorder recorder =new FFmpegFrameRecorder(output,width,height,0); //过滤掉日志 avutil.av_log_set_level(avutil.AV_LOG_ERROR); recorder.setFormat(\"image2\"); if(mode==null) { mode=\"0\";//默认连续截图 } recorder.setOption(\"update\", mode); recorder.setOption(\"strftime\", \"1\"); //根据日期生成文件名 try { recorder.start(); } catch (Exception e) { throw new RuntimeException(e); } // CanvasFrame canvas = new CanvasFrame(\"图像预览\");// 新建一个窗口 // canvas.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); Frame frame = null; // 只抓取图像画面 for (;(frame = grabber.grabImage()) != null;) { try { // 显示画面 // canvas.showImage(frame); //录制/推流 recorder.record(frame); // Thread.sleep(1000); } catch (org.bytedeco.javacv.FrameRecorder.Exception e) { e.printStackTrace(); } } recorder.close();//close包含stop和release方法。录制文件必须保证最后执行stop()方法，才能保证文件头写入完整，否则文件损坏。 grabber.close();//close包含stop和release方法 } }","categories":[{"name":"rtsp视频流","slug":"rtsp视频流","permalink":"https://luan-bx.github.io/categories/rtsp%E8%A7%86%E9%A2%91%E6%B5%81/"}],"tags":[{"name":"module","slug":"module","permalink":"https://luan-bx.github.io/tags/module/"},{"name":"rtsp视频流","slug":"rtsp视频流","permalink":"https://luan-bx.github.io/tags/rtsp%E8%A7%86%E9%A2%91%E6%B5%81/"},{"name":"视频","slug":"视频","permalink":"https://luan-bx.github.io/tags/%E8%A7%86%E9%A2%91/"}]},{"title":"rtsp视频流存储","slug":"module/rtspSave","date":"2023-03-14T13:29:49.000Z","updated":"2023-03-22T06:12:22.058Z","comments":true,"path":"2023/03/14/module/rtspsave/","link":"","permalink":"https://luan-bx.github.io/2023/03/14/module/rtspsave/","excerpt":"","text":"对rtsp视频流存储 import org.bytedeco.ffmpeg.global.avcodec; import org.bytedeco.ffmpeg.global.avutil; import org.bytedeco.javacv.FFmpegFrameGrabber; import org.bytedeco.javacv.FFmpegFrameRecorder; import org.bytedeco.javacv.Frame; import java.io.File; import java.text.SimpleDateFormat; import java.util.Date; /** * @author lbx * @date 2023/2/23 - 16:11 **/ public class VideoRecorderService { static SimpleDateFormat DataFormat = new java.text.SimpleDateFormat(\"yyyy-MM-dd\"); static SimpleDateFormat TimeFormat = new java.text.SimpleDateFormat(\"HH-mm-ss\"); private String inputFile = Constants.LBXINPUT; //根据当前日期+时间命名 private String outputFile = Constants.VIDEOOUTPUTPATH + \"\\\\%Y-%m-%d_%H-%M-%S.mp4\"; public void startRecordVideo() throws Exception { String url = \"D:\\\\项目\\\\AIO\\\\recorder\\\\\" +(new java.text.SimpleDateFormat(\"yyyy-MM-dd\")).format(new Date()) ; File localPath = new File(url); if (!localPath.exists()) { // 获得文件目录，判断目录是否存在，不存在就新建一个 localPath.mkdirs(); } // %03d表示长度为3位，缺位的补零 frameRecord(inputFile, outputFile,1); } /** * 按帧录制视频 * @param inputFile-该地址可以是网络直播/录播地址，也可以是远程/本地文件路径 * @param outputFile-文件地址 * @param audioChannel * @throws Exception * @throws org.bytedeco.javacv.FrameRecorder.Exception */ public void frameRecord(String inputFile, String outputFile, int audioChannel) throws Exception, org.bytedeco.javacv.FrameRecorder.Exception { boolean isStart=true;//该变量建议设置为全局控制变量，用于控制录制结束 // 获取视频源 FFmpegFrameGrabber grabber = new FFmpegFrameGrabber(inputFile); // 如果不设置成tcp连接时，默认使用UDP，丢包现象比较严重 grabber.setOption(\"rtsp_transport\", \"tcp\"); // 设置成tcp以后比较稳定 //socket网络超时时间 grabber.setOption(\"stimeout\",\"3000000\"); grabber.setImageWidth(1280); grabber.setImageHeight(720); grabber.setImageScalingFlags(0); // grabber.setPixelFormat(avutil.AV_PIX_FMT_YUV420P); // 一般来说摄像头的帧率是25 grabber.setFrameRate(25); // 流媒体输出地址，分辨率（长，高），是否录制音频（0:不录制/1:录制） FFmpegFrameRecorder recorder = new FFmpegFrameRecorder(outputFile, 1280,720, audioChannel); // 设置视频编码H264 recorder.setVideoCodec(avcodec.AV_CODEC_ID_H264); //设置音频编码 recorder.setAudioCodec(avcodec.AV_CODEC_ID_AAC); // 2000 kb/s, reasonable \"sane\" area for 720 // recorder.setVideoBitrate(4000000); // recorder.setPixelFormat(avutil.AV_PIX_FMT_YUV420P); // recorder.setPixelFormat(0); //过滤掉日志 avutil.av_log_set_level(avutil.AV_LOG_ERROR); recorder.setOption(\"strftime\", \"1\"); //根据日期生成文件名 recorder.setFormat(\"segment\"); //十秒钟一切 recorder.setOption(\"segment_time\", \"10\"); recorder.setOption(\"segment_filename\", \"10\"); //生成模式：live（实时生成）、cache（边缓存边生成，只支持m3u8清单文件缓存） recorder.setOption(\"segment_list_flags\", \"live\"); //强制锁定切片时长 recorder.setOption(\"segment_atclocktime\", \"1\"); //使得每段视频都是从零开始计时 recorder.setOption(\"reset_timestamps\", \"1\"); //设置帧率 recorder.setFrameRate(25); //因为是直播，如果需要保证最小延迟，gop最好设置成帧率相同或者帧率*2 //一个gop表示关键帧间隔，假设25帧/秒视频，gop是50， //则每隔两秒有一个关键帧，播放器必须加载到关键帧才能开始解码播放，就是说直播流最多两秒延迟 recorder.setGopSize(50);//设置gop recorder.setVideoQuality(0.8);//视频质量 recorder.setVideoBitrate(2000000);//码率，10kb/s // 在视频质量和编码速度之间选择适合自己的方案，包括这些选项： // ultrafast,superfast, veryfast, faster, fast, medium, slow, slower, veryslow // ultrafast offers us the least amount of compression (lower encoder CPU) at the cost of a larger stream size // at the other end, veryslow provides the best compression (high encoder CPU) while lowering the stream size // (see: https://trac.ffmpeg.org/wiki/Encode/H.264) // ultrafast对CPU消耗最低 // recorder.setVideoOption(\"preset\", \"veryslow\"); // 开始取视频源 recordByFrame(grabber, recorder, isStart); } private void recordByFrame(FFmpegFrameGrabber grabber, FFmpegFrameRecorder recorder, Boolean status) throws Exception, org.bytedeco.javacv.FrameRecorder.Exception { try {//建议在线程中使用该方法 grabber.start(); recorder.start(); Frame frame = null; while (status&amp;&amp; (frame = grabber.grabFrame()) != null) { recorder.record(frame); //1.用线程sleep //2.获取当前时间，做时间差 //3.@Scheduled } recorder.stop(); grabber.stop(); } catch (org.bytedeco.javacv.FrameRecorder.Exception e) { try { e.printStackTrace(); System.out.println(\"录制器启动失败，正在重新启动...\"); if (recorder != null) { System.out.println(\"尝试关闭录制器\"); recorder.stop(); grabber.stop(); System.out.println(\"尝试重新开启录制器\"); // recorder.start(); frameRecord(inputFile,outputFile,1); } } catch (org.bytedeco.javacv.FrameRecorder.Exception e1) { throw e; } }finally { if (grabber != null) { grabber.stop(); } } } }","categories":[{"name":"rtsp视频流","slug":"rtsp视频流","permalink":"https://luan-bx.github.io/categories/rtsp%E8%A7%86%E9%A2%91%E6%B5%81/"}],"tags":[{"name":"module","slug":"module","permalink":"https://luan-bx.github.io/tags/module/"},{"name":"rtsp视频流","slug":"rtsp视频流","permalink":"https://luan-bx.github.io/tags/rtsp%E8%A7%86%E9%A2%91%E6%B5%81/"},{"name":"视频","slug":"视频","permalink":"https://luan-bx.github.io/tags/%E8%A7%86%E9%A2%91/"}]},{"title":"普通类@Autowired注入为null","slug":"DevelopmentProblem","date":"2023-02-26T14:03:49.000Z","updated":"2023-04-20T03:14:16.758Z","comments":true,"path":"2023/02/26/developmentproblem/","link":"","permalink":"https://luan-bx.github.io/2023/02/26/developmentproblem/","excerpt":"","text":"在普通类里或工具类里注入service或mapper，那么我们直接使用@Autowired注入，注入的service或mapper在方法里是不能直接使用，会报null。 如果是工具类，工具类里一般都是静态方法，更是无法使用。 解决方法方法一：构造器传参如果该工具类或普通类是被其他Controller&#x2F;Service层调用的 可以在Controller&#x2F;Service层@Autowired注入类 并创造被调用类的构造器 将对象传到被调用的类 调用的类 @Autowired protected ReceiveAlarmMapping receiveAlarmMapping; Socket socket = null; socket = serverSocket.accept(); public void receiveAlarm() { Thread serverHandleThread = new Thread(new ServerHandleThread(socket, receiveAlarmMapping)); serverHandleThread.setPriority(4); serverHandleThread.start(); } 被调用的类 Socket socket = null; ReceiveAlarmMapping receiveAlarmMapping = null; public ServerHandleThread(Socket socket, ReceiveAlarmMapping receiveAlarmMapping) { super(); this.socket = socket; this.receiveAlarmMapping = receiveAlarmMapping; } 方法二：@PostConstruct第一步：在java类上添加@Component注解，将java类实例到spring容器中。 import org.springframework.stereotype.Component; @Component public class HJ212ServerHandler { } 第二步：使用@Autowired注入service或mapper。 import org.springframework.stereotype.Component; import org.springframework.beans.factory.annotation.Autowired; @Component public class HJ212ServerHandler { // 需要注入的 service @Autowired protected ConditionService conditionService; } 第三步：使用@PostConstruct注解初始化java类和service或mapper。 import javax.annotation.PostConstruct; import org.springframework.stereotype.Component; import org.springframework.beans.factory.annotation.Autowired; @Component public class HJ212ServerHandler { // 需要注入的 service @Autowired protected ConditionService conditionService; // 当前类 private static HJ212ServerHandler hJ212ServerHandler; /** * 初始化 */ @PostConstruct public void init(){ hJ212ServerHandler = this; hJ212ServerHandler.conditionService = this.conditionService; } } 第四步：以上三步完成后，在方法里就可以使用注入的service或mapper了。 import javax.annotation.PostConstruct; import org.springframework.stereotype.Component; import org.springframework.beans.factory.annotation.Autowired; @Component public class HJ212ServerHandler { // 需要注入的 service @Autowired protected ConditionService conditionService; // 当前类 private static HJ212ServerHandler hJ212ServerHandler; /** * 初始化 */ @PostConstruct public void init(){ hJ212ServerHandler = this; hJ212ServerHandler.conditionService = this.conditionService; } /** * 需要使用 serive 的方法 */ public static void test(){ // 调用查询方法 String monitorName = hJ212ServerHandler.conditionService.getMonitorName(mn); } }","categories":[{"name":"开发常见问题","slug":"开发常见问题","permalink":"https://luan-bx.github.io/categories/%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"开发常见问题","slug":"开发常见问题","permalink":"https://luan-bx.github.io/tags/%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/tags/Java/"}]},{"title":"监听器","slug":"module/fileListener","date":"2023-02-25T08:33:56.000Z","updated":"2023-03-22T06:11:42.358Z","comments":true,"path":"2023/02/25/module/filelistener/","link":"","permalink":"https://luan-bx.github.io/2023/02/25/module/filelistener/","excerpt":"","text":"监听器：文件&#x2F;文件夹 当文件&#x2F;文件夹发生新增或删除就会出发监听器并可以设置相关操作比如视频快照，每个照片都要进行算法识别，可以监听该文件夹，一旦有新照片创建，自动调用算法接口。 import lombok.extern.slf4j.Slf4j; import org.apache.commons.io.FileUtils; import org.apache.commons.io.monitor.FileAlterationListenerAdaptor; import org.apache.commons.io.monitor.FileAlterationMonitor; import org.apache.commons.io.monitor.FileAlterationObserver; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.context.event.ApplicationReadyEvent; import org.springframework.context.ApplicationListener; import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor; import javax.annotation.Resource; import java.io.File; import java.util.List; //@Component @Slf4j public class InitFFmpeg implements ApplicationListener&lt;ApplicationReadyEvent> { @Override public void onApplicationEvent(ApplicationReadyEvent event) { runExample(\"需要监听的 文件/文件夹 URL\"); } public void runExample(String PARENT_DIR) throws java.lang.Exception { File parentDir = FileUtils.getFile(PARENT_DIR); FileAlterationObserver observer = new FileAlterationObserver(parentDir); observer.addListener(new FileAlterationListenerAdaptor() { @Override public void onFileCreate(File file) { } @Override public void onFileDelete(File file) { } @Override public void onDirectoryCreate(File dir) { System.out.println(\"Directory created: \" + dir.getName()); } @Override public void onDirectoryDelete(File dir) { System.out.println(\"Directory deleted: \" + dir.getName()); } }); FileAlterationMonitor monitor = new FileAlterationMonitor(500, observer); monitor.start(); } }","categories":[{"name":"监听器","slug":"监听器","permalink":"https://luan-bx.github.io/categories/%E7%9B%91%E5%90%AC%E5%99%A8/"}],"tags":[{"name":"文件操作","slug":"文件操作","permalink":"https://luan-bx.github.io/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"name":"module","slug":"module","permalink":"https://luan-bx.github.io/tags/module/"},{"name":"监听器","slug":"监听器","permalink":"https://luan-bx.github.io/tags/%E7%9B%91%E5%90%AC%E5%99%A8/"}]},{"title":"String类常用方法","slug":"String","date":"2023-02-12T07:06:31.000Z","updated":"2023-03-19T05:53:45.296Z","comments":true,"path":"2023/02/12/string/","link":"","permalink":"https://luan-bx.github.io/2023/02/12/string/","excerpt":"","text":"replacemsg.replace(\";CP=\", \"\") replace将此字符串中与目标序列匹配的每个子字符串替换为指定的文字替换序列。 替换从字符串的开始一直进行到结束 例如，在字符串“aaa”中，将“aa”替换为“b”将导致“ba”而不是“ab”。 形参: target -要替换的字符值的序列replace -字符值的替换序列 substringsubstring返回该字符串的子字符串。 以索引处的字符开始，并扩展到该字符串的末尾。 例子: “unhappy” .substring(2)返回”happy” “Harbison”.substring(3)返回”bison” “empty”.substring(9)返回””(空字符串) 以索引1的字符开始，并扩展到该字符串的索引2,但不包含索引2。 例子: “123456”.substring(2,5)返回”345” containsif (msg.contains(\"DataTime\")) 当且仅当此字符串包含指定的char值序列时返回true。 形参: S -要搜索的序列 返回值: 如果字符串包含s则为True，否则为false indexOfdata.indexOf(\"-\") 返回该字符串中指定子字符串第一次出现的索引。 返回值: 指定子字符串的第一个出现项的索引，如果没有出现项，则为-1。 例子: “123456”.indexOf(“2”)返回”1”","categories":[{"name":"String类","slug":"String类","permalink":"https://luan-bx.github.io/categories/String%E7%B1%BB/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/tags/Java/"},{"name":"String类","slug":"String类","permalink":"https://luan-bx.github.io/tags/String%E7%B1%BB/"}]},{"title":"HTML标签属性（后端）","slug":"module/html","date":"2023-01-07T03:51:28.000Z","updated":"2023-04-21T05:53:25.479Z","comments":true,"path":"2023/01/07/module/html/","link":"","permalink":"https://luan-bx.github.io/2023/01/07/module/html/","excerpt":"","text":"HTML标签属性（由后端控制）我们需要在HTML标签控制一条属性，该属性的性质来自后端例如 &lt;input&gt; 标签里的checked标签，通过它控制复选框是否选择true为选上，false或空是没选。后面尝试用0和1也可以控制但是前端返回给后端的是off和on HTML&lt;div class=\"\"> &lt;label> &lt;input type=\"checkbox\" class=\"js-switch\" th:attr=\"checked=${authority.authority2}\"/> 用电监测 &lt;/label> &lt;/div> AuthorityController@RequestMapping(\"/authorityManagement\") public String authority(HttpServletRequest req){ AuthorityEntity authority = new AuthorityEntity(); req.setAttribute(\"authority\", authority); return \"authorityManagement\"; } AuthorityEntity//0和1，true和false都可以控制 private int id; private String authority1 = \"true\"; private String authority2 = \"false\" ; private int authority3 = 1; private int authority4 = 0; private int authority5 = 0; private int authority6 = 0; private int authority7 = 0;","categories":[{"name":"HTML标签属性","slug":"HTML标签属性","permalink":"https://luan-bx.github.io/categories/HTML%E6%A0%87%E7%AD%BE%E5%B1%9E%E6%80%A7/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://luan-bx.github.io/tags/HTML/"},{"name":"标签属性","slug":"标签属性","permalink":"https://luan-bx.github.io/tags/%E6%A0%87%E7%AD%BE%E5%B1%9E%E6%80%A7/"},{"name":"交互数据","slug":"交互数据","permalink":"https://luan-bx.github.io/tags/%E4%BA%A4%E4%BA%92%E6%95%B0%E6%8D%AE/"}]},{"title":"Sokect传输对象","slug":"module/socket","date":"2022-11-23T03:05:13.000Z","updated":"2023-04-19T07:34:00.144Z","comments":true,"path":"2022/11/23/module/socket/","link":"","permalink":"https://luan-bx.github.io/2022/11/23/module/socket/","excerpt":"","text":"流程可以理解为是对TCP的实现。 服务端 创建ServerSocket对象，绑定监听端口 通过accept0方法监听客户端请求 连接建立后，通过输入流读取客户端发送的请求信息 通过输出流向客户端发送响应信息 关闭相关资源 客户端 : 创建Socket对象，指明需要连接的服务器的地址和端口号 连接建立后，通过输出流向服务器端发送请求信息 通过输入流获取服务器响应的信息 关闭相关资源 序列化和反序列化对象输出流和对象输入流（ObjectOutputStream和ObjectInputStream）只能将支持 java.io.Serializable 接口的对象写入流中。需要传递的类必须实现需要实现Serializable接口接口。 @Data @ToString //需要实现Serializable接口 public class AuthorityEntity implements Serializable { private int id; private String authority1 = \"off\"; private String authority2 = \"off\"; private String authority3 = \"off\"; private String authority4 = \"off\"; private String authority5 = \"off\"; private String authority6 = \"off\"; private String authority7 = \"off\"; } 序列化：将一个特定的数据结构转换为一组字节的过程。ObjectOutputStream 反序列化：将一组字节转换为特定的数据结构的过程。ObjectInputStream ObjectOutputStream将 Java 对象的基本数据类型和图形写入 OutputStream。 可以使用 ObjectInputStream 读取（重构）对象。 通过在流中使用文件可以实现对象的持久存储。 如果流是网络套接字流，则可以在另一台主机上或另一个进程中重构对象。 常用方法：&#x2F;&#x2F;将指定的对象写入 ObjectOutputStream。public final void writeObject(Object obj);如： OutputStream os = socket.getOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(os); oos.writeObject(authorityEntity); ObjectInputStream对以前使用 ObjectOutputStream 写入的基本数据和对象进行反序列化。 常用方法：&#x2F;&#x2F;从 ObjectInputStream 读取对象。public final Object readObject();如： InputStream is = socket.getInputStream(); ObjectInputStream ois = new ObjectInputStream(is); //必须保证服务端和客户端的 对象 包名一致 log.info(\"客户端发送的对象：\" + ois.readObject()); 实现 创建服务端Socket：ServerSocket 创建客户端Socket：Socket； 打开连接到Socket的InputStream&#x2F;OutputStream; 按照协议对Socket进行读写操作； 关闭InputStream和OutputStream和Socket。 服务端/** * 接受请求并开起处理线程 */ public class ContractPart { public static void main(String arg[]) { try { ServerSocket serverSocket = new ServerSocket(9998); int count = 0;//记录客户端的数量 System.out.println(\"服务器启动，等待客户端的连接。。。\"); Socket socket = null; while (true) { socket = serverSocket.accept(); ++count; Thread serverHandleThread = new Thread(new ServerHandleThread(socket)); serverHandleThread.setPriority(4); serverHandleThread.start(); System.out.println(\"上线的客户端有\" + count + \"个！\"); InetAddress inetAddress = socket.getInetAddress(); System.out.println(\"当前客户端的IP地址是：\" + inetAddress.getHostAddress()); } } catch (IOException e) {//TODO Auto-generated catch block e.printStackTrace(); } } } /** * 服务器对socket进行处理的线程 */ class ServerHandleThread implements Runnable { Socket socket = null; public ServerHandleThread(Socket socket) { super(); this.socket = socket; } @Override public void run() {//TODO Auto-generated method stub OutputStream os = null; PrintWriter pw = null; try { InputStream is = socket.getInputStream(); ObjectInputStream ois = new ObjectInputStream(is); //readObject()方法必须保证服务端和客户端的 对象 包名一致，要不然会出现找不到类的错误 System.out.println(\"客户端发送的对象：\" + ois.readObject()); socket.shutdownInput();//禁用套接字的输入流 os = socket.getOutputStream(); pw = new PrintWriter(os); pw.println(\"欢迎登录！\"); pw.flush(); socket.shutdownOutput(); } catch (IOException | ClassNotFoundException e) {//TODO Auto-generated catch block e.printStackTrace(); } finally { try { if (pw != null) { pw.close(); } if (os != null) { os.close(); } if (socket != null) { socket.close(); } } catch (IOException e) {//TODO Auto-generated catch block e.printStackTrace(); } } } } 客户端public static void main(String arg[]) throws IOException { try { //1.创建客户端的Socket，指定服务器的IP和端口 Socket socket = new Socket(\"454585x8l0.qicp.vip\", 14031); //2.获取该Socket的输出流，用来向服务器发送信息 OutputStream os = socket.getOutputStream(); //将对象序列化，转为字节 ObjectOutputStream oos = new ObjectOutputStream(os); //对象写入输出流 AuthorityEntity authorityEntity = new AuthorityEntity(); oos.writeObject(authorityEntity); socket.shutdownOutput(); String infoString = null; //3.获取输入流，取得服务器的信息 InputStream is = socket.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(is)); String info = null; while ((info = br.readLine()) != null) { System.out.println(\"服务器端的信息：\" + info); } socket.shutdownInput(); oos.close(); os.close(); is.close(); br.close(); socket.close(); } catch (UnknownHostException e) {//TODO Auto-generated catch block e.printStackTrace(); } catch (IOException e) {//TODO Auto-generated catch block e.printStackTrace(); } } 注ObjectOutputStream 和 ObjectInputStream 分别与 FileOutputStream 和 FileInputStream 一起使用时，可以为应用程序提供对对象图形的持久存储。 传输多个参数分别添加各个参数，可以是同类。但接受方顺序必须保持一致 //客户端 oos.writeObject(alarmRecordEntity ); oos.writeObject(\"1\" ); oos.writeObject(\"2\" ); //服务端 System.out.println((AlarmRecordEntity)ois.readObject()); System.out.println((String) ois.readObject()); System.out.println((String) ois.readObject());","categories":[{"name":"Sokect","slug":"Sokect","permalink":"https://luan-bx.github.io/categories/Sokect/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"https://luan-bx.github.io/tags/TCP/"},{"name":"Sokect","slug":"Sokect","permalink":"https://luan-bx.github.io/tags/Sokect/"},{"name":"传输对象","slug":"传输对象","permalink":"https://luan-bx.github.io/tags/%E4%BC%A0%E8%BE%93%E5%AF%B9%E8%B1%A1/"}]},{"title":"内存磁盘网络参数","slug":"module/system","date":"2022-10-11T08:39:53.000Z","updated":"2023-03-30T12:15:24.769Z","comments":true,"path":"2022/10/11/module/system/","link":"","permalink":"https://luan-bx.github.io/2022/10/11/module/system/","excerpt":"","text":"内存、磁盘 /** * 获取内存使用情况 */ @RequestMapping(\"/diskCapacityManagement\") public String diskCapacityManagement(HttpServletRequest req, HttpServletResponse reps) throws IOException { OperatingSystemMXBean mem = (OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean(); // 获取内存总容量 long totalMemorySize = mem.getTotalPhysicalMemorySize(); // 获取可用内存容量(剩余物理内存） long freeMemorySize = mem.getFreePhysicalMemorySize(); // 空闲的交换容量 long freeSwapSpaceSize = mem.getFreeSwapSpaceSize(); float usedRAM = (float)(((totalMemorySize - freeMemorySize) * 1.0 / totalMemorySize) * 100); System.out.println(\"物理内存总容量totalMemorySize：\" + transformation(totalMemorySize) ); System.out.println(\"剩余物理内存可用容量freeMemorySize：\" + transformation(freeMemorySize)); System.out.println(\"usedRAM：\" + usedRAM); System.out.println(\"空闲的交换容量:\" + transformation(freeSwapSpaceSize)); // Runtime runtime = Runtime.getRuntime(); // // java虚拟机中的内存总量，可用内存空间 单位为byte，默认为系统的1/64 // long totalMemory = runtime.totalMemory(); // // java虚拟机试图使用的最大内存量 最大可用内存空间 单位byte，默认为系统的1/4 // long maxMemory = runtime.maxMemory(); // // java 虚拟机中的空闲内存量 空闲空间 单位byte， 默认为系统的1/4 // long freeMemory = runtime.freeMemory(); // float usedRAMJava = (float)(((totalMemory - freeMemory) * 1.0 / totalMemory) * 100); // System.out.println(\"java虚拟机中的内存总量:\" + totalMemory / 1024 / 1024 + \"MB\" ); // System.out.println(\"java虚拟机试图使用的最大内存量:\" + maxMemory / 1024 / 1024 + \"MB\" ); // System.out.println(\"java虚拟机中的空闲内存量:\" + freeMemory / 1024 / 1024 + \"MB\" ); // System.out.println(\"java虚拟机中的剩余内存占总量:\" + usedRAMJava + \"%\" ); //限制小数点位数 DecimalFormat df = new DecimalFormat(\"#0.00\"); File[] disks = File.listRoots(); for (File file : disks) { // 获取盘符 System.out.print(file.getCanonicalPath() + \" \"); // 获取总容量 long totalSpace = file.getTotalSpace(); // 获取剩余容量 long usableSpace = file.getUsableSpace(); // 获取已经使用的容量 long freeSpace = totalSpace - usableSpace; // 获取使用率 float useRate = (float)((freeSpace * 1.0 / totalSpace) * 100); System.out.print(\"总容量： \" + transformation(totalSpace)); System.out.print(\"已经使用： \" + transformation(freeSpace)); System.out.print(\"剩余容量： \" + transformation(usableSpace)); System.out.println(\"使用率： \" + df.format(useRate) + \"% \"); } boolean isConnect = isConnect(\"www.baidu.com\"); System.out.println(\"网络状态\" + isConnect); DiskCapacityEntity diskCapacity = new DiskCapacityEntity(); diskCapacity.setTotalMemorySize(transformation(totalMemorySize)); diskCapacity.setTotalSpace(transformation(totalSpace)); diskCapacity.setConnect(isConnect); diskCapacity.setUsedRAMRate(df.format(usedRAMRate) + \"%\"); diskCapacity.setUseRate(df.format(useRate) + \"%\"); req.setAttribute(\"diskCapacity\", diskCapacity); return \"diskCapacityManagement\"; } /** * 将字节容量转化为GB */ public static String transformation(long size){ DecimalFormat df = new DecimalFormat(\"#0.00\"); return df.format((float) size / 1024 / 1024 / 1024) + \"GB\"+\" \"; } 网络情况（是否连接）public static boolean isConnect(String urlPath){ //定义其返回的状态，默认为false，网络不正常 boolean connect = false; Runtime runtime = Runtime.getRuntime(); Process process; try { process = runtime.exec(\"ping \" + urlPath); InputStream is = process.getInputStream(); InputStreamReader isr = new InputStreamReader(is,\"GBK\"); BufferedReader br = new BufferedReader(isr); String line = null; StringBuffer sb = new StringBuffer(); while ((line = br.readLine()) != null) { sb.append(line); } // System.out.println(\"返回值为: {}\"+sb); is.close(); isr.close(); br.close(); if (null != sb &amp;&amp; !sb.toString().equals(\"\")) { if (sb.toString().indexOf(\"TTL\") > 0) { // 网络畅通 connect = true; } else { // 网络不畅通 connect = false; } } } catch (IOException e) { e.printStackTrace(); } return connect; } 前端 &lt;table class=\"table table-striped projects\"> &lt;thead> &lt;tr> &lt;th style=\"width: 10%\">内存总容量&lt;/th> &lt;th style=\"width: 10%\">磁盘总容量&lt;/th> &lt;th style=\"width: 10%\">网络状态&lt;/th> &lt;th>内存利用率&lt;/th> &lt;th>存储利用率&lt;/th> &lt;th>编辑&lt;/th> &lt;/tr> &lt;/thead> &lt;tbody> &lt;tr th:each=\"disk:${diskCapacity}\"> &lt;td th:text=\"${disk.totalMemorySize}\">&lt;/td> &lt;td th:text=\"${disk.totalSpace}\">&lt;/td> &lt;td th:if=\"${disk.connect} eq true\"> &lt;button type=\"button\" class=\"btn btn-success btn-sm btn-round\">良好&lt;/button> &lt;/td> &lt;td th:if=\"${disk.connect }eq false\"> &lt;button type=\"button\" class=\"btn btn-danger btn-sm btn-round\">掉线&lt;/button> &lt;/td> &lt;td class=\"project_progress\" > &lt;div class=\"progress progress_sm\"> &lt;div class=\"progress-bar bg-green\" role=\"progressbar\" th:data-transitiongoal= \"${disk.usedRAMRate}\">&lt;/div> &lt;/div> &lt;small th:text=\"${disk.usedRAMRate}\">&lt;/small> &lt;/td> &lt;td class=\"project_progress\" > &lt;div class=\"progress progress_sm\"> &lt;div class=\"progress-bar bg-green\" role=\"progressbar\" th:data-transitiongoal= \"${disk.useRate}\">&lt;/div> &lt;/div> &lt;small th:text=\"${disk.useRate}\">&lt;/small> &lt;/td> &lt;td> &lt;a href=\"#\" class=\"btn btn-info btn-sm\">&lt;i class=\"fa fa-pencil\">&lt;/i> 提醒 &lt;/a> &lt;a th:href=\"@{/documentManagement}\" class=\"btn btn-danger btn-sm\">&lt;i class=\"fa fa-trash-o\">&lt;/i> 删除 &lt;/a> &lt;/td> &lt;/tr> &lt;/tbody> &lt;/table>","categories":[{"name":"系统参数","slug":"系统参数","permalink":"https://luan-bx.github.io/categories/%E7%B3%BB%E7%BB%9F%E5%8F%82%E6%95%B0/"}],"tags":[{"name":"内存","slug":"内存","permalink":"https://luan-bx.github.io/tags/%E5%86%85%E5%AD%98/"},{"name":"磁盘","slug":"磁盘","permalink":"https://luan-bx.github.io/tags/%E7%A3%81%E7%9B%98/"},{"name":"网络","slug":"网络","permalink":"https://luan-bx.github.io/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"前端加弹窗","slug":"module/frontPopover","date":"2022-09-24T12:06:54.000Z","updated":"2023-04-11T05:44:12.683Z","comments":true,"path":"2022/09/24/module/frontpopover/","link":"","permalink":"https://luan-bx.github.io/2022/09/24/module/frontpopover/","excerpt":"","text":"前端加弹窗 前端加一段js即可 &lt;script th:inline=\"javascript\"> /*&lt;![CDATA[*/ var msg = /*[[${msg}]]*/null; if(msg!=null){ alert(msg); } /*]]>*/ &lt;/script> 后端request方法 @RequestMapping(\"/pollution\") public String pollutionWeb(HttpServletRequest request) { request.setAttribute(Constants.MSG, \"暂无数据\"); return \"pollution\"; }","categories":[{"name":"前端加弹窗","slug":"前端加弹窗","permalink":"https://luan-bx.github.io/categories/%E5%89%8D%E7%AB%AF%E5%8A%A0%E5%BC%B9%E7%AA%97/"}],"tags":[{"name":"module","slug":"module","permalink":"https://luan-bx.github.io/tags/module/"},{"name":"html","slug":"html","permalink":"https://luan-bx.github.io/tags/html/"}]},{"title":"接口继承","slug":"javaCode/JavaCodeImplements","date":"2022-08-14T14:32:51.000Z","updated":"2023-03-09T07:10:29.088Z","comments":true,"path":"2022/08/14/javacode/javacodeimplements/","link":"","permalink":"https://luan-bx.github.io/2022/08/14/javacode/javacodeimplements/","excerpt":"","text":"ApplicationRunnerspringBoot项目启动时，代码自启动 @Component @Order(1) public class HJ212Server implements ApplicationRunner { @Override public void run(ApplicationArguments args) { runEPServer(); } /** * 启动服务 */ public static void runEPServer(){ //相关操作，需要系统启动时自行运行的代码 } } 若有多个代码段需要执行，可用@Order注解设置执行的顺序。 线程方式一：继承Thread类 定义子类继承Thread类。 子类中重写Thread类中的run方法。 创建Thread子类对象，即创建了线程对象。 调用线程对象start方法：启动线程，调用run方法。 注意点： 如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式。 run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统CPU调度决定。 想要启动多线程，必须调用start方法。 一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以上的异常 “IllegalThreadStateException”。 方式二：实现Runnable接口 定义子类，实现Runnable接口。 子类中重写Runnable接口中的run方法。 通过Thread类含参构造器创建线程对象。 将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。 调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。","categories":[{"name":"接口","slug":"接口","permalink":"https://luan-bx.github.io/categories/%E6%8E%A5%E5%8F%A3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/tags/Java/"},{"name":"Code","slug":"Code","permalink":"https://luan-bx.github.io/tags/Code/"},{"name":"接口","slug":"接口","permalink":"https://luan-bx.github.io/tags/%E6%8E%A5%E5%8F%A3/"},{"name":"继承","slug":"继承","permalink":"https://luan-bx.github.io/tags/%E7%BB%A7%E6%89%BF/"}]},{"title":"文件相关操作","slug":"javaCode/JavaCodeFile","date":"2022-07-10T08:19:45.000Z","updated":"2023-03-08T09:48:54.702Z","comments":true,"path":"2022/07/10/javacode/javacodefile/","link":"","permalink":"https://luan-bx.github.io/2022/07/10/javacode/javacodefile/","excerpt":"","text":"文件下载/* * 下载文件 */ public void downloadFile(String proname, String fileName, HttpServletResponse resp) { try { ProjectEntity projectEntity = projectMapping.getProjectByName(proname); ProductEntity productEntity = productMapping.getProductByProductId(projectEntity.getProProductId()); ProductOutsourceEntity productOutsourceEntity = productOutsourceMapping.getProductOutsourceByOutId(productEntity.getOutId()); //获取文件名 String strUrl = productOutsourceEntity.getFileUrl(); String filename = strUrl.substring(strUrl.lastIndexOf(\"/\")+1); filename = new String(filename.getBytes(\"iso8859-1\"),\"UTF-8\"); String path = strUrl; File file = new File(path); //如果文件不存在 if(!file.exists()){ log.info(\"下载文件不存在\"); } //解决下载文件时文件名乱码问题 byte[] fileNameBytes = filename.getBytes(StandardCharsets.UTF_8); filename = new String(fileNameBytes, 0, fileNameBytes.length, StandardCharsets.ISO_8859_1); resp.reset(); resp.setContentType(\"application/octet-stream\"); resp.setCharacterEncoding(\"utf-8\"); resp.setContentLength((int) file.length()); //设置响应头，控制浏览器下载该文件 resp.setHeader(\"content-disposition\", \"attachment;filename=\" + filename); try{ //读取要下载的文件，保存到文件输入流 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(path)); //创建输出流 OutputStream os = resp.getOutputStream(); //缓存区 byte[] buff = new byte[1024]; int i = 0; //循环将输入流中的内容读取到缓冲区中 while ((i = bis.read(buff)) != -1) { os.write(buff, 0, i); os.flush(); } //关闭 bis.close(); os.close(); } catch (IOException e) { log.error(\"{}\",e); log.info(\"下载失败\"); } log.info(\"下载成功\"); } catch (Exception e) { // TODO 自动生成的 catch 块 e.printStackTrace(); } } 文件夹下载 与文件下载不一样，需要先压缩再下载。本例子的服务器中文件URL已知，所以未用mapping层查询数据库，可根据需要加上。 Service:/* * 下载文件夹 */ public void downloadFile(String proname, String fileName, HttpServletResponse resp) { try { //下载后的文件 String name=Constants.FILEPATH + Constants.PROJECT + proname + \"/product/outsource\"+\".zip\"; zipUtil zc = new zipUtil(name); List&lt;String> list=new ArrayList&lt;>(); //服务器存储的URL list.add(Constants.FILEPATH + Constants.PROJECT + proname + \"/product/outsource\"); //可继续添加要一起压缩的文件夹或文件 //list.add(\"\"); String[] strings = new String[list.size()]; list.toArray(strings); File file=null; try { zc.compress(strings);//压缩 file=new File(name); downLoad.downloadZip(file,resp);//下载 } catch (IOException e) { e.printStackTrace(); }finally { if(file!=null){ file.delete();//把生成的压缩文件删除 } } } catch (Exception e) { // TODO 自动生成的 catch 块 e.printStackTrace(); } } Utile:建立两个工具包 （1）压缩文件夹 public class ZipCompressorUtil { static final int BUFFER = 8192; /** * 压缩的文件夹 */ private File zipFile1111; public ZipCompressorUtil(String pathName) { zipFile1111 = new File(pathName); } /** * 遍历需要压缩文件集合 * @param pathName * @throws IOException */ public void compress(String... pathName) throws IOException { ZipOutputStream out =null; FileOutputStream fileOutputStream=null; CheckedOutputStream cos=null; try { fileOutputStream = new FileOutputStream(zipFile1111); cos = new CheckedOutputStream(fileOutputStream,new CRC32()); out = new ZipOutputStream(cos); String basedir = \"\"; for (int i=0;i&lt;pathName.length;i++){ compress(new File(pathName[i]), out, basedir); } } catch (Exception e) { throw new RuntimeException(e); }finally { if(out!=null){ out.close(); } if(fileOutputStream!=null){ fileOutputStream.close(); } if(cos!=null){ cos.close(); } } } /** * 压缩 * @param file * @param out * @param basedir */ private void compress(File file, ZipOutputStream out, String basedir) throws IOException { // 判断是目录还是文件 if (file.isDirectory()) { this.compressDirectory(file, out, basedir); } else { this.compressFile(file, out, basedir); } } /** * 压缩一个目录 * */ private void compressDirectory(File dir, ZipOutputStream out, String basedir) throws IOException { if (!dir.exists()){ return; } File[] files = dir.listFiles(); for (int i = 0; i &lt; files.length; i++) { // 递归 compress(files[i], out, basedir + dir.getName() + \"/\"); } } /** * 压缩一个文件 * * */ private void compressFile(File file, ZipOutputStream out, String basedir) throws IOException { if (!file.exists()) { return; } BufferedInputStream bis =null; try { bis = new BufferedInputStream(new FileInputStream(file)); ZipEntry entry = new ZipEntry(basedir + file.getName()); out.putNextEntry(entry); int count; byte[] data = new byte[BUFFER]; while ((count = bis.read(data, 0, BUFFER)) != -1) { out.write(data, 0, count); } } catch (Exception e) { throw new RuntimeException(e); }finally { if(bis!=null){ bis.close(); } } } } （2）下载文件夹 public class DownLoadUtil { /** * 下载压缩包 * @param file * @param response * @return */ public static HttpServletResponse downloadZip(File file,HttpServletResponse response) { InputStream fis = null; OutputStream toClient = null; try { // 以流的形式下载文件。 fis = new BufferedInputStream(new FileInputStream(file.getPath())); byte[] buffer = new byte[fis.available()]; fis.read(buffer); // 清空response response.reset(); toClient = new BufferedOutputStream(response.getOutputStream()); response.setContentType(\"application/octet-stream\"); //如果输出的是中文名的文件，在此处就要用URLEncoder.encode方法进行处理 response.setHeader(\"Content-Disposition\", \"attachment;filename=\" + URLEncoder.encode(file.getName(), \"UTF-8\")); toClient.write(buffer); toClient.flush(); } catch (IOException ex) { ex.printStackTrace(); }finally{ try { File f = new File(file.getPath()); f.delete(); if(fis!=null){ fis.close(); } if(toClient!=null){ toClient.close(); } } catch (Exception e) { e.printStackTrace(); } } return response; } } 文件删除/** * 删除文件 * @param fileName * @return */ public static boolean deleteFile(String fileName) { File file = new File(fileName); // 如果文件路径只有单个文件 if (file.exists() &amp;&amp; file.isFile()) { if (file.delete()) { System.out.println(\"删除文件\" + fileName + \"成功！\"); return true; } else { System.out.println(\"删除文件\" + fileName + \"失败！\"); return false; } } else { System.out.println(fileName + \"不存在！\"); return false; } } 文件夹删除/** * 删除文件夹,里面用到了删除文件的函数，把上面文件删除的函数也引进来 */ public static boolean deleteAllFile(String dir) { // 如果dir不以文件分隔符结尾，自动添加文件分隔符 if (!dir.endsWith(File.separator)) dir = dir + File.separator; File dirFile = new File(dir); // 如果dir对应的文件不存在，或者不是一个目录，则退出 if ((!dirFile.exists()) || (!dirFile.isDirectory())) { System.out.println(\"删除文件夹失败：\" + dir + \"不存在！\"); return false; } boolean flag = true; // 删除文件夹中的所有文件包括子文件夹 File[] files = dirFile.listFiles(); for (int i = 0; i &lt; files.length; i++) { // 删除子文件 if (files[i].isFile()) { flag = deleteFile(files[i].getAbsolutePath()); if (!flag) break; } // 删除子文件夹 else if (files[i].isDirectory()) { flag = deleteAllFile(files[i].getAbsolutePath()); if (!flag) break; } } if (!flag) { System.out.println(\"删除文件夹失败！\"); return false; } // 删除当前文件夹 if (dirFile.delete()) { System.out.println(\"删除文件夹\" + dir + \"成功！\"); return true; } else { return false; } } 文件上传（文件夹需自行压缩）public String insertProductOutsource(ProductOutsourceEntity productOutsourceEntity,String proname, List&lt;MultipartFile> file,HttpServletRequest req) { // 判断参数有没有效 if(productOutsourceEntity == null) { return Constants.FAILCODE; } try { //获取当前时间 Calendar calendar = Calendar.getInstance(); String nowTime = (new SimpleDateFormat(\"yyyy-MM-dd_HH-mm-ss\").format(calendar.getTime())); // 创建文件夹,文件名称与提交时间关联 ProjectEntity projectEntity = projectMapping.getProjectByName(proname); String poId = signMapping.getSignById(projectEntity.getProSignId()).getPoId(); String docPath = Constants.FILEPATH + Constants.PROJECT + proname + \"/product/\" + poId + \"-outsource/\"+nowTime+\"/\"; File localPath = new File(docPath); if (!localPath.exists()) { // 获得文件目录，判断目录是否存在，不存在就新建一个 localPath.mkdirs(); } //存文件 for (MultipartFile f : file) { String filename = f.getOriginalFilename(); String path = docPath +filename; File filePath = new File(path); BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(filePath));// 保存文件到目录下 out.write(f.getBytes());//在创建好的文件中写入f.getBytes() out.flush(); out.close(); productOutsourceEntity.setFileUrl(path); log.info(\"数据库中FileUrl储存\"+productOutsourceEntity.getFileUrl()); } productOutsourceMapping.insert(productOutsourceEntity); return Constants.SUCCESSCODE; } catch (Exception e) { // TODO: handle exception e.printStackTrace(); req.setAttribute(\"error\", \"添加文件失败\"); return Constants.FAILCODE; } }","categories":[{"name":"文件","slug":"文件","permalink":"https://luan-bx.github.io/categories/%E6%96%87%E4%BB%B6/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/tags/Java/"},{"name":"Code","slug":"Code","permalink":"https://luan-bx.github.io/tags/Code/"}]},{"title":"企业项目管理系统服务端","slug":"pms","date":"2022-07-05T08:22:49.000Z","updated":"2023-03-17T07:16:00.397Z","comments":true,"path":"2022/07/05/pms/","link":"","permalink":"https://luan-bx.github.io/2022/07/05/pms/","excerpt":"","text":"企业项目管理系统服务端注册 1.1用户名-密码注册 1.11注册界面接收以下信息： 用户名、密码、手机号、邮箱 1.12用户名-密码注册逻辑： 接收前端用户注册填写的个人信息：用户名、手机号、邮箱，服务器请求数据库，查看以上三个字段是否有记录，来判断是否为新用户。 （1）如果是新用户，则继续填写公司相关信息： gender;icon;number;isAdmin;postId;postName;departmentId;departmentName。 controller层：接收这些字段，放入UserEntity。 service层：再UserMapping.insert(UserEntity)插入一个用户。 （2）如果第三方微信注册过，则提示用户名？手机号？邮箱？“已经注册过，正在进行相关绑定”。 controller层接口：接收上述字段，放入UserEntity。 service层接口：同时先通过UUID生成OpenID，通过当前手机号查询到数据库的users表的id，调用UserMapping.updateFromUser进行数据库的更新 1.13用户名-密码注册流程： 1.14controller层接口： 1.15service层接口： 1.2第三方登录注册 1.21注册界面接收以下信息： Nick_name、性别、头像地址url、地点、手机号、邮件、openid 1.22微信扫码注册逻辑： 扫码后，授权Nick_name、性别、头像地址url、 地点，返回的信息放入WxUsersEntity。弹框提示绑定手机号、邮件，再放入UsersEntity。通过获得授权接收的手机号，服务器请求数据库，查看手机号、邮箱字段是否有记录，来判断是否为新用户。 （1）如果是新用户，继续填写公司相关信息： gender;icon;number;isAdmin;postId;postName;departmentId;departmentName，放入UsersEntity。 controller层：接收WxUsersEntity，icon字段用微信头像，gender、phone，都放入UsersEntity中。 service层：先去微信网关拿到wxOpenId放入WxUsersEntity，插入UserMapping.insert(UserEntity)，UsersMapping.getUserId()通过phone查询users表，返回users_id放入WxUsersEntity，进行插入再WxUsersMapping.insert()插入一个用户。 （2）如果用户名-密码注册过，则绑定用户名密码注册的表单： controller层接口：接收WxUsersEntity字段 。 service层：先去微信网关拿到wxOpenId放入WxUsersEntity。WxUsersMapping.getUserId()通过phone查询users表，返回users_id存入WxUsersEntity，再插入WxUsersMapping.insert()。 再次扫码获取授权后可直接登录。 1.23第三方登录注册流程： 同1.13模式，可根据以上逻辑进行判断，不再叙述 1.24controller层接口： 1.25service层接口： 登录2.1用户名-密码登录 2.11登录界面发送以下信息： 用户名、密码、手机号、邮箱 2.12用户名密码登录逻辑： 接收前端用户登录填写的个人信息：用户名或手机号、密码，服务器请求数据库，查看用户名或手机号字段是否有记录，来判断是否为新用户。 （1）如果用户名为空，继续判断手机号，如果手机号也为空，则是新用户，log“账号不存在，请先注册” （2）如果用户名或手机号有一项不为空，则继续判断密码。将接收到的phone和UserName输入MD5方法加密，与数据库请求之前存过的密码是否一致，若相同，则进入主页，log“登录成功”，写Redis。否则log“登录失败，用户名或密码错误” 2.13controller层接口： 2.14service层接口： Redis后面再设置 2.2第三方登录 2.21登录界面发送以下信息： Nick_name、性别、头像地址url、地点、openid 2.22第三方登录逻辑： 接收前端第三方登录授权的个人信息：openid，服务器请求数据库，查看openid字段是否有记录，来判断是否为新用户。 （1）如果数据库openid与接收到的openid一致，则进入主页，log“登录成功”，写Redis。 （2）否则是新用户，log“账号不存在，请先注册” 2.23 controller层接口： 2.24 service层接口： 本地测试（注册、登录）3.1 修改注册逻辑： 通过“用户名、手机号、邮箱”查用户名-密码注册表单为空时，进行微信注册表单绑定，如果表单绑定成功，可直接登录。如果不成功，则进行添加新用户。 3.2 本地测试 http://localhost/Register?userName=test01&amp;password=123456&amp;phone=123456789&amp;email=123@qq.com&amp;gender=0&amp;number=123456&amp;is_admin=1&amp;post_id=123&amp;department_id=123 第一次 注册 第二次 重复注册 第三次 只更改用户名注册 第四次 只更改用户名和手机号注册 第五次 只更改用户名、手机号和邮箱注册 第六次 只更改用户名、手机号、邮箱工号和注册 3.3 微信·开放平台——网站应用开发 3.31网址 https://open.weixin.qq.com/cgi-bin/frame?t=home/web_tmpl&amp;lang=zh_CN 3.32功能 用户可使用微信帐号快速登录你的网站，并可在用户授权后，获取用户基本信息，包括头像、昵称、性别、地区。 3.33 账号 账号：&#108;&#x75;&#x61;&#x6e;&#98;&#x61;&#x69;&#120;&#x69;&#97;&#x6e;&#x67;&#x40;&#49;&#x36;&#51;&#x2e;&#99;&#x6f;&#x6d; 密码：首字母大写 3.34 申请流程 在微信开放平台注册开发者帐号，并拥有一个已审核通过的网站应用，并获得相应的AppID和AppSecret 3.35时序流程图 用户点击网站微信登陆图标。 网站带上AppID和AppSecret和回调域名参数请求微信OAuth2.0授权登陆。 第二步通过后，微信返回二维码供用户扫码。 用户扫码确定授权。 微信带上code参数回调java后端相关接口。 java后端获取到code后，在带上带上AppID和AppSecret和code再去调微信接口。 获取access_token后就可以解析用户的一些基本信息，比如：微信用户头像、用户名、性别、城市等一些基本参数。 具体接口参数说明看官方文档。 3.36 接口 相关资料已备齐，等平台申请通过再测试 3.4 注册信息下拉选项（动态） 3.41 功能 “岗位、权限、部门”下拉选项，动态更新，使高级管理员更改三类选项时，注册界面的下拉选项可直接更新。 3.42 controller层接口： 3.43 service层接口： 前后端测试（注册）4.1 页面整合 4.11文件存储规则 在resource&#x2F;static&#x2F;html下面放html文件 #应用名称 spring.application.name&#x3D;test #使用的端口，默认就是8080 server.port&#x3D;8080#视图解析 spring.mvc.view.prefix&#x3D;&#x2F;html&#x2F;spring.mvc.view.suffix&#x3D;.html 前缀是&#x2F;html&#x2F;，不是什么&#x2F;static&#x2F;html&#x2F;，也不是什么classpath:&#x2F;static&#x2F;html。 注释必须要独占一行。 springboot中默认resources中static文件夹存放静态资源，如js文件、css文件、图片等等。templates文件夹中存放html页面。 4.12 返回页面（注释） 在controller中可直接返回html文件名，示例：return “index”;不能在service层里返回页面 注意Controller上要用@Controller，不能用@RestController或@ResponseBody，这2个注解是把return返回的字符串作为json直接返回给浏览器。 @RestController &#x3D; @ResponseBody + @Controller 在浏览器地址栏输入 ip:port&#x2F;html&#x2F;xxx.html 可直接访问对应的页面。 使用普通的html有一个很大的问题：不好取controller传递的数据。 使用jsp作为视图时，jsp中可以写java代码，可以用EL表达式或request.getXxx()获取数据，普通html文件中不能写java代码，不好取数据。 前端页面显示后端参数中的数据：${xxx} 4.13 配置YAML 在YAML文件的顶级映射不允许使用重复键，出现了两个spring，因为它们必须是unique according to the specification。 在显式YAML文档开头出现的指令指示符”—” 也可以保留一个spring，datasource和thymeleaf对齐 4.2 前后端测试 4.21数据转换 测试时，发现前后端定义的数据格式不一致，导致存储失败。 解决:设置实体层UserEntityVo，且均以string格式传过来，在接收时先进行数据格式转换处理，再放到方法体里。格式转换按照数据库设置的格式来，对应UserEntity. 一、自行编码如string格式传来文字，而数据库储存int格式，则进行 if(userEntityVo.getGender().equals(\"男\")) { userEntity.setGender(2); } 把“男”赋值“2”进行存储。 二、直接转格式（注意静态动态，不可在controller直接把参数传进去）Controller层： Service层： 4.22 测试测试成功，未来得及截图，因为还想优化一下，等师弟那边相对文件路径改好再测一遍。 项目请求、签订、状态5.1项目请求 5.11项目请求逻辑： 项目请求界面，填好信息，点击“提交”，插入一个项目请求，并且提供两种查询项目方法： 通过名称查询 通过公司名称查询 5.12controller层接口： 项目请求界面，填好信息，点击“提交”，插入一个项目请求 根据项目名称查询项目信息 根据客户公司名称查询项目信息 5.13service层接口： 5.2项目签订 5.21项目签订逻辑： 项目签订界面，填好信息，点击“提交”，插入一个签订记录。根据po查询签订记录，根据合同号查询签订记录，根据公司项目编号查询签订记录，根据客户公司代码查询签订记录，根据交货日期查询签订记录 5.22controller层接口： 项目签订界面，填好信息，点击“提交”，插入一个签订记录 根据po查询签订记录 根据合同号查询签订记录 根据公司项目编号查询签订记录 根据客户公司代码查询签订记录 根据交货日期查询签订记录 5.23service层接口： 5.3项目状态 5.31项目状态逻辑： 插入一条状态记录,根据状态描述查询id,修改状态描述。 修改状态分两种： pass，状态递进一位； noPass，状态递减一位。 5.32controller层接口： 插入一条状态记录 根据状态描述查询id 修改状态,通过 修改状态,不通过 5.33service层接口： 项目设计6.1项目设计 6.11项目设计逻辑： 插入一条设计记录 6.12controller层接口： 6.13service层接口： 6.2项目-软件设计 6.21项目软件设计： 插入一条软件设计记录 6.22controller层接口： 插入一条软件设计记录 6.23service层接口： 6.24文件上传测试： 在本地文件夹和数据库中均储存成功 (1)本地文件夹: (2)数据库: 6.25文件上传注意： 参数保持一致 (1)controller 前端html: (2)controller创建多个value &#x3D; “”与html中name一一对应 6.3项目-电气设计 6.31项目电气设计逻辑： 插入一条电气设计记录 6.32controller层接口： 6.33service层接口： 6.34文件上传测试： 在本地文件夹和数据库中均储存成功 (1)本地文件夹: (2)数据库: 6.4项目-机械设计师 6.41项目机械设计师逻辑： 插入一条机械设计师记录 6.42controller层接口： 6.43service层接口： 6.44文件上传测试： 在本地文件夹和数据库中均储存成功 (1)本地文件夹: (2)数据库: 6.5项目-设计关系表 6.51项目设计关系表逻辑： 插入一条设计关系表记录，根据项目公司内部项目表好pro_id查询项目机械设计信息 6.52controller层接口： 插入一条设计关系表记录 根据项目公司内部项目表好pro_id查询项目机械设计信息 6.53service层接口： 项目生产7.1项目生产 7.11项目生产逻辑： 插入一条生产记录 7.12controller层接口： 7.13service层接口： 7.2项目-外协 7.21项目生产外协逻辑： 插入一条外协记录 7.22controller层接口： 7.23service层接口： 7.24文件上传测试 7.3项目-零件加工 7.31项目生产零件加工逻辑： 插入一条零件加工记录 7.32controller层接口： 7.33service层接口： 7.4项目-采购 7.41项目生产采购逻辑： 插入一条采购记录 7.42controller层接口： 7.43service层接口： 项目-用户关联、项目装配表8.1项目-用户关联 8.11项目-用户关联逻辑： 插入一条项目-用户关系记录，根据userId,查询相关的proId，根据proId, 查询相关的userId 8.12controller层接口： 插入一条项目-用户关系记录 根据userId,查询相关的proId 根据proId, 查询相关的userId 8.13service层接口： 8.2项目装配表 8.21项目装配表逻辑： 插入一条装配记录 8.22controller层接口： 8.23service层接口：","categories":[{"name":"开发笔记","slug":"开发笔记","permalink":"https://luan-bx.github.io/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/tags/Java/"},{"name":"开发笔记","slug":"开发笔记","permalink":"https://luan-bx.github.io/tags/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"}]},{"title":"Java（十一）IO流","slug":"javaNotes/java11","date":"2022-06-30T15:28:46.000Z","updated":"2023-03-08T07:14:20.985Z","comments":true,"path":"2022/06/30/javanotes/java11/","link":"","permalink":"https://luan-bx.github.io/2022/06/30/javanotes/java11/","excerpt":"","text":"File类说明 java.io.File类：文件和文件目录路径的抽象表示形式，与平台无关 File 能新建、删除、重命名文件和目录，但 File 不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入&#x2F;输出流。 想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录。 File对象可以作为参数传递给流的构造器 构造器public File(String pathname) 以pathname为路径创建File对象，可以是绝对路径或者相对路径，相对路径的当前路径在系统属性user.dir中存储。 public File(String parent,String child) 以parent为父路径，child为子路径创建File对象。 public File(File parent,String child) 根据一个父File对象和子文件路径创建File对象 路径分隔符路径分隔符和系统有关： windows和DOS系统默认使用“\\”来表示 UNIX和URL使用“&#x2F;”来表示 File类提供了一个常量解决分隔符统一： public static final String separator。根据操作系统，动态的提供分隔符 File file2 &#x3D; new File(“d:” + File.separator + “atguigu” + File.separator + “info.txt”); 方法File类的获取功能 public String getAbsolutePath()：获取绝对路径 public String getPath() ：获取路径 public String getName() ：获取名称 public String getParent()：获取上层文件目录路径。若无，返回null public long length() ：获取文件长度（即：字节数）。不能获取目录的长度。 public long lastModified() ：获取最后一次的修改时间，毫秒值 public String[] list() ：获取指定目录下的所有文件或者文件目录的名称数组 public File[] listFiles() ：获取指定目录下的所有文件或者文件目录的File数组 File类的重命名功能 public boolean renameTo(File dest):把文件重命名为指定的文件路径 File类的判断功能 public boolean isDirectory()：判断是否是文件目录 public boolean isFile() ：判断是否是文件 public boolean exists() ：判断是否存在 public boolean canRead() ：判断是否可读 public boolean canWrite() ：判断是否可写 public boolean isHidden() ：判断是否隐藏 File类的创建功能 public boolean createNewFile() ：创建文件。若文件存在，则不创建，返回false public boolean mkdir() ：创建文件目录。如果此文件目录存在，就不创建了。 如果此文件目录的上层目录不存在，也不创建。 public boolean mkdirs() ：创建文件目录。如果上层文件目录不存在，一并创建 注意事项：如果你创建文件或者文件目录没有写盘符路径，那么，默认在项目路径下。 File类的删除功能 public boolean delete()：删除文件或者文件夹 删除注意事项：Java中的删除不走回收站。 要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录 IO流Google I&#x2F;O 寓为“开放中创新” (Innovation in the Open) Input&#x2F;Output 二进制1,0 分类按操作数据单位不同分为：字节流(8 bit)，字符流(16 bit) 按数据流的流向不同分为：输入流，输出流 按流的角色的不同分为：节点流，处理流 Java的IO流共涉及40多个类，实际上非常规则，都是从如下4个抽象基类派生的。 由这四个类派生出来的子类名称都是以其父类名作为子类名后缀 节点流和处理流节点流：直接从数据源或目的地读写数据 处理流：不直接连接到数据源或目的地，而是“连接”在已存在的流（节点流或处理流）之上，通过对数据的处理为程序提供更为强大的读写功能。 InputStream &amp; ReaderInputStream 和Reader 是所有输入流的基类。 InputStream（典型实现：FileInputStream） int read() int read(byte[] b) int read(byte[] b, int off, int len) Reader（典型实现：FileReader） int read() int read(char [] c) int read(char [] c, int off, int len) 程序中打开的文件IO 资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该显式关闭文件IO 资源。 OutputStream &amp; Writervoid write(int b/int c); void write(byte[] b/char[] cbuf); void write(byte[] b/char[] buff, int off, int len); void flush(); void close(); 需要先刷新，再关闭此流 因为字符流以字符作为操作单位，所以Writer可以用字符串来替换字符数组 void write(String str); void write(String str, int off, int len); read的理解Java 下 IO 中 FileReader 和 FileInputStream 分别是以字符和字节的形式来完成数据的读取的，然而返回值确是 int 类型的数据，这样做的核心目的只是要取到到一个 int 类型下的 -1 来表示数据流的末尾。为什么要这样做？又是怎么实现的呢？ 首先看FileReader ： FileReader fr = new FileReader(\"src.txt\"); int ch = fr.read(); 如上面的代码，FileReader 的 read 方法返回值是一个 int 类型的变量来接收的，然而 read 方法在实际中却是以字符形式来进行数据的读取的。通过上面的基本数据类型的取值范围我们能发现 char 类型数据的取值范围为 0 ~ 65535 ，也就是说 char 类型数据是取不到负值的；int 类型数据的取值范围为 -2147483648 ~ 2147483647 ，可以取到负值；同时 int 的取值范围又包含 char 的取值范围，这就为使用 int 作为返回值类型提供了可能，因为流需要一个特殊的值来表示流末尾，这个值不应该在 char 的取值范围内，如果使用 char 取值范围内的值作为流末尾标志，那么这个值同样有可能出现在数据流中间作为数据来传输，流在读到这个值的时候会认为已经到达流末尾，后面未读取的数据将被截断。所以 Java 中选择了使用 -1 来作为流末尾，这个值不在 char 的取值范围内，所以不存在数据截断，然而 -1 又在 int 的取值范围内，同时 int 的取值范围包含 char 的取值范围，所以 FileReader 下 read 方法返回的 char 类型数据直接转为了 int 类型。 再看FileInputStream ： FileInputStream fis = new FileInputStream(\"src.txt\"); int b = fis.read(); 同理FileInputStream 也需要一个自己取不到的值来作为流末尾的标志，Java 同样使用 -1 来作为字节流的流末尾，从上面基本数据类型的取值范围我们可以看到 byte 的取值范围为 -128 ~ 127 ，这就意味走着 byte 可以取到 -1 ，如果把 -1 直接当作 int 作为流末尾，那么就无法区分这个读到的结果是流末尾还是流中的数据了，那么 Java 是如何实现取值 -1 的呢？在 Java 内部，Java 通过高位补 0 来实现数据从 byte 到 int 的转换，举个例子： -1 在 byte 类型和 int 类型中都可以取到，-1 在 byte 类型下的二进制存储形式为 11111111 ，然而使用 read 方法的时候，Java 内部将 byte 的高位补 0 将 byte 转为 int 类型，所以 byte 类型的 -1 在 int 类型下的二进制存储形式为 00000000 00000000 00000000 11111111，对应的 int 值为 255，通过高位补 0 ，所有 byte 类型的负数都转为了正数。然而在使用这些读到的 byte 数据时，只要将这些数据从 int 强转回 byte 即可得到原有的数据。所以就可以使用 -1 来作为流末尾的标志，因为 Java 内部将 byte 的负数通过高位补 0 将其转换为了正数。 节点流（或文件流） 可以省略new File，因为FileReader会自动封装 1024是因为通常设置10位二进制 定义文件路径时，注意：可以用“&#x2F;”或者“\\”。 写入一个文件时，如果使用构造器FileOutputStream(file)，则目录下有同名文件将被覆盖。 如果使用FileOutputStream(file,true)，则同名文件不会被覆盖，在文件内容末尾追加内容。 在读取文件时，必须保证该文件已存在，否则报异常。 字节流操作字节，比如：.mp3，.avi，.rmvb，mp4，.jpg，.doc，.ppt 字符流操作字符，只能操作普通文本文件。最常见的文本文件：.txt，.java，.c，.cpp 等语言的源代码。尤其注意.doc,excel,ppt这些不是文本文件。 可以用stream复制文本，但是不能中途查看会乱码,其他操作不可以. 缓冲流 为了提高数据读写的速度，Java API提供了带缓冲功能的流类，在使用这些流类时，会创建一个内部缓冲区数组，缺省使用8192个字节(8Kb)的缓冲区。 缓冲流要“套接”在相应的节点流之上，根据数据操作单位可以把缓冲流分为： BufferedInputStream 和 BufferedOutputStream BufferedReader 和 BufferedWriter 当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区 当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从文件中读取8192个(8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中读取下一个8192个字节数组。 向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满， BufferedOutputStream才会把缓冲区中的数据一次性写到文件里。使用方法flush()可以强制将缓冲区的内容全部写入输出流 关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外层流也会相应关闭内层节点流 flush()方法的使用：手动将buffer中内容写入文件 如果是带缓冲区的流对象的close()方法，不但会关闭流，还会在关闭流之前刷新缓冲区，关闭后不能再写出 转换流转换流提供了在字节流和字符流之间的转换 Java API提供了两个转换流： InputStreamReader：将InputStream转换为Reader OutputStreamWriter：将Writer转换为OutputStream 字节流中的数据都是字符时，转成字符流操作更高效。 很多时候我们使用转换流来处理文件乱码问题。实现编码和解码的功能 6.输入、输出流System.in和System.out分别代表了系统标准的输入和输出设备 默认输入设备是：键盘，输出设备是：显示器 System.in的类型是InputStream System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream 的子类 重定向：通过System类的setIn，setOut方法对默认设备进行改变。 public static void setIn(InputStream in) public static void setOut(PrintStream out) 打印流实现将基本数据类型的数据格式转化为字符串输出 打印流：PrintStream和PrintWriter 提供了一系列重载的print()和println()方法，用于多种数据类型的输出 PrintStream和PrintWriter的输出不会抛出IOException异常 PrintStream和PrintWriter有自动flush功能 PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。 在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。 System.out返回的是PrintStream的实例 数据流 对象流ObjectInputStream和OjbectOutputSteam 用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。 序列化：用ObjectOutputStream类保存基本类型数据或对象的机制 反序列化：用ObjectInputStream类读取基本类型数据或对象的机制 ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量 对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。&#x2F;&#x2F;当其它程序获取了这种二进制流，就可以恢复成原来的Java对象 序列化的好处在于可将任何实现了Serializable接口的对象转化为字节数据，使其在保存和传输时可被还原 序列化是RMI（Remote Method Invoke – 远程方法调用）过程的参数和返回值都必须实现的机制，而RMI 是JavaEE 的基础。因此序列化机制是JavaEE 平台的基础 如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。 否则，会抛出NotSerializableException异常 Serializable Externalizable 凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量： private static final long serialVersionUID; serialVersionUID用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象 进行版本控制，有关各版本反序列化时是否兼容。 如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自 动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。故建议， 显式声明。 简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常(InvalidCastException)。防止序列化后，该类被修改了，反序列找不到类了。 path","categories":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/tags/Java/"},{"name":"Java笔记","slug":"Java笔记","permalink":"https://luan-bx.github.io/tags/Java%E7%AC%94%E8%AE%B0/"}]},{"title":"TCP收发测试","slug":"javaCode/JavaCodeTCP","date":"2022-06-20T13:06:39.000Z","updated":"2023-03-08T09:57:48.818Z","comments":true,"path":"2022/06/20/javacode/javacodetcp/","link":"","permalink":"https://luan-bx.github.io/2022/06/20/javacode/javacodetcp/","excerpt":"","text":"接收import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.InetSocketAddress; import java.net.ServerSocket; import java.net.Socket; public class Tcp { /* * TCP接收 */ public static void main(String[] args) throws Exception{ try { System.out.println(\"12345678\"); int port = 8081; //创建服务器端的Socket对象(ServerSocket) ServerSocket serverSocket = new ServerSocket(port); //serverSocket.bind(new InetSocketAddress(port)); while (true) { //监听客户端连接，返回一个Socket对象 Socket socket = serverSocket.accept(); //设置阻塞的超时时间 //socket.setSoTimeout(5000); //输出流 OutputStream output = socket.getOutputStream(); //获取输入流，读数据，并把数据显示在控制台 InputStream input = socket.getInputStream(); //打印连接IP String IP = serverSocket.getInetAddress().getHostAddress(); System.out.println(IP + \"......connected\"); int i = 0; while (socket.isConnected()) { byte[] b = new byte[1024]; int len = input.read(b) + 1; // 把一个字节数组str从0取到len，取出来之后转换成String类型 String str = new String(b, 0, len); System.out.println(\"数据为\" + str); output.write(str.getBytes()); //output.write(\"okok\".getBytes());//可删 i++; if(i > 10) { break; } } socket.close(); //serverSocket.close(); } } catch (IOException e) { e.printStackTrace(); } } } 发送import java.io.BufferedReader; import java.io.InputStream; import java.io.InputStreamReader; import java.io.OutputStream; import java.net.InetAddress; import java.net.Socket; import java.net.UnknownHostException; /* * 客户端向服务器发送数据 */ public class TcpSend { public static void main(String[] args) throws Exception { //接受控制台数据的输入流 BufferedReader buff=null; //定义保存服务器地址的对象【String】 InetAddress serverip=null; //定义连接服务器的端口号 int serverport=38700; //定义创建客户端对象的Socket Socket client=null; //定义发送信息的输出流对象 OutputStream out=null; //定义保存被发送的数据 String info=null; //返回包含有本机IP地址的InetAddress对象,花生壳透传公网IP serverip=InetAddress.getByName(\"454585x8l0.qicp.vip\"); System.out.println(\"接收方： \" + serverip.getHostName()); System.out.println(\"接收IP： \" + serverip.getHostAddress()); //Socket(InetAddress address,int prot)---创建流套接字并将其连接到指定IP地址的指定端口号 client=new Socket(serverip,serverport); // getOutputStream()---返回客户端的输出流。【与服务器的输入流连接】 out=client.getOutputStream(); for(int i=0;i&lt;5;i++) { System.out.println(\"请输入发送的数据\"); buff=new BufferedReader(new InputStreamReader(System.in)); info=buff.readLine(); out.write(info.getBytes()); } out.close(); buff.close(); client.close(); } }","categories":[{"name":"TCP","slug":"TCP","permalink":"https://luan-bx.github.io/categories/TCP/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/tags/Java/"},{"name":"Code","slug":"Code","permalink":"https://luan-bx.github.io/tags/Code/"},{"name":"TCP","slug":"TCP","permalink":"https://luan-bx.github.io/tags/TCP/"}]},{"title":"Java（十）集合","slug":"javaNotes/java10","date":"2022-06-17T11:56:09.000Z","updated":"2023-03-29T15:01:33.263Z","comments":true,"path":"2022/06/17/javanotes/java10/","link":"","permalink":"https://luan-bx.github.io/2022/06/17/javanotes/java10/","excerpt":"","text":"概述对比数组数组在内存存储方面的特点：（所以安全） 数组初始化以后，长度就确定了。 数组声明的类型，就决定了进行元素初始化时的类型 数组在存储数据方面的弊端： 数组初始化以后，长度就不可变了，不便于扩展 数组中提供的属性和方法少，不便于进行添加、删除、插入等操作，且效率不高。 同时无法直接获取存储元素的个数 数组存储的数据是有序的、可以重复的。—-&gt;存储数据的特点单一 Java 集合类可以用于存储数量不等的多个对象，还可用于保存具有映射关系的关联数组。 接口Java 集合可分为Collection 和Map 两种体系 Collection接口：单列数据，定义了存取一组对象的方法的集合 List：元素有序、可重复的集合 Set：元素无序、不可重复的集合 Map接口：双列数据，保存具有映射关系“key-value对”的集合 接口树 Collection接口 Collection 接口是List、Set 和Queue 接口的父接口 JDK不提供此接口的任何直接实现，而是提供更具体的子接口(如：Set和List) 实现。 在Java5 之前，Java 集合会丢失容器中所有对象的数据类型，把所有对象都当成Object 类型处理； 从JDK 5.0 增加了泛型以后，Java 集合可以记住容器中对象的数据类型。 方法： 添加 add(Object obj) addAll(Collection coll) 获取有效元素的个数 int size() 清空集合 void clear() 是否是空集合 boolean isEmpty() 是否包含某个元素 boolean contains(Object obj)：是通过元素的equals方法来判断是否是同一个对象 boolean containsAll(Collection c)：调用元素的equals方法来。拿两个集合的元素挨个比较。 删除 boolean remove(Object obj) ：通过元素的equals方法判断是否是要删除的那个元素。``` 只会删除找到的第一个元素 ```java boolean removeAll(Collection coll)：取当前集合的差集 取两个集合的交集 boolean retainAll(Collection c)：把交集的结果存在当前集合中，不影响c 集合是否相等 boolean equals(Object obj) 转成对象数组 Object[] toArray() 获取集合对象的哈希值 hashCode() 遍历 iterator()：返回迭代器对象，用于集合遍历 Iterator迭代器接口Iterator接口 Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。 Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。 Iterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建Iterator 对象，则必须有一个被迭代的集合。 集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。 遍历集合元素在调用xxxxx.next()方法之前必须要调用xxxxx.hasNext()进行检测。若不调用，且下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常。 remove（）方法 注意： Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法。 如果还未调用next()或在上一次调用next 方法之后已经调用了remove 方法，再调用remove都会报IllegalStateException。 foreach 循环遍历集合元素 Collection —— List鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组 List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。 List容器中的元素可以根据序号存取容器中的元素。 JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。 List接口方法除了从Collection集合继承的方法外，List 集合里添加了根据索引来操作集合元素的方法。 void add(int index, Object ele):在index位置插入ele元素 boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来 Object get(int index):获取指定index位置的元素 int indexOf(Object obj):返回obj在集合中首次出现的位置 int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置 Object remove(int index):移除指定index位置的元素，并返回此元素 Object set(int index, Object ele):设置指定index位置的元素为ele List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合 实现类1：ArrayListArrayList 是 List 接口的典型实现类、主要实现类 本质上，ArrayList是对象引用的一个”变长”数组 ArrayList的JDK1.8之前与之后的实现区别？ JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组 JDK1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元素时 再创建一个始容量为10的数组 删除的是对应的下角标 改为：list.remove(new Integer(2)) 装箱删除的是对象 Java List 的 remove 方法有两个重载，一个接收 int 型参数（通过下标删除），一个接收 Object 型参数（通过元素删除）。对于List,如果传入一个整型字面值，会删除对应下标处的元素 实现类2：LinkedList对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高 新增方法： void addFirst(Object obj) void addLast(Object obj) Object getFirst() Object getLast() Object removeFirst() Object removeLast() LinkedList：双向链表，内部没有声明数组，而是定义了Node类型的first和last，用于记录首末元素。同时，定义内部类Node，作为LinkedList中保存数据的基本结构。Node除了保存数据，还定义了两个变量： prev变量记录前一个元素的位置 next变量记录下一个元素的位置 实现类3：VectorVector 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的。 在各种list中，最好把ArrayList作为缺省选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用。 list总结 Collection —— SetSet接口是Collection的子接口，set接口没有提供额外的方法 Set 集合不允许包含相同的元素，如果两个相同的元素加入同个Set 集合，则添加操作失败 Set 判断两个对象是否相同不是使用&#x3D;&#x3D; 运算符，而是根据equals() 方法 实现类1:HashSetHashSet 是Set 接口的典型实现，大多数时候使用Set 集合时都使用这个实现类。 HashSet 按Hash 算法来存储集合中的元素，因此具有很好的存取、查找、删除性能。 HashSet 具有以下特点： 不能保证元素的排列顺序 HashSet 不是线程安全的 集合元素可以是null HashSet 集合判断两个元素相等的标准：两个对象通过hashCode() 方法比较相等，并且两个对象的equals() 方法返回值也相等。 对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object obj)方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”。 向HashSet中添加元素的过程： 当向HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来得到该对象的 hashCode 值，然后根据 hashCode 值，通过某种散列函数决定该对象在 HashSet 底层数组中的存储位置。（这个散列函数会与底层数组的长度相计算得到在数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布，该散列函数设计的越好）如果两个元素的hashCode()值相等，会再继续调用equals方法，如果equals方法结果为true，添加失败；如果为false，那么会保存该元素，但是该数组的位置已经有元素了，那么会通过链表的方式继续链接。如果两个元素的equals() 方法返回true，但它们的hashCode() 返回值不相等，hashSet 将会把它们存储在不同的位置，但依然可以添加成功。 重写hashCode() 方法的基本原则 在程序运行时，同一个对象多次调用hashCode() 方法应该返回相同的值。 当两个对象的equals() 方法比较返回true 时，这两个对象的hashCode()方法的返回值也应相等。 对象中用作equals() 方法比较的Field，都应该用来计算hashCode 值。 重写equals() 方法的基本原则 以自定义的Customer类为例，何时需要重写equals()？ 当一个类有自己特有的“逻辑相等”概念,当改写equals()的时候，总是要改写hashCode()，根据一个类的equals方法（改写后），两个截然不同的实例有可能在逻辑上是相等的，但是，根据Object.hashCode()方法，它们仅仅是两个对象。 因此，违反了“相等的对象必须具有相等的散列码”。 结论：复写equals方法的时候一般都需要同时复写hashCode方法。通常参与计算hashCode的对象的属性也应该参与到equals()中进行计算。 实现类2：LinkedHashSetLinkedHashSet 是HashSet 的子类 LinkedHashSet 根据元素的hashCode 值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的。 LinkedHashSet插入性能略低于HashSet，但在迭代访问Set 里的全部元素时有很好的性能。 LinkedHashSet 不允许集合元素重复。 实现类3：TreeSetTreeSet 是SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态。 TreeSet底层使用红黑树结构存储数据 新增的方法如下：(了解) Comparator comparator() Object first() Object last() Object lower(Object e) Object higher(Object e) SortedSet subSet(fromElement, toElement) SortedSet headSet(toElement) SortedSet tailSet(fromElement) TreeSet 两种排序方法：自然排序和定制排序。默认情况下，TreeSet 采用自然排序。 TreeSet和后面要讲的TreeMap采用红黑树的存储结构 特点：有序，查询速度比List快 hashmap","categories":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/tags/Java/"},{"name":"Java笔记","slug":"Java笔记","permalink":"https://luan-bx.github.io/tags/Java%E7%AC%94%E8%AE%B0/"}]},{"title":"Java（九）枚举类 | 注解","slug":"javaNotes/java9","date":"2022-06-09T07:48:23.000Z","updated":"2023-03-09T02:34:06.757Z","comments":true,"path":"2022/06/09/javanotes/java9/","link":"","permalink":"https://luan-bx.github.io/2022/06/09/javanotes/java9/","excerpt":"","text":"枚举类定义 使用枚举类的实现 JDK1.5之前需要自定义枚举类 JDK 1.5 新增的enum 关键字用于定义枚举类 若枚举只有一个对象, 则可以作为一种单例模式的实现方式。 属性枚举类对象的属性不应允许被改动, 所以应该使用private final 修饰 枚举类的使用private final 修饰的属性应该在构造器中为其赋值 若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数 自定义 私有化类的构造器，保证不能在类的外部创建其对象 在类的内部创建枚举类的实例。声明为：public static final 对象如果有实例变量，应该声明为private final，并在构造器中初始化 enum使用enum 定义的枚举类默认继承了java.lang.Enum类，因此不能再继承其他类 枚举类的构造器只能使用private 权限修饰符 枚举类的所有实例必须在枚举类中显式列出(, 分隔; 结尾)。列出的实例系统会自动添加public static final 修饰 必须在枚举类的第一行声明枚举类对象 JDK 1.5 中可以在switch 表达式中使用Enum定义的枚举类的对象作为表达式, case 子句可以直接使用枚举值的名字, 无需添加枚举类作为限定。 Enum类的主要方法values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。 valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。 toString()：返回当前枚举类对象常量的名称 注解(Annotation)理解框架&#x3D; 注解+ 反射+ 设计模式。 使用使用Annotation 时要在其前面增加@ 符号, 并把该Annotation 当成一个修饰符使用。用于修饰它支持的程序元素 示例一：生成文档相关的注解 @author 标明开发该类模块的作者，多个作者之间使用,分割 @version 标明该类模块的版本 @see 参考转向，也就是相关主题 @since 从哪个版本开始增加的 @param 对方法中某参数的说明，如果没有参数就不能写 @return 对方法返回值的说明，如果方法的返回值类型是void就不能写 @exception 对方法可能抛出的异常进行说明，如果没有用throws显式抛出的异常就不能写 其中 @param @return 和@exception 这三个标记都是只用于方法的。 @param的格式要求：@param 形参名形参类型形参说明 @return 的格式要求：@return 返回值类型返回值说明 @exception的格式要求：@exception 异常类型异常说明 @param和@exception可以并列多个 示例二：在编译时进行格式检查(JDK内置的三个基本注解) @Override: 限定重写父类方法, 该注解只能用于方法 @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择 @SuppressWarnings: 抑制编译器警告 示例三：跟踪代码依赖性，实现替代配置文件功能 Servlet3.0提供了注解,使得不再需要在web.xml文件中进行Servlet的部署。 spring框架中关于“事务”的管理 自定义A.定义新的Annotation 类型使用@interface 关键字 B.自定义注解自动继承了java.lang.annotation.Annotation接口 C.Annotation 的成员变量在Annotation 定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型。我们称为配置参数。类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组。 D.可以在定义Annotation 的成员变量时为其指定初始值, 指定成员变量的初始值可使用default 关键字 E.如果只有一个参数成员，建议使用参数名为value F.如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认值。格式是“参数名 &#x3D; 参数值”，如果只有一个参数成员，且名称为value，可以省略“value&#x3D;” G.没有成员定义的Annotation 称为标记; 包含成员变量的Annotation 称为元数据Annotation 注意：自定义注解必须配上注解的信息处理流程才有意义。","categories":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/tags/Java/"},{"name":"Java笔记","slug":"Java笔记","permalink":"https://luan-bx.github.io/tags/Java%E7%AC%94%E8%AE%B0/"}]},{"title":"数据库相关操作","slug":"javaCode/JavaCodeMySQL","date":"2022-06-03T10:36:12.000Z","updated":"2023-03-08T09:48:42.956Z","comments":true,"path":"2022/06/03/javacode/javacodemysql/","link":"","permalink":"https://luan-bx.github.io/2022/06/03/javacode/javacodemysql/","excerpt":"","text":"删除一条记录（此记录与其他表关联）表A其中一个字段为表B的某个字段，当表B的该条记录删除时，应当提前在表B设置一条初始记录，当某条记录删除，应将初始记录的对应字段set到表A对应字段，防止表B删除后，表A查不到信息。 /* * 删除岗位，设置的初始记录为postId = 16，postName = “待管理员审核身份” */ public String delatePost(String name) { if (name == null) { return Constants.FAILCODE; } try { List&lt;UserEntity> allUser = backSysMapping.getAll(); for (UserEntity userEntity : allUser) { if (userEntity.getPostName() == name) { userEntity.setPostId(16); userEntity.setPostName(postMapping.getNameById(16)); }else { continue; } } postMapping.deletePostByName(name); return Constants.SUCCESSCODE; } catch (Exception e) { log.info(\"BackSysService/delatePost, 删除岗位失败, \", e); return Constants.FAILCODE; } }","categories":[{"name":"数据库","slug":"数据库","permalink":"https://luan-bx.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/tags/Java/"},{"name":"Code","slug":"Code","permalink":"https://luan-bx.github.io/tags/Code/"},{"name":"数据库","slug":"数据库","permalink":"https://luan-bx.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Java（八）多线程","slug":"javaNotes/java8","date":"2022-05-28T10:08:56.000Z","updated":"2023-03-09T03:34:22.349Z","comments":true,"path":"2022/05/28/javanotes/java8/","link":"","permalink":"https://luan-bx.github.io/2022/05/28/javanotes/java8/","excerpt":"","text":"概述程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。 进程(process)是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期 如：运行中的QQ，运行中的MP3播放器 程序是静态的，进程是动态的 进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域 线程(thread)进程可进一步细化为线程，是一个程序内部的一条执行路径。 若一个进程同一时间并行执行多个线程，就是支持多线程的 线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小。 一个进程中的多个线程共享相同的内存单元&#x2F;内存地址空间——它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。 单核CPU和多核CPU 单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果有某个人不想交钱，那么收费人员可以把他“挂起”（晾着他，等他想通了，准备好了钱，再去收费）。但是因为CPU时间单元特别短，因此感觉不出来。 如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的） 一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。 并行与并发并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。 并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。 使用多线程的优点背景：以单核CPU为例，只使用单个线程先后完成多个任务（调用多个方法），肯定比用多个线程来完成用的时间更短，为何仍需多线程呢？ 多线程程序的优点： 提高应用程序的响应。对图形化界面更有意义，可增强用户体验。 提高计算机系统CPU的利用率 改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改 何时需要多线程 程序需要同时执行两个或多个任务。 程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。 需要一些后台运行的程序时。 线程说明Java语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来体现。 Thread类特性： 每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体 通过该Thread对象的start()方法来启动这个线程，而非直接调用run() 构造器： Thread()：创建新的Thread对象 Thread(String threadname)：创建线程并指定线程实例名 Thread(Runnable target)：指定创建线程的目标对象，它实现了Runnable接口中的run方法 Thread(Runnable target, String name)：创建新的Thread对象 线程的创建JDK1.5之前创建新执行线程有两种方法： 继承Thread类的方式 实现Runnable接口的方式 方式一：继承Thread类 定义子类继承Thread类。 子类中重写Thread类中的run方法。 创建Thread子类对象，即创建了线程对象。 调用线程对象start方法：启动线程，调用run方法。 注意点： 如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式。 run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统CPU调度决定。 想要启动多线程，必须调用start方法。 一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以上的异常 “IllegalThreadStateException”。 方式二：实现Runnable接口 定义子类，实现Runnable接口。 子类中重写Runnable接口中的run方法。 通过Thread类含参构造器创建线程对象。 将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。 调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。 区别： 继承Thread：线程代码存放Thread子类run方法中。 实现Runnable：线程代码存在接口的子类的run方法。 实现方式的好处： 避免了单继承的局限性 多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源。 Thread类的有关方法void start(): 启动线程，并执行对象的run()方法 run(): 线程在被调度时执行的操作 String getName(): 返回线程的名称 void setName(String name):设置该线程名称 static Thread currentThread(): 返回当前线程。在Thread子类中就是this，通常用于主线程和 Runnable实现类 static void yield()：线程让步 暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程 若队列中没有同优先级的线程，忽略此方法 join() ：当某个程序执行流中调用其他线程的join() 方法时，调用线程将被阻塞，直到join() 方法加入的join 线程执行完为止 低优先级的线程也可以获得执行 static void sleep(long millis)：(指定时间:毫秒) 令当前线程在指定时间段放弃对CPU控制,使其他线程有机会被执行,时间到后重排队。 抛出InterruptedException异常 stop(): 强制线程生命期结束，不推荐使用 boolean isAlive()：返回boolean，判断线程是否还活着 （5）线程的调度调度策略： Java的调度方法： 同优先级线程组成先进先出队列（先到先服务），使用时间片策略 对高优先级，使用优先调度的抢占式策略 线程的优先级线程的优先级等级 MAX_PRIORITY：10 MIN _PRIORITY：1 NORM_PRIORITY：5 涉及的方法 getPriority() ：返回线程优先值 setPriority(int newPriority) ：改变线程的优先级 说明 线程创建时继承父线程的优先级 低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用 补充：线程的分类Java中的线程分为两类：一种是守护线程，一种是用户线程。 它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开。 守护线程是用来服务用户线程的，通过在start()方法前调用thread.setDaemon(true)可以把一个用户线程变成一个守护线程。 Java垃圾回收就是一个典型的守护线程。 若JVM中都是守护线程，当前JVM将退出。 形象理解：兔死狗烹，鸟尽弓藏 生命周期五个状态 A.新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态 B.就绪： 处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了 运行的条件，只是没分配到CPU资源 C.运行： 当就绪的线程被调度并获得CPU资源时,便进入运行状态，run()方法定义了线程的操 作和功能 D.阻塞： 在某种特殊情况下，被人为挂起或执行输入输出操作时，让出CPU 并临时中止自己的 执行，进入阻塞状态 E.死亡： 线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束 线程的同步Synchronized同步代码块synchronized (同步监视器){ // 需要被同步的代码； } 同步监视器可自定义，但需要保证每个线程调用时，该对象是同一个。 A.使用实现Runnable接口的方法： 只会创建一个对象，所以监视器可以用this，即刚创建的该类的对象。 B.使用继承Thread类的方法： 由于创建多线程会创建出多个对象，就拥有了多个监视器，所以此时用把监视器设置为：该类.calss，因为一个类只有一个，且类也是对象。 Synchronized同步方法如果整个方法均需要同步，synchronized还可以放在方法声明中，表示整个方法为同步方法。 例如： public synchronized void show (String name){ …. } A.使用实现Runnable接口的方法： 只会创建一个对象，所以可以直接用上面的形势，此时也是有监视器的，是this，即刚创建的该类的对象。 B.使用继承Thread类的方法： 由于创建多线程会创建出多个对象，就拥有了多个监视器，所以此时用把该方法设置为static，此时的监视器为：该类.calss，因为一个类只有一个 synchronized的锁是什么？ 任意对象都可以作为同步锁。所有对象都自动含有单一的锁（监视器）。 同步方法的锁：静态方法（类名.class）、非静态方法（this） 同步代码块：自己指定，很多时候也是指定为this或类名.class 注意： 必须确保使用同一个资源的多个线程共用一把锁，这个非常重要，否则就无法保证共享资源的安全 一个线程类中的所有静态方法共用同一把锁（类名.class），所有非静态方法共用同一把锁（this），同步代码块（指定需谨慎） 同步的范围 如何找问题，即代码是否存在线程安全？（非常重要） 明确哪些代码是多线程运行的代码 明确多个线程是否有共享数据 明确多线程运行代码中是否有多条语句操作共享数据 如何解决呢？（非常重要） 对多条操作共享数据的语句，一个线程执行过程中，其他线程不可以参与执行。 即所有操作共享数据的这些语句都要放在同步范围中 切记： 范围太小：没锁住所有有安全问题的代码 范围太大：没发挥多线程的功能。 释放锁的操作A.当前线程的同步方法、同步代码块执行结束。 B.当前线程在同步代码块、同步方法中遇到break、return终止该代码块、该方法的继续执行。 C.当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。 D.当前线程在同步代码块、同步方法中执行线程对象的wait()方法，当前线程暂停并释放锁。 不会释放锁的操作A.线程执行同步代码块或同步方法时，程序调用Thread.sleep()、 Thread.yield()方法暂停当前线程的执行 B.线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）。 应尽量避免使用suspend()和resume()来控制线程 线程的死锁问题死锁： 不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续 解决方法： 专门的算法、原则 尽量减少同步资源的定义 尽量避免嵌套同步 Lock(锁)从JDK 5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。 java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。 ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。 class A{ private final ReentrantLock lock = new ReenTrantLock(); public void m(){ lock.lock(); try{ 证线程安全的代码; } finally{ lock.unlock(); } } } 注意：如果同步代码有异常，要将unlock()写入finally语句块 synchronized 与 Lock 的对比 Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁，出了作用域自动释放 Lock只有代码块锁，synchronized有代码块锁和方法锁 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类） 优先使用顺序： Lock —— 同步代码块（已经进入了方法体，分配了相应资源）—— 同步方法 （在方法体之外） 线性的通信wait() 与notify() 和notifyAll()wait()：令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用notify()或notifyAll()方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行。 notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待 notifyAll ()：唤醒正在排队等待资源的所有线程结束等待. 这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报 java.lang.IllegalMonitorStateException异常。 因为这三个方法必须有锁对象调用，而任意对象都可以作为synchronized的同步锁，因此这三个方法只能在Object类中声明。 wait() 方法在当前线程中调用方法：对象名.wait() 使当前线程进入等待（某对象）状态，直到另一线程对该对象发出notify(notifyAll) 为止。 调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁） 调用此方法后，当前线程将释放对象监控权，然后进入等待 在当前线程被notify后，要重新获得监控权，然后从断点处继续代码的执行。 notify()&#x2F;notifyAll()当前线程调用方法：对象名.notify()，对象名一般设置为同步代码块（方法）的同步监控器 功能：唤醒等待该对象监控权的一个&#x2F;所有线程。 调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁） 面试题: sleep() 和wait()的异同? A. 相同点:一旦执行方法， 都可以使得当前的线程进入阻塞状态。 B. 不同点: 两个方法声明的位置不同: Thread类 中声明sleep()，object类中声明wait() 调用的要求不同: sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代 关于是否释放同步监视器:|如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会。 实现Callable接口概述JDK5.0 新增线程创建方式 与使用Runnable相比， Callable功能更强大些 相比run()方法，可以有返回值 方法可以抛出异常 支持泛型的返回值 需要借助FutureTask类，比如获取返回结果 Future接口 可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。 FutrueTask是Futrue接口的唯一的实现类 FutureTask 同时实现了Runnable, Future接口。它既可以作为 Runnable被线程执行，又可以作为Future得到Callable的返回值 创建流程//1.创建一个实现Callable的实现类 class NumThread implements Callable{ //2.实现call方法，将此线程需要执行的操作声明在call（）中 @Override Public Object call（）throws Exception{ } } 在调用类中： //3.创建Callable接口实现类的对象 NumThread numThread = new NumThread( ); //4.将Callable接口实现类的对象作为参数传到FutureTask构造器，创建FutureTask的对象 FutureTask futureTask = new FutureTask( numThread); //5.将FutureTask的对象作为参数侍送到Thread美的构造器中创建Thread.象， 并调用start(） new Thread(futureTask) . start(); Try{ //6.获取Callable中dplL方法的返回值 //get()返回值即为Future Task构造器参数Callable实现类重写的call()的返回値。 object sum = futureTask.get(); System. out . println( sum); }catch (InterruptedException e){ e. printStackTrace(); }catch (ExecutionException e) { e. printStackTrace(); 线程池概述背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。 好处： A.提高响应速度（减少了创建新线程的时间） B.降低资源消耗（重复利用线程池中线程，不需要每次都创建） C.便于线程管理 corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没有任务时最多保持多长时间后会终止 … 线程池相关APIJDK 5.0起提供了线程池相关API：ExecutorService 和 Executors ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor void execute(Runnable command) ：执行任务&#x2F;命令，没有返回值，一般用来执行Runnable Future submit(Callable task)：执行任务，有返回值，一般又来执行Callable void shutdown() ：关闭连接池 Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池 Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池 Executors.newFixedThreadPool(n); 创建一个可重用固定线程数的线程池 Executors.newSingleThreadExecutor() ：创建一个只有一个线程的线程池 Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。","categories":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/tags/Java/"},{"name":"Java笔记","slug":"Java笔记","permalink":"https://luan-bx.github.io/tags/Java%E7%AC%94%E8%AE%B0/"}]},{"title":"Java（七）异常处理","slug":"javaNotes/java7","date":"2022-05-22T07:46:28.000Z","updated":"2023-03-09T02:33:52.708Z","comments":true,"path":"2022/05/22/javanotes/java7/","link":"","permalink":"https://luan-bx.github.io/2022/05/22/javanotes/java7/","excerpt":"","text":"概述说明因为很多问题不是靠代码能够避免的，(开发过程中的语法错误和逻辑错误不是异常) ，比如： 客户输入数据的格式 读取文件是否存在 网络是否始终保持通畅等等 异常分类Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError和OOM。一般不编写针对性的代码进行处理。 Exception: 其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如： 空指针访问 试图读取不存在的文件 网络连接中断 数组角标越界 捕获错误最理想的是在编译期间，但有的错误只有在运行时才会发生。比如：除数为0，数组下标越界等 分类：编译时异常和运行时异常 常见异常java.lang.RuntimeException (运行异常) ClassCastException ArrayIndexOutOfBoundsException NullPointerException ArithmeticException NumberFormatException InputMismatchException ... java.io.IOExeption FileNotFoundException EOFException java.lang.ClassNotFoundException java.lang.InterruptedException java.io.FileNotFoundException java.sql.SQLException Java异常处理的方式方式一：try-catch-finally 方式二：throws + 异常类型 Java提供的是异常处理的抓抛模型。 Java程序的执行过程中如出现异常，会生成一个异常类对象，该异常对象将被提交给Java运行时系统，这个过程称为抛出(throw)异常。 异常对象的生成 A.由虚拟机自动生成：程序运行过程中，虚拟机检测到程序发生了问题，如果在当前代码中没有找到相应的处理程序，就会在后台自动创建一个对应异常类的实例对象并抛出——自动抛出 B.由开发人员手动创建：Exception exception &#x3D; new ClassCastException();——创建好的异常对象不抛出对程序没有任何影响，和创建一个普通对象一样 如果一个方法内抛出异常，该异常对象会被抛给调用者方法中处理。如果异常没有在调用者方法中处理，它继续被抛给这个调用方法的上层方法。这个过程将一直继续下去，直到异常被处理。这一过程称为捕获(catch)异常。 如果一个异常回到main()方法，并且main()也不处理，则程序运行终止。 程序员通常只能处理Exception，而对Error无能为力。 try-catch-finally 捕获异常的有关信息： 与其它对象一样，可以访问一个异常对象的成员变量或调用它的方法。 getMessage() 获取异常信息，返回字符串 printStackTrace() 获取异常类名和信息，以及异常出现在程序中的位置。返回值void。 finally:捕获异常的最后一步是通过finally语句为异常处理提供一个统一的出口，使得在控制流转到程序的其它部分以前，能够对程序的状态作统一的管理。 throws声明抛出异常是Java中处理异常的第二种方式 如果一个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。 在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。 重写方法不能抛出比被重写方法范围更大的异常类型。 在多态的情况下，对methodA()方法的调用-异常的捕获按父类声明的异常处理。 手动抛出异常首先要生成异常类对象，然后通过throw语句实现抛出操作(提交给Java运行环境)。 IOException e &#x3D; new IOException(); throw e; 可以抛出的异常必须是Throwable或其子类的实例。下面语句在编译时将会产生语法错误： throw new String(“want to throw”); 自定义异常类 一般地，用户自定义异常类都是RuntimeException的子类。 通常需要编写几个重载的构造器。 需要提供serialVersionUID 通过throw抛出。 最重要的是异常类的名字，当异常出现时，可以根据名字判断异常类型。 用户自己的异常类必须继承现有的异常类。","categories":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/tags/Java/"},{"name":"Java笔记","slug":"Java笔记","permalink":"https://luan-bx.github.io/tags/Java%E7%AC%94%E8%AE%B0/"}]},{"title":"Java（六）面向对象（下）","slug":"javaNotes/java6","date":"2022-05-15T11:20:03.000Z","updated":"2023-03-09T02:33:42.516Z","comments":true,"path":"2022/05/15/javanotes/java6/","link":"","permalink":"https://luan-bx.github.io/2022/05/15/javanotes/java6/","excerpt":"","text":"static类属性、类方法类属性作为该类各个对象之间共享的变量。在设计类时,分析哪些属性不因对象的不同而改变，将这些属性设置为类属性。相应的方法设置为类方法。类变量（类属性）由该类的所有实例共享.如果方法与调用者无关，则这样的方法通常被声明为类方法，由于不需要创建对象就可以调用类方法，从而简化了方法的调用。 使用范围在Java类中，可用static修饰：属性、方法、代码块、内部类 特点：A.随着类的加载而加载 B.优先于对象存在 C.修饰的成员，被所有对象所共享 D.访问权限允许时，可不创建对象，直接被类调用(如Person.id、Person.add(int num) ) E.调用时，在一处修改了static的变量或方法，所有调用该static的均同步变化。 F.在static方法内部只能访问类的static修饰的属性或方法，不能访问类的非static结构。 G.因为不需要实例就可访问static方法，因此static方法内部不能有this,也不能有super 。 H.static修饰的方法不能被重写。 单例设计模式设计模式设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。“套路” 单例设计模式所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的构造器的访问权限设置为private，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的。 单例-饿汉式一加载类就new好了，等待调用。 单例-懒汉式用的时候再new 单例模式的优点由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。 单例设计模式应用 main因为main() 方法是静态的，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员。 代码块作用对Java类或对象进行初始化 分类一个类中代码块若有修饰符，则只能被static修饰，称为静态代码块(static block)，没有使用static修饰的，为非静态代码块。 static代码块通常用于初始化static的属性 对比A.静态代码块：用static 修饰的代码块 可以有输出语句。 可以对类的属性、类的声明进行初始化操作。 不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。 若有多个静态的代码块，那么按照从上到下的顺序依次执行。 静态代码块的执行要先于非静态代码块。 静态代码块随着类的加载而加载，且只执行一次。 B.非静态代码块：没有static修饰的代码块 可以有输出语句。 可以对类的属性、类的声明进行初始化操作。 除了调用非静态的结构外，还可以调用静态的变量或方法。 若有多个非静态的代码块，那么按照从上到下的顺序依次执行。 每次创建对象的时候，都会执行一次。且先于构造器执行。 分析运行顺序 先执行的是father的static代码块，然后son的static代码块，才是打印“777777777”，因为main方法的运行，需要son类的加载，又继承了father，所以从father开始打印。 属性赋值的位置 final定义声明类、变量和方法时，可使用关键字final来修饰,表示“最终的”。 A.final标记的类不能被继承。提高安全性，提高程序的可读性。 如：String类、System类、StringBuffer类 B.final标记的方法不能被子类重写。 如：Object类中的getClass()。 C.final标记的变量(成员变量或局部变量)称为常量。名称大写，且只能被赋值一次,不可修改。final标记的成员变量必须在声明时或在每个构造器中或代码块中显式赋值，然后才能使用。 如：final double MY_PI &#x3D; 3.14; static final：全局常量 面试题第一题： public class Something { public int addOne(final int x) { return ++x; 错误，对x进行修改了 return x + 1; 正确，对x没有变化，只是用x进行运算。 } } 第二题： public class Something { public static void main(String[] args) { Other o = new Other(); new Something().addOne(o); } public void addOne(final Other o) { o = new Other(); 错误，对象o重新赋值。 o.i++; 正确，对象o的属性依然可以重新改写。 } } class Other { public int i; } final属性赋值位置加载类之前一定要赋值,否则此属性不能再赋值了。 抽象类、抽象方法有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。 说明A.用abstract关键字来修饰一个类，这个类叫做抽象类。 B.用abstract来修饰一个方法，该方法叫做抽象方法。 抽象方法：只有方法的声明，没有方法的实现。以分号结束： 比如：public abstract void talk(); C.含有抽象方法的类必须被声明为抽象类。 D.抽象类不能被实例化。抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。 E.不能用abstract修饰变量、代码块、构造器； F.不能用abstract修饰私有方法、静态方法、final的方法、final的类。 个人理解：相当于规定了子类应该有哪些方法，各个子类根据实际情况执行自己的代码。 应用超类声明一个方法但不提供实现，该方法的实现由子类提供。这样的方法称为抽象方法。有一个或更多抽象方法的类称为抽象类。 模板方法设计模式（多态的应用）抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。 解决的问题： 当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。 换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。 接口说明一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。 另一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又没有is-a的关系，仅仅是具有相同的行为特征而已。例如：鼠标、键盘、打印机、扫描仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等都支持USB连接。 接口就是规范，定义的是一组规则，体现了现实世界中“如果你是&#x2F;要…则必须能…”的思想。继承是一个”是不是”的关系，而接口实现则是 “能不能”的关系。 接口的本质是契约，标准，规范，就像我们的法律一样。制定好后大家都要遵守。 接口(interface)是抽象方法和常量值定义的集合。 特点A.用interface来定义。 B.接口中的所有成员变量都默认是由public static final修饰的。 C.接口中的所有抽象方法都默认是由public abstract修饰的。 D.接口中没有构造器。 E.接口采用多继承机制。 规范A.定义Java类的语法格式：先写extends，后写implements class SubClass extends SuperClass implements InterfaceA{ } B.一个类可以实现多个接口，接口也可以继承其它接口。 C.实现接口的类必须提供接口中所有方法的具体实现内容，方可实例化。否则，仍为抽象类。 D.接口的主要用途就是被实现类实现。（面向接口编程） E.与继承关系类似，接口与实现类之间存在多态性 F.接口和类是并列关系，或者可以理解为一种特殊的类。从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义(JDK7.0及之前)，而没有变量和方法的实现。 G.分别介绍本类、父类、接口的调用： 代理模式（接口的应用）概述代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问。 应用场景A.安全代理：屏蔽对真实角色的直接访问。 B.远程代理：通过代理类处理远程方法调用（RMI） C.延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象 比如你要开发一个大文档查看软件，大文档中有大的图片，有可能一个图片有100MB，在打开文件时，不可能将所有的图片都显示出来，这样就可以使用代理模式，当需要查看图片时，用proxy来进行大图片的打开。 分类: 静态代理（静态定义代理类） 动态代理（动态生成代理类） JDK自带的动态代理，需要反射等知识 接口与抽象类对比对比 在开发中，常看到一个类不是去继承一个已经实现好的类，而是要么继承抽象类，要么实现接口。 面试 编译错误，接口和继承一个优先级，所以不确定此时x是哪个。 编译错误：The final field Rollable.ball cannot be assigned 任何在interface里声明的interface variable (接口变量，也可称成员变量)，默认为public static final。不可修改参数 java 8的改进Java 8中，你可以为接口添加静态方法和默认方法。从技术角度来说，这是完全合法的，只是它看起来违反了接口作为一个抽象定义的理念。 静态方法：使用static 关键字修饰。可以通过接口直接调用静态方法，并执行其方法体。我们经常在相互一起使用的类中使用静态方法。你可以在标准库中找到像Collection&#x2F;Collections或者Path&#x2F;Paths这样成对的接口和类。 默认方法：默认方法使用default 关键字修饰。可以通过实现类对象来调用。我们在已有的接口中提供新方法的同时，还保持了与旧版本代码的兼容性。比如：java 8 API中对Collection、List、Comparator等接口提供了丰富的默认方法。 默认方法若一个接口中定义了一个默认方法，而另外一个接口中也定义了一个同名同参数的方法（不管此方法是否是默认方法），在实现类同时实现了这两个接口时，会出现：接口冲突。 解决办法：实现类必须覆盖接口中同名同参数的方法，来解决冲突。 若一个接口中定义了一个默认方法，而父类中也定义了一个同名同参数的非抽象方法，则不会出现冲突问题。因为此时遵守：类优先原则。接口中具有相同名称和参数的默认方法会被忽略。 内部类说明成员内部类作为类的成员的角色： A.和外部类不同，Inner class还可以声明为private或protected； B.可以调用外部类的结构; C.可以声明为static的，但此时就不能再使用外层类的非static的成员变量； 成员内部类作为类的角色： A.可以在内部定义属性、方法、构造器等结构 B.可以声明为abstract类，因此可以被其它的内部类继承 C.可以声明为final的 D.编译以后生成OuterClass$InnerClass.class字节码文件（也适用于局部内部类） 【注意】 非static的成员内部类中的成员不能声明为static的，只有在外部类或static的成员内部类中才可声明static成员。 外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式 成员内部类可以直接使用外部类的所有成员，包括私有的数据 当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的 特点A.内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号，以及数字编号。 B.只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类。 C.局部内部类可以使用外部类的成员，包括私有的。 D.局部内部类可以使用外部方法的局部变量，但是必须是final的。由局部内部类和局部变量的声明周期不同所致。 E.局部内部类和局部变量地位类似，不能使用public,protected,缺省,private F.局部内部类不能使用static修饰，因此也不能包含静态成员","categories":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/tags/Java/"},{"name":"Java笔记","slug":"Java笔记","permalink":"https://luan-bx.github.io/tags/Java%E7%AC%94%E8%AE%B0/"}]},{"title":"Java（五）面向对象中","slug":"javaNotes/java5","date":"2022-04-29T14:06:47.000Z","updated":"2023-03-09T02:33:01.623Z","comments":true,"path":"2022/04/29/javanotes/java5/","link":"","permalink":"https://luan-bx.github.io/2022/04/29/javanotes/java5/","excerpt":"","text":"继承性为什么要有继承多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。 此处的多个类称为子类(派生类)，单独的这个类称为父类(基类或超类)。 类继承语法规则class Subclass extends SuperClass&#123; &#125; 作用 减少了代码冗余，提高了代码的复用性。 更有利于功能的扩展。 让类与类之间产生了关系，提供了多态的前提。 注意：不要仅为了获取其他类中某个功能而去继承 使用 子类继承了父类，就继承了父类的方法和属性。 在子类中，可以使用父类中定义的方法和属性，也可以创建新的数据和方法。 在Java 中，继承的关键字用的是“extends”，即子类不是父类的子集，而是对父类的“扩展”。 关于继承的规则： 子类不能直接访问父类中私有的(private)的成员变量和方法。但此时，依然继承了这个私有的变量、方法。 Java只支持单继承和多层继承，不允许多重继承 一个子类只能有一个父类 一个父类可以派生出多个子类 class SubDemo extends Demo&#123; &#125; //ok class SubDemo extends Demo1,Demo2...//error 如果没有显示生命一个父类，则继承java.lang.object类。 且所有类直接或间接继承java.lang.object类 练习题第一次打印定义base类，运行的是base2类，所以相当于在base2类要找base类重写的方法。 第二次打印定义base2类，运行的也是base2类，所以直接在base2里找方法，优先匹配形式一致的方法。 方法的重写定义：(override&#x2F;overwrite)在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。 要求： 子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表 子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型 子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限 子类不能重写父类中声明为private权限的方法 子类方法抛出的异常不能大于父类被重写方法的异常 注意：子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为 static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法。 super在Java类中使用super来调用父类中的指定操作： super可用于访问父类中定义的属性 super可用于调用父类中定义的成员方法 super可用于在子类构造器中调用父类的构造器 注意： 尤其当子父类出现同名成员时，可以用super表明调用的是父类中的成员 super的追溯不仅限于直接父类 super和this的用法相像，this代表本类对象的引用，super代表父类内存空间的标识 调用父类的构造器： 子类中所有的构造器默认都会访问父类中空参数的构造器 当父类中没有空参数的构造器时，子类的构造器必须通过this(参数列表)或者super(参数列表)语句指定调用本类或者父类中相应的构造器。同时，只能”二选一”，且必须放在构造器的首行 如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译出错 this和super的区别多态性定义 多态性，是面向对象中最重要的概念，在Java中的体现： 对象的多态性：父类的引用指向子类的对象。可以直接应用在抽象类和接口上 Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。简称：编译时，看左边；运行时，看右边。 若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism) 多态情况下，“看左边”：看的是父类的引用（父类中不具备子类特有的方法） “看右边”：看的是子类的对象（实际运行的是子类重写父类的方法） 对象的多态 在Java中,子类的对象可以替代父类的对象使用 一个变量只能有一种确定的数据类型 一个引用类型变量可能指向(引用)多种不同类型的对象 Person p &#x3D; new Student(); Object o &#x3D; new Person();&#x2F;&#x2F;Object类型的变量o，指向Person类型的对象 o &#x3D; new Student(); &#x2F;&#x2F;Object类型的变量o，指向Student类型的对象 子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向上转型(upcasting)。 一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法 应用方法的重载与重写从编译和运行的角度看： 重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。 所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”； 而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。 多态小结多态作用： 提高了代码的通用性，常称作接口重用 前提： 需要存在继承或者实现关系 有方法的重写 成员方法： 编译时：要查看引用变量所声明的类中是否有所调用的方法。 运行时：调用实际new的对象所属的类中的重写方法。 成员变量： 不具备多态性，只看引用变量所声明的类。 子类继承父类若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。 对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量 即：多态性，把父类和子类的属性和方法都加载在堆中，运行的是父类的属性（子类的属性加载进来但不能调用）和子类重写的方法（此方法父类中必须包含）。 instanceofx instanceof A：检验变量x是否为类A的对象，返回值为boolean型。 要求x所属的类与类A必须是子类和父类的关系，否则编译错误。 如果x属于类A的子类B，x instanceof A值也为true。 public class Person extends Object {…} public class Student extends Person {…} public class Graduate extends Person {…} ------------------------------------------------------------------- public void method1(Person e) { if (e instanceof Person) // 处理Person类及其子类对象 if (e instanceof Student) //处理Student类及其子类对象 if (e instanceof Graduate) //处理Graduate类及其子类对象 } 对象类型转换(Casting )1.基本数据类型的Casting： 自动类型转换：小的数据类型可以自动转换成大的数据类型 如long g&#x3D;20; double d&#x3D;12.0f 强制类型转换：可以把大的数据类型强制转换(casting)成小的数据类型 如float f&#x3D;(float)12.0; int a&#x3D;(int)1200L 2.对Java对象的强制类型转换称为造型 从子类到父类的类型转换可以自动进行 从父类到子类的类型转换必须通过造型(强制类型转换)实现 无继承关系的引用类型间的转换是非法的 在造型前可以使用instanceof操作符测试一个对象的类型 单元测试在方法名上面加入@Test注解，然后add导包，即可对其中一个方法进行测试。 要求：类为public、有public无参构造器、方法名public且无返回值无形参。 ObjectObject类是所有Java类的根父类 如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类 &#x3D;&#x3D;A.基本类型比较值:只要两个变量的值相等，即为true。 int a&#x3D;5; if(a&#x3D;&#x3D;6){…} B.引用类型比较引用(是否指向同一个对象)：只有指向同一个对象时，&#x3D;&#x3D;才返回true。 Person p1&#x3D;new Person(); Person p2&#x3D;new Person(); if (p1&#x3D;&#x3D;p2){…} 此时比较的是p1、p2是否是同一地址。用“&#x3D;&#x3D;”进行比较时，符号两边的数据类型必须兼容(可自动转换的基本数据类型除外)，否则编译出错。 equals()A.所有类都继承了Object，也就获得了equals()方法。还可以重写。 B.只能比较引用类型，其作用与“&#x3D;&#x3D;”相同,比较是否指向同一个对象。（地址值） 格式:obj1.equals(obj2) C.特例： 当用equals()方法进行比较时，对类File、String、Date及包装类（Wrapper Class）来说，是比较类型及内容而不考虑引用的是否是同一个对象； 原因： 在这些类中重写了Object类的equals()方法。当自定义使用equals()时，可以重写。用于比较两个对象的“内容”是否都相等 D.任何情况下 x.equals(null)，永远返回是“false”； x.equals(和x不同类型的对象)永远返回是“false”。 &#x3D;&#x3D;和equals的区别 &#x3D;&#x3D; 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址 equals的话，它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也 是&#x3D;&#x3D;;我们可以看到String等类的equals方法是被重写过的，而且String类在日常开发中用的比较多，久而久之，形成了equals是比较值的错误观点。 具体要看自定义类里有没有重写Object的equals方法来判断。 通常情况下，重写equals方法，会比较类中的相应属性是否都相等。 int it = 65; float fl = 65.0f; System.out.println(“65和65.0f是否相等？” + (it == fl)); //true char ch1 = 'A'; char ch2 = 12; System.out.println(\"65和'A'是否相等？\" + (it == ch1));//true System.out.println(“12和ch2是否相等？\" + (12 == ch2));//true toString() toString()方法在Object类中定义，其返回值是String类型，返回类名和它的引用地址。 在进行String与其它类型数据的连接操作时，自动调用toString()方法 Date now&#x3D;new Date(); System.out.println(“now&#x3D;”+now); 相当于System.out.println(“now&#x3D;”+now.toString()); 可以根据需要在用户自定义类型中重写toString()方法 如String 类重写了toString()方法，返回字符串的值。 s1&#x3D;“hello”; System.out.println(s1);&#x2F;&#x2F;相当于System.out.println(s1.toString()); 基本类型数据转换为String类型时，调用了对应包装类的toString()方法 int a&#x3D;10; System.out.println(“a&#x3D;”+a); 面试题： char[] arr = new char[] { 'a', 'b', 'c' }; System.out.println(arr); //abc int[] arr1 = new int[] { 1, 2, 3 }; System.out.println(arr1); //[I@1c655221 double[] arr2 = new double[] { 1.1, 2.2, 3.3 }; System.out.println(arr2); //[D@58d25a40 包装类的使用装箱拆箱JDK1.5之后，支持自动装箱，自动拆箱。但类型必须匹配。 A.基本数据类型包装成包装类的实例—装箱 通过包装类的构造器实现： int i = 500; Integer t = new Integer(i); 还可以通过字符串参数构造包装类对象： Float f = new Float(“4.56”); Long l = new Long(“asdf”); //NumberFormatException B.获得包装类对象中包装的基本类型变量—拆箱 调用包装类的.xxxValue()方法： boolean b = flag.booleanValue(); 字符串、基本数据类型转换A.字符串转换成基本数据类型 通过包装类的构造器实现： int i = new Integer(“12”); 通过包装类的parseXxx(String s)静态方法： Float f = Float.parseFloat(“12.1”); B.基本数据类型转换成字符串 调用字符串重载的valueOf()方法： String fstr = String.valueOf(2.34f); 更直接的方式： String intStr = 5 + “” 面试题Object o1 = true ? new Integer(1) : new Double(2.0); System.out.println(o1); // 1.0 执行三元判断时，都运行了，所以int型，类型提升 Integer i = new Integer(1); Integer j = new Integer(1); System.out.println(i == j); // false （两个地址值不一样） Integer m = 1; Integer n = 1; System.out.println(m == n);// true （为快速加载，该类提前定义数组[-128，127]，所以没有经过new，两个1均从数组里取值） Integer x = 128; Integer y = 128; System.out.println(x == y);// false （超过127，需要重新new）","categories":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/tags/Java/"},{"name":"Java笔记","slug":"Java笔记","permalink":"https://luan-bx.github.io/tags/Java%E7%AC%94%E8%AE%B0/"}]},{"title":"Java（四）面向对象上","slug":"javaNotes/java4","date":"2022-04-20T06:09:21.000Z","updated":"2023-03-09T02:33:04.993Z","comments":true,"path":"2022/04/20/javanotes/java4/","link":"","permalink":"https://luan-bx.github.io/2022/04/20/javanotes/java4/","excerpt":"","text":"基本概念面向过程(POP) 与 面向对象(OOP)二者都是一种思想，面向对象是相对于面向过程而言的。 面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做。 面向对象，将功能封装进对象，强调具备了功能的对象，以类&#x2F;对象为最小单位，考虑谁来做。 面向对象的三大特征封装(Encapsulation) 继承(Inheritance) 多态(Polymorphism) 面向对象的思想概述类(Class)和对象(Object)是面向对象的核心概念。 类是对一类事物的描述，是抽象的、概念上的定义 对象是实际存在的该类事物的每个个体，因而也称为实例(instance)。 常见的类的成员属性：对应类中的成员变量 行为：对应类中的成员方法 Field &#x3D; 属性&#x3D; 成员变量，Method &#x3D; (成员)方法&#x3D; 函数 自定义类步骤： 定义类（考虑修饰符、类名） 编写类的属性（考虑修饰符、属性类型、属性名、初始化值） 编写类的方法（考虑修饰符、返回值类型、方法名、形参等） 对象创建对象语法：类名 对象名&#x3D; new 类名(); 使用 “对象名.对象成员” 的方式访问对象成员（包括属性和方法） 类的访问机制：在一个类中的访问机制：类中的方法可以直接访问类中的成员变量。（例外：static方法访问非static，编译不通过。） 在不同类中的访问机制：先创建要访问类的对象，再用对象访问类中定义的成员。 内存解析堆（Heap），此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。 栈（Stack），是指虚拟机栈。虚拟机栈用于存储局部变量等。局部变量表存放了编译期可知长度的各种基本数据类型（boolean、byte、char 、short 、int 、float 、long 、double）、对象引用（reference类型，它不等同于对象本身，是对象在堆内存的首地址）。方法执行完，自动释放。 方法区（Method Area），用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 匿名对象我们也可以不定义对象的句柄，而直接调用这个对象的方法。这样的对象叫做匿名对象。 如：new Person().shout(); 使用情况：如果对一个对象只需要进行一次方法调用，那么就可以使用匿名对象。我们经常将匿名对象作为实参传递给一个方法调用。 属性语法格式：修饰符 数据类型 属性名&#x3D; 初始化值; 说明1: 修饰符 常用的权限修饰符有：private、缺省、protected、public 其他修饰符：static、final (暂不考虑) 说明2：数据类型 任何基本数据类型(如int、Boolean) 或任何引用数据类型。 说明3：属性名 属于标识符，符合命名规则和规范即可。 变量的分类在方法体外，类体内声明的变量称为 成员变量。 在方法体内部声明的变量称为 局部变量。 赋值的位置：① 默认初始化 ② 显式初始化 ③ 构造器中初始化 ④ 通过“对象.属性“或“对象.方法”的方式赋值 赋值的先后顺序： ① - ② - ③ - ④ 技巧如果循环体外还想用变量，可以把变量的声明放在外面，复制在循环体里面，这样循环完还可以继续用这个变量 方法方法是类或对象行为特征的抽象，用来完成某个功能操作。在某些语言中也称为函数或过程。将功能封装为方法的目的是，可以实现代码重用，简化代码 Java里的方法不能独立存在，所有的方法必须定义在类里。 声明格式修饰符 返回值 类型 方法名（参数类型形参1, 参数类型形参2, ….）｛ 方法体 程序代码 return 返回值; ｝ 方法中只能调用方法或属性，不可以在方法内部定义方法。 方法的重载概念： 在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同。 特点： 与返回值类型无关，只看参数列表，且参数列表必须不同。(参数个数或参数类型)。调用时，根据方法参数列表的不同来区别。 可变个数的形参&#x2F;&#x2F;JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量 public static void test(int a ,String[] books); &#x2F;&#x2F;JDK5.0：采用可变个数形参来定义方法，传入多个同一类型变量 public static void test(int a ,String…books); 说明： 声明格式：方法名(参数的类型名 …参数名) 可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个 可变个数形参的方法与同名的方法之间，彼此构成重载 可变参数方法的使用与方法参数部分使用数组是一致的 方法的参数部分有可变形参，需要放在形参声明的最后 在一个方法的形参位置，最多只能声明一个可变个数形参 方法参数的值传递机制形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参 形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参 失败：change会新创建一个变量放在栈里，两个x各走各的。 成功：change和main共用一个对象，放在堆里，修改的是一个对象。 拓展题目： 递归一个方法体内调用它自身。 方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。 递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。 封装和隐藏我们程序设计追求“高内聚，低耦合”。 高内聚：类的内部数据操作细节自己完成，不允许外部干涉； 低耦合：仅对外暴露少量的方法用于使用。 隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。 通过将数据声明为私有的(private)，再提供公共的（public）方法:getXxx()和setXxx()实现对该属性的操作，以实现下述目的： 隐藏一个类中不需要对外提供的实现细节； 便于修改，增强代码的可维护性； 只能通过事先定制好的方法来访问数据，可以加入控制逻辑，限制对属性的不合理操作； 构造器语法格式：修饰符类名(参数列表) { 初始化语句； } 构造器的特征： 它具有与类相同的名称 它不声明返回值类型。（与声明为void不同） 不能被static、final、synchronized、abstract、native修饰，不能有return语句返回值 构造器的作用： 创建对象； 给对象进行初始化 如：Order o &#x3D; new Order(); Person p &#x3D; new Person(“Peter”,15); 如同我们规定每个“人”一出生就必须先洗澡，我们就可以在“人”的构造器中加入完成“洗澡”的程序代码，于是每个“人”一出生就会自动完成“洗澡”，程序就不必再在每个人刚出生时一个一个地告诉他们要“洗澡”了。 创建Animal类的实例：Animal a &#x3D; new Animal(); 调用构造器，将legs初始化为4。 根据参数不同，构造器可以分为如下两类： 隐式无参构造器（系统默认提供） 显式定义一个或多个构造器（无参、有参） 注意： Java语言中，每个类都至少有一个构造器 默认构造器的修饰符与所属类的修饰符一致 一旦显式定义了构造器，则系统不再提供默认构造器 一个类可以创建多个重载的构造器 父类的构造器不可被子类继承 JavaBeanJavaBean是一种Java语言写成的可重用组件。 所谓javaBean，是指符合如下标准的Java类： 类是公共的 有一个无参的公共的构造器 有属性，且有对应的get、set方法 用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。用户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。 UML类图 +表示public 类型，- 表示private 类型，#表示protected类型 方法的写法: 方法的类型(+、-) 方法名(参数名：参数类型)：返回值类型 this定义 它在方法内部使用，即这个方法所属对象的引用；它在构造器内部使用，表示该构造器正在初始化的对象。 this可以调用类的属性、方法和构造器 当在方法内需要用到调用该方法的对象时，就用this。 具体的：我们可以用this来区分属性和局部变量。 比如：this.name &#x3D; name; 使用： 在任意方法或构造器内，如果使用当前类的成员变量或成员方法可以在其前面添加this，增强程序的阅读性。不过，通常我们都习惯省略this。 当形参与成员变量同名时，如果在方法内或构造器内需要使用成员变量，必须添加this来表明该变量是类的成员变量 使用this访问属性和方法时，如果在本类中未找到，会从父类中查找 this可以作为一个类中构造器相互调用的特殊格式 (3)注意（构造器相互调用）：1.可以在类的构造器中使用”this(形参列表)”的方式，调用本类中重载的其他的构造器！ 2.明确：构造器中不能通过”this(形参列表)”的方式调用自身构造器 3.如果一个类中声明了n个构造器，则最多有 n - 1个构造器中使用了”this(形参列表)” 4.”this(形参列表)”必须声明在类的构造器的首行！ 5.在类的一个构造器中，最多只能声明一个”this(形参列表)” packagepackage语句作为Java源文件的第一条语句，指明该文件中定义的类所在的包。(若缺省该语句，则指定为无名包)。它的格式为： package 顶层包名.子包名; 包对应于文件系统的目录，package语句中，用“.” 来指明包(目录)的层次； 包通常用小写单词标识。通常使用所在公司域名的倒置：com.atguigu.xxx 举例：pack1\\pack2\\PackageTest.java package pack1.pack2; &#x2F;&#x2F;指定类PackageTest属于包pack1.pack2 MVC设计模式 192 节 课后练习4 定义类Student，包含三个属性：学号number(int)，年级state(int)，成绩score(int)。创建20个学生对象，学号为1到20，年级和成绩都由随机数确定。 问题一：打印出3年级(state值为3）的学生信息。 问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息","categories":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/tags/Java/"},{"name":"Java笔记","slug":"Java笔记","permalink":"https://luan-bx.github.io/tags/Java%E7%AC%94%E8%AE%B0/"}]},{"title":"Java（三）数组","slug":"javaNotes/java3","date":"2022-04-12T11:15:42.000Z","updated":"2023-03-08T07:14:24.069Z","comments":true,"path":"2022/04/12/javanotes/java3/","link":"","permalink":"https://luan-bx.github.io/2022/04/12/javanotes/java3/","excerpt":"","text":"二维数组 打印二维数组的外层数组，其实相当于打印一个一维数组，只会打印出这个数组存放的地址。其中“[I@15db…”的‘[’表示一维，‘I’ 表示int型。 倒数第二行为null，即使二维数组是double，但里面的元素数组还未定义类型，而数组的为初始化为null。报错是因为未初始化就取值会报错。 数组的赋值与复制（1）数组的赋值： 慎用array1 &#x3D; array2 来赋值，虽然把array2 赋值给array1，但修改array1同样修改的是array2，只是将array2的地址给了array1，他俩共用一个数组。 （2）数组的复制： 开辟一个新的堆，存放新数组 array1 = new int[array2.length]; for(int i = 0;i &lt; array1.length;i++){ array1[i] = array2[i]; } 打印数组将数组转成String：Arrays.toString() System.out.println(“等级” + Arrays.toString(abcd)); 数组算法（1）衡量排序算法的优劣 1.时间复杂度：分析关键字的比较次数和记录的移动次数 2.空间复杂度：分析排序算法中需要多少辅助内存 3.稳定性：若两个记录A和B的关键字值相等，但排序后A、B的先后次序保持不变，则称这种排序算法是稳定的。 （2）排序算法分类 内部排序和外部排序。 内部排序：整个排序过程不需要借助于外部存储器（如磁盘等），所有排序操作都在内存中完成。 外部排序：参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助于外部存储器（如磁盘）。外部排序最常见的是多路归并排序。可以认为外部排序是由多次内部排序组成。 （3）十大内部排序算法 a选择排序 直接选择排序、堆排序 b交换排序 冒泡排序、快速排序 c插入排序 直接插入排序、折半插入排序、Shell排序 d归并排序 e桶式排序 f基数排序 (3)冒泡排序 介绍： 冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。 排序思想： 比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较为止。 (4)快速排序 介绍： 快速排序通常明显比同为O(nlogn)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。 快速排序（Quick Sort）由图灵奖获得者Tony Hoare发明，被列为20世纪十大算法之一，是迄今为止所有内排序算法中速度最快的一种。冒泡排序的升级版，交换排序的一种。快速排序的时间复杂度为O(nlog(n))。 排序思想： 从数列中挑出一个元素，称为”基准”（pivot）， 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。","categories":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/tags/Java/"},{"name":"Java笔记","slug":"Java笔记","permalink":"https://luan-bx.github.io/tags/Java%E7%AC%94%E8%AE%B0/"}]},{"title":"Java（二）基本语法","slug":"javaNotes/java2","date":"2022-04-06T08:52:19.000Z","updated":"2023-03-08T07:14:24.710Z","comments":true,"path":"2022/04/06/javanotes/java2/","link":"","permalink":"https://luan-bx.github.io/2022/04/06/javanotes/java2/","excerpt":"","text":"关键字(keyword)定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词） 特点：关键字中所有字母都为小写 保留字(reserved word)现有Java版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字： goto 、const 标识符(Identifier)Java 对各种变量、方法和类等要素命名时使用的字符序列称为标识符 技巧：凡是自己可以起名字的地方都叫标识符。 定义合法标识符规则：A.由26个英文字母大小写，0-9 ，_或$ 组成 B.数字不可以开头。 C.不可以使用关键字和保留字，但能包含关键字和保留字。 D.Java中严格区分大小写，长度无限制。 E.标识符不能包含空格。 Java中的名称命名规范：包名：多单词组成时所有字母都小写：xxxyyyzzz 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个开始首字母大写：xxxYyyZzz 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ 注意1：在起名字时，为了提高阅读性，要尽量有意义，“见名知意”。 注意2：java采用unicode字符集，因此标识符也可以使用汉字声明，但是不建议使用。 变量变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值 变量的分类按数据类型 按声明的位置的不同 说明数值型（1）整数类型：byte、short、int、long 整型常量默认为int 型，声明long型常量须后加‘l’或‘L’ ，否则默认为int。 Java程序中变量通常声明为int型，除非不足以表示较大的数，才使用long。 （2）浮点类型：float、double double:双精度，精度是float的两倍。通常采用此类型。 浮点型常量默认为double型，声明float型常量，须后加‘f’或‘F’。否则默认为double。 如下图：因为b1已经为int，f1已经为double。 字符型：char用来表示通常意义上“字符”(2字节) ，Java中的所有字符都使用Unicode编码， 故一个字符可以存储一个字母，一个汉字，或其他书面语的一个字符。 字符型变量的三种表现形式： （1）字符常量是用单引号(‘ ’)括起来的单个字符。 例如：char c1 &#x3D; ‘a’; char c2 &#x3D; ‘中’; char c3 &#x3D; ‘9’; （2）Java中还允许使用转义字符‘\\’来将其后的字符转变为特殊字符型常量。 例如：char c3 &#x3D; ‘\\n’; &#x2F;&#x2F; ‘\\n’表示换行符 （3）直接用Unicode值表示字符型常量：‘\\uXXXX’。XXXX代表一个十六进制整数。 例如：\\u000a 表示\\n。 char类型是可以进行运算的。因为它都对应有Unicode码。 Char c1 &#x3D; 97; 和char c2 &#x3D; ‘97’; 是不一样的，c1输出的是Unicode码，c2输出的是符号对应的Unicode码。 布尔型：boolean只允许取值true和false，无null。 不可以使用0或非0 的整数替代false和true，这点和C语言不同。 编译后使用java虚拟机中的int数据类型来代替：true用1表示，false用0表示。 引用数据类型字符串类型：String , String不是基本数据类型，属于引用数据类型 使用变量注意A.Java中每个变量必须先声明，后使用 B.使用变量名来访问这块区域的数据 C.变量的作用域：其定义所在的一对{ }内 D.变量只有在其作用域内才有效 E.同一个作用域内，不能定义重名的变量 声明变量A.语法：&lt;数据类型&gt; &lt;变量名称&gt; 例如：int var; B.变量的赋值 语法：&lt;变量名称&gt; &#x3D; &lt;值&gt; 例如：var &#x3D; 10; C.声明和赋值变量 语法：&lt;数据类型&gt; &lt;变量名&gt; &#x3D; &lt;初始化值&gt; 例如：int var &#x3D; 10; 数据类型转换容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为： A.有多种类型的数据混合运算时，自动将所有数据转换成容量最大的类型，再进行计算。 B. byte,short,char之间不会相互转换，他们三者在计算时首先转换为int类型。 C. boolean类型不能与其它数据类型运算。 D.当把任何基本数据类型的值和字符串(String)进行连接运算时(+)，基本数据类型的值将自动转化为字符串(String)类型。 ‘a’为char，和后面的int 1 自动升级int值97，97 +1 &#x3D; 98 再升级为字符串 强制类型转换自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符：()，但可能造成精度降低或溢出,格外要注意。 通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型。如：String a &#x3D; “43”; int i &#x3D; Integer.parseInt(a); boolean类型不可以转换为其它的数据类型。 例子：byte b &#x3D; 3; b &#x3D; (byte)(b+4); 因为b+4，所以b本应该转为int，强制转为byte。 二进制计算机以二进制补码的形式保存所有的整数。 二进制的整数有如下三种形式： 原码：直接将一个数值换成二进制数。最高位是符号位 负数的反码：是对原码按位取反，只是最高位（符号位）确定为1。 负数的补码：其反码加1。 运算符算术运算符 注意： （1）算术“与”，是他们的二进制对位相乘 十进制的60转为十六进制 第三行强制转char，就可以把i2-10（int） + ‘A’（char）输出char型的字符 练习：表示三位数的各个位： 赋值运算符+&#x3D;, -&#x3D;, *&#x3D;, &#x2F;&#x3D;, %&#x3D; 以+&#x3D;为例，格式都一样的: x +&#x3D; 2； (不改变数据类型) x &#x3D; x + 2; （x初始为short，输出的x应为int，所以编译错误，没有强行转换） 练习： int n &#x3D; 10; n +&#x3D; (n++) + (++n); System.out.println(n); 答案：n &#x3D; 32； 解答：n &#x3D; n + (n++) + (++n) 每个n对应的值： 10 10 12 比较运算符（关系运算符） 第七行是把true赋值给y，这个（y&#x3D;true）括号就为真 逻辑运算符&amp;—逻辑与| —逻辑或！—逻辑非 &amp;&amp; —短路与|| —短路或^ —逻辑异或 开发中推荐 &amp;&amp; 和 || A.“&amp;”和“&amp;&amp;”的区别： &amp;时，左边无论真假，右边都进行运算； &amp;&amp;时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。 int n &#x3D; 10; false &amp; (n++); n &#x3D; 11 true&amp; (n++); n &#x3D; 11 false &amp;&amp; (n++); n &#x3D; 10 true&amp;&amp; (n++); n &#x3D; 11 B.“|”和“||”的区别同理，||表示：当左边为真，右边不参与运算。 C.异或( ^ )与或( | )的不同之处是：当左右都为true时，结果为false。 理解：异或，追求的是“异”! D.在Java中不可以写成3&lt;x&lt;6，应该写成x&gt;3 &amp; x&lt;6 。因为前面3&lt;x已经为布尔型数据，不能再和6去比较了。 位运算符位运算是直接对整数的二进制进行的运算 三元运算符 表达式1和表达式2为同种类型，可以嵌套 三元运算符与if-else的联系与区别： 1）三元运算符可简化if-else语句,比if -else运行效率高。 2）三元运算符要求必须返回一个结果。 3）if后的代码块可有多个语句 练习： A.两个数比大小 int n &#x3D; 10; int m &#x3D; 20; int out &#x3D; (m&gt;n) ? “m大” ：（(n &#x3D;&#x3D; m) ? “m和n一样大” ：“n大”） B.三个数取最大 Int n &#x3D; 10; int m &#x3D; 20; int z &#x3D; 30; int max &#x3D; (n&lt;m) ? ((m&lt;z) ? z : m) : ((n&gt;z) ? n : z) 控制台输入 通过Scanner类来输入，如果是String，调用next（），其他类型数据就nextXxx（）。 程序流程控制流程控制语句是用来控制程序中各语句执行顺序的语句 三种基本流程结构:A.顺序结构 B.分支结构 根据条件，选择性地执行某段代码。 有if…else和switch-case两种分支语句。 C.循环结构 根据循环条件，重复性的执行某段代码。 有while、do…while、for三种循环语句。 注：JDK1.5提供了foreach循环，方便的遍历集合、数组元素。 循环语句的四个组成部分： A.初始化部分(init_statement) B.循环条件部分(test_exp) C.循环体部分(body_statement) D.迭代部分(alter_statement) if-else结构注意： 当多个条件是“互斥”关系时，条件判断语句及执行语句间顺序无所谓 当多个条件是“包含”关系时，“小上大下 &#x2F; 子上父下” switch-case结构switch(表达式) { case 常量1: 语句1; // break; case 常量2: 语句2; // break; … … case 常量N: 语句N; // break; default: 语句; // break; } switch和if语句的对比： （1）如果判断的具体数值不多，而且符合byte、short 、char、int、String、枚举等几 种类型。虽然两个语句都可以使用，建议使用swtich语句。因为效率稍高。 （2）其他情况：对区间判断，对结果为boolean类型判断，使用if，if的使用范围更广。 也就是说，使用switch-case的，都可以改写为if-else。反之不成立。 注意： （1）switch(表达式)中表达式的值必须是下述几种类型之一： byte，short，char，int，枚举(jdk 5.0)，String (jdk 7.0)； （2）case子句中的值必须是常量，不能是变量名或不确定的表达式值； （3）同一个switch语句，所有case子句中的常量值互不相同； （4）break语句用来在执行完一个case分支后使程序跳出switch语句块； 如果没有break，程序会顺序执行到switch结尾 （5）default子句是可任选的。同时，位置也是灵活的。当没有匹配的case时，执行default （6）多个case执行相同语句，可以考虑合并 （7）编写程序：从键盘上输入2019年的“month”和“day”，要求通过程序输出输入的日期为2019年的第几天。 break不加的情况。 倒着写，把前面的结果累加。 每次加的是上个月的天数，最后加一下本月的天数。 for循环for (①初始化部分; ②循环条件部分; ④迭代部分)｛ ③循环体部分; ｝ 执行过程：①-②-③-④-②-③-④-②-③-④-…..-② 说明： ②循环条件部分为boolean类型表达式，当值为false时，退出循环 ①初始化部分可以声明多个变量，但必须是同一个类型，用逗号分隔 ④可以有多个变量更新，用逗号分隔 题目：输入两个正整数m和n，求其最大公约数和最小公倍数。 比如：12和20的最大公约数是4，最小公倍数是60。 说明：break关键字的使用。比如公约数为1，2，4，找最大，可以倒着判断，从大到小取模，会先找到4，4ok就退出循环。 while循环语法格式 ①初始化部分 while(②循环条件部分)｛ ③循环体部分; ④迭代部分; } 执行过程： ①-②-③-④-②-③-④-②-③-④-…-② 说明： 注意不要忘记声明④迭代部分。否则，循环将不能结束，变成死循环。 for循环和while循环可以相互转换 不确定循环次数，通过循环体内容判断，然后break跳出循环体。 Boolean isFlag &#x3D; true； while（isFlag）{ ……. If(…….){ ….. Break; } } do-while循环语法格式 ①初始化部分; do{ ③循环体部分 ④迭代部分 }while(②循环条件部分); 执行过程： ①-③-④-②-③-④-②-③-④-…② 说明： do-while循环至少执行一次循环体。 练习：100以内的所有质数 1.Math.sqrt()为开根号，如果可以被除开，或有一对数，一大一小，小的数&lt;开根号，极大提高速度。 2.break，发现有一个被除开，就不要继续运算了 break、continue、return（1）break break语句用于终止某个语句块的执行 { …… break; …… } break语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是 哪一层语句块 label1: { …… label2: { …… label3: { …… break label2; …… } } } （2）continue continue只能使用在循环结构中 continue语句用于跳过其所在循环语句块的一次执行，继续下一次循环 continue语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环 （3）return 并非专门用于结束循环的，它的功能是结束一个方法。 当一个方法执行到一个return语句时，这个方法将被结束。 与break和continue不同的是，return直接结束整个方法，不管return处于多少层循环之内 总结： break只能用于switch语句和循环语句中。 continue 只能用于循环语句中。 二者功能类似，但continue是终止本次循环，break是终止本层循环。 break、continue之后不能有其他的语句，因为程序永远不会执行其后的语句。 标号语句必须紧接在循环的头部。标号语句不能用在非循环语句的前面。 很多语言都有goto语句，goto语句可以随意将控制转移到程序中的任意一条语句上，然后执行它。但使程序容易出错。Java中的break和continue是不同于goto的。","categories":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/tags/Java/"},{"name":"Java笔记","slug":"Java笔记","permalink":"https://luan-bx.github.io/tags/Java%E7%AC%94%E8%AE%B0/"}]},{"title":"Java零碎知识","slug":"javaNotes/java12","date":"2022-04-05T02:23:19.000Z","updated":"2023-03-09T03:28:28.983Z","comments":true,"path":"2022/04/05/javanotes/java12/","link":"","permalink":"https://luan-bx.github.io/2022/04/05/javanotes/java12/","excerpt":"","text":"1.在字符串“”中，加入双引号，会与方法中的“”混淆。 分别在前面加 \\ ,即可打印出双引号 2.产生随机数 int value = (int)(Math.random() * 90 + 10) // [10.0, 100.0) Math.random() : [0,1) [a,b] : (int)(Math.random() * (b - a + 1) + a) 3.\\t System.out.println(\"制表符：这是一个 \\t 空格\"); System.out.println(\"这是一个斜杠t：\\\\t ，双斜杠取消修饰符\"); 4.数组是有序的，对数组其中一位删除，后面的要依次往前补一个 5.判断数据是否等于某字符串时，把字符串放在前面，避免data出现空指针（.equals报错）","categories":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/tags/Java/"},{"name":"Java笔记","slug":"Java笔记","permalink":"https://luan-bx.github.io/tags/Java%E7%AC%94%E8%AE%B0/"}]},{"title":"Java（一）语言概述","slug":"javaNotes/java1","date":"2022-03-28T04:56:44.000Z","updated":"2023-03-08T07:14:22.131Z","comments":true,"path":"2022/03/28/javanotes/java1/","link":"","permalink":"https://luan-bx.github.io/2022/03/28/javanotes/java1/","excerpt":"","text":"java语言的特点是什么？面向对象性：两个基本概念（要素）：类、对象；三大特性：封装、继承、多态健壮性：吸收了C&#x2F;C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制跨平台性：通过Java语言编写的应用程序在不同的系统平台上都可以运行。“Write once , Run Anywhere” 软件开发软件，即一系列按照特定顺序组织的计算机数据和指令的集合。有系统软件和应用软件之分。 系统软件：windows、mac os、linux、android、ios… 应用软件：ppt、画图板、word… 人机交互方式图形化界面(Graphical User Interface GUI)：这种方式简单直观 命令行方式(Command Line Interface CLI)：需要有一个控制台，输入特定的指令，让计算机完成一些操作。 Pascal之父Nicklaus Wirth：“Algorithms+Data Structures&#x3D;Programs” 应用程序 &#x3D; 算法 + 数据结构 常用的DOS命令（cmd）dir : 列出当前目录下的文件以及文件夹 md : 创建目录 rd : 删除目录 cd : 进入指定目录 cd.. : 退回到上一级目录 cd: 退回到根目录 del : 删除文件 exit : 退出dos 命令行 Java优势A.纯粹的面向对象 B.舍弃了C语言中容易引起错误的指针 C.增加了垃圾回收器功能 Java两种核心机制Java虚拟机（Java Virtal Machine），JVM 垃圾收集机制（Garbage Collection），也会出现内存泄漏、内存溢出事件。 System.out.println()和System.out.print()什么区别呢？System.out.println();打印完后，会换行。 System.out.print();打印完后，不会换行。 \\n(换行)，\\t(制表符) 一个”.java”源文件中是否可以包括多个类（不是内部类）？答：可以。但最多只有一个类名声明为public，与文件名相同。 文件名和类名Something类的文件名叫OtherThing.java class Something{ public static void main(String[] something_to_do){ System.out.println(\"Do something ...\"); } } 这个很明显。 答案: 正确。从来没有人说过Java的class名字必须和其文件名相同。但public class的名字必须和文件名相同。 配置环境变量为什么要设置path（设置path的目的是什么）？目的是为了在控制台的任何文件路径下，都可以调用jdk指定目录下的所有指令。 JDK,JRE和JVM，以及关系是什么？JDK: Java Development Kit Java 开发工具包 JRE: Java Runtime Environment Java运行环境 关系： 使用JDK的开发工具完成的Java程序，交给JRE运行。 JDK包含JRE，JRE包含JVM. JDK &#x3D; JRE + 开发工具集（如javac编译工具） JRE &#x3D; JVM + Java SE 标准类库 终端／cmd运行程序格式？编译：javac 源文件名.java （会生成类名.calss的文件，称为字节码文件） 运行：java 类名 （不要加后缀.class） 程序的入口main()方法 Public static void main(String[] args) 注释分为单行注释、多行注释、文档注释（java特有） 单行注释、多行注释——对程序进行说明，增加可读性，不参与编译，.class文件不包含。 文档注释——可以被jdk提供的工具javadoc解析，生成一套以网页文件形式的说明文档。","categories":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/tags/Java/"},{"name":"Java笔记","slug":"Java笔记","permalink":"https://luan-bx.github.io/tags/Java%E7%AC%94%E8%AE%B0/"}]},{"title":"git常用命令","slug":"git","date":"2022-02-20T11:38:38.000Z","updated":"2023-03-08T07:14:23.380Z","comments":true,"path":"2022/02/20/git/","link":"","permalink":"https://luan-bx.github.io/2022/02/20/git/","excerpt":"","text":"基本操作 初始化本地库 git init 查看状态 git status 推 添加到暂缓区 git add . 提交至本地库 git commit -m '提交信息' 推到远程仓库 git push 拉 下拉并与本地合并 git pull 如未知关联的仓库 git pull 仓库名 分支名 冲突冲突产生的表现：后面状态为MERGING 查看状态 git status 解决合并问题： 1）编辑有冲突的文件，删除特殊符号，决定要使用的内容 特殊符号：&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 当前分支的代码======= 合并过来的代码&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2）添加到暂存区 git add XXXX（文件名） 或 git add . 3）查看解决状态，全部绿色（modified修改过） git status 4）执行提交（注意：此时使用git commit 命令时不能带文件名） git commit -m ' ' 发现后面MERGING 消失，变为正常 分支 创建分支 git branch 分支名 查看分支 git branch -v 切换分支（切换分支的本质就是移动HEAD 指针） git checkout 分支名 指定分支合并到当前分支 git merge 分支名 版本 查看历史记录 git reflog 版本穿梭 git reset --hard 版本号 vim相关操作主要用到： “a”进入编辑 “Esc”退出编辑 “shift + :”开始编辑命令 “:wq”保存 “:q”退出vim 添加远程仓库git remote add 仓库名（本地自拟） git@xxx.github.com:用户名/仓库.git 如果是推到新的仓库，出现以下情况， 则是：远程仓库中有着本地仓库没有的文件，由于远程仓库和本地仓库没有共同的commit，需要先pull拒绝合并不相关的历史所以需要： git pull origin master --allow-unrelated-histories 完成！","categories":[{"name":"git","slug":"git","permalink":"https://luan-bx.github.io/categories/git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://luan-bx.github.io/tags/Git/"}]},{"title":"Markdown","slug":"Markdown","date":"2022-02-16T14:06:12.000Z","updated":"2023-03-08T07:14:29.078Z","comments":true,"path":"2022/02/16/markdown/","link":"","permalink":"https://luan-bx.github.io/2022/02/16/markdown/","excerpt":"","text":"Markdown 是一种轻量级标记语言，它用简洁的语法代替排版，使我们专心于码字。它的目标是实现易读易写，成为一种适用于网络的书写语言。同时，Markdown支持嵌入html标签。注意：符号后面必须跟至少1个空格才有效！ 常用命令标题# 一级标题 ## 二级标题 ### 三级标题 列表 Red Green Blue - Red - Green - Blue 标号 Red Green Blue 1. Red 2. Green 3. Blue 打开本地服务器 一级引用 二级引用 三级引用 引用 ，注意：在&gt;后面有 1 个空格 这是引用的代码块形式 //在`&gt;`后面有 5 个空格 代码例子： protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } > 一级引用 > > 二级引用 > > > 三级引用 > 引用 ，注意：在`>`后面有 1 个空格 > > 这是引用的代码块形式 //在`>`后面有 5 个空格 > 代码例子： protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); }","categories":[{"name":"语言","slug":"语言","permalink":"https://luan-bx.github.io/categories/%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://luan-bx.github.io/tags/Markdown/"}]},{"title":"Hexo","slug":"hexo","date":"2022-02-15T07:21:33.000Z","updated":"2023-03-08T07:14:22.756Z","comments":true,"path":"2022/02/15/hexo/","link":"","permalink":"https://luan-bx.github.io/2022/02/15/hexo/","excerpt":"","text":"常用命令清理hexo clean 构建静态文件hexo g 上传至仓库hexo d 打开本地服务器hexo server //可进行本地调试","categories":[{"name":"框架","slug":"框架","permalink":"https://luan-bx.github.io/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://luan-bx.github.io/tags/Hexo/"}]}],"categories":[{"name":"Cookie和Session","slug":"Cookie和Session","permalink":"https://luan-bx.github.io/categories/Cookie%E5%92%8CSession/"},{"name":"前后端交互","slug":"前后端交互","permalink":"https://luan-bx.github.io/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/"},{"name":"MySQL命令","slug":"MySQL命令","permalink":"https://luan-bx.github.io/categories/MySQL%E5%91%BD%E4%BB%A4/"},{"name":"CRUD","slug":"CRUD","permalink":"https://luan-bx.github.io/categories/CRUD/"},{"name":"rtsp视频流","slug":"rtsp视频流","permalink":"https://luan-bx.github.io/categories/rtsp%E8%A7%86%E9%A2%91%E6%B5%81/"},{"name":"开发常见问题","slug":"开发常见问题","permalink":"https://luan-bx.github.io/categories/%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"name":"监听器","slug":"监听器","permalink":"https://luan-bx.github.io/categories/%E7%9B%91%E5%90%AC%E5%99%A8/"},{"name":"String类","slug":"String类","permalink":"https://luan-bx.github.io/categories/String%E7%B1%BB/"},{"name":"HTML标签属性","slug":"HTML标签属性","permalink":"https://luan-bx.github.io/categories/HTML%E6%A0%87%E7%AD%BE%E5%B1%9E%E6%80%A7/"},{"name":"Sokect","slug":"Sokect","permalink":"https://luan-bx.github.io/categories/Sokect/"},{"name":"系统参数","slug":"系统参数","permalink":"https://luan-bx.github.io/categories/%E7%B3%BB%E7%BB%9F%E5%8F%82%E6%95%B0/"},{"name":"前端加弹窗","slug":"前端加弹窗","permalink":"https://luan-bx.github.io/categories/%E5%89%8D%E7%AB%AF%E5%8A%A0%E5%BC%B9%E7%AA%97/"},{"name":"接口","slug":"接口","permalink":"https://luan-bx.github.io/categories/%E6%8E%A5%E5%8F%A3/"},{"name":"文件","slug":"文件","permalink":"https://luan-bx.github.io/categories/%E6%96%87%E4%BB%B6/"},{"name":"开发笔记","slug":"开发笔记","permalink":"https://luan-bx.github.io/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/categories/Java/"},{"name":"TCP","slug":"TCP","permalink":"https://luan-bx.github.io/categories/TCP/"},{"name":"数据库","slug":"数据库","permalink":"https://luan-bx.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"git","slug":"git","permalink":"https://luan-bx.github.io/categories/git/"},{"name":"语言","slug":"语言","permalink":"https://luan-bx.github.io/categories/%E8%AF%AD%E8%A8%80/"},{"name":"框架","slug":"框架","permalink":"https://luan-bx.github.io/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Cookie","slug":"Cookie","permalink":"https://luan-bx.github.io/tags/Cookie/"},{"name":"Session","slug":"Session","permalink":"https://luan-bx.github.io/tags/Session/"},{"name":"HTML","slug":"HTML","permalink":"https://luan-bx.github.io/tags/HTML/"},{"name":"标签属性","slug":"标签属性","permalink":"https://luan-bx.github.io/tags/%E6%A0%87%E7%AD%BE%E5%B1%9E%E6%80%A7/"},{"name":"交互数据","slug":"交互数据","permalink":"https://luan-bx.github.io/tags/%E4%BA%A4%E4%BA%92%E6%95%B0%E6%8D%AE/"},{"name":"MySQL","slug":"MySQL","permalink":"https://luan-bx.github.io/tags/MySQL/"},{"name":"Linux","slug":"Linux","permalink":"https://luan-bx.github.io/tags/Linux/"},{"name":"CRUD","slug":"CRUD","permalink":"https://luan-bx.github.io/tags/CRUD/"},{"name":"module","slug":"module","permalink":"https://luan-bx.github.io/tags/module/"},{"name":"rtsp视频流","slug":"rtsp视频流","permalink":"https://luan-bx.github.io/tags/rtsp%E8%A7%86%E9%A2%91%E6%B5%81/"},{"name":"视频","slug":"视频","permalink":"https://luan-bx.github.io/tags/%E8%A7%86%E9%A2%91/"},{"name":"开发常见问题","slug":"开发常见问题","permalink":"https://luan-bx.github.io/tags/%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"name":"Java","slug":"Java","permalink":"https://luan-bx.github.io/tags/Java/"},{"name":"文件操作","slug":"文件操作","permalink":"https://luan-bx.github.io/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"name":"监听器","slug":"监听器","permalink":"https://luan-bx.github.io/tags/%E7%9B%91%E5%90%AC%E5%99%A8/"},{"name":"String类","slug":"String类","permalink":"https://luan-bx.github.io/tags/String%E7%B1%BB/"},{"name":"TCP","slug":"TCP","permalink":"https://luan-bx.github.io/tags/TCP/"},{"name":"Sokect","slug":"Sokect","permalink":"https://luan-bx.github.io/tags/Sokect/"},{"name":"传输对象","slug":"传输对象","permalink":"https://luan-bx.github.io/tags/%E4%BC%A0%E8%BE%93%E5%AF%B9%E8%B1%A1/"},{"name":"内存","slug":"内存","permalink":"https://luan-bx.github.io/tags/%E5%86%85%E5%AD%98/"},{"name":"磁盘","slug":"磁盘","permalink":"https://luan-bx.github.io/tags/%E7%A3%81%E7%9B%98/"},{"name":"网络","slug":"网络","permalink":"https://luan-bx.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"html","slug":"html","permalink":"https://luan-bx.github.io/tags/html/"},{"name":"Code","slug":"Code","permalink":"https://luan-bx.github.io/tags/Code/"},{"name":"接口","slug":"接口","permalink":"https://luan-bx.github.io/tags/%E6%8E%A5%E5%8F%A3/"},{"name":"继承","slug":"继承","permalink":"https://luan-bx.github.io/tags/%E7%BB%A7%E6%89%BF/"},{"name":"开发笔记","slug":"开发笔记","permalink":"https://luan-bx.github.io/tags/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"},{"name":"Java笔记","slug":"Java笔记","permalink":"https://luan-bx.github.io/tags/Java%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"https://luan-bx.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Git","slug":"Git","permalink":"https://luan-bx.github.io/tags/Git/"},{"name":"Markdown","slug":"Markdown","permalink":"https://luan-bx.github.io/tags/Markdown/"},{"name":"Hexo","slug":"Hexo","permalink":"https://luan-bx.github.io/tags/Hexo/"}]}